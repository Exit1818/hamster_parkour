设置
{
	主程序
	{
		描述: "键盘"
	}

	大厅
	{
		比赛语音聊天: 启用
		玩家上限 队伍1: 12
		玩家上限 队伍2: 0
		观战者人数上限: 6
		返回大厅: 从不
		队列中的玩家可以加入: 是
	}

	模式
	{
		团队死斗
		{
			启用地图
			{
			}
		}

		突击模式
		{
			启用地图
			{
				监测站：直布罗陀
			}
		}

		训练靶场
		{
			启用地图
			{
			}
		}

		禁用 运载目标
		{
			运载目标速度: 10%
		}

		综合
		{
			允许切换英雄: 关闭
			复生时间: 5%
			急救包刷新: 禁用
			消灭提示: 关闭
			消灭镜头: 关闭
			游戏模式开始: 即时
			英雄限制: 关闭
			随机英雄复生: 开启
		}
	}

	英雄
	{
		综合
		{
			无需装弹: 开启
			终极技能充能速度: 10%
			终极技能自动充能速度: 0%
			重生时终极技能充能完毕: 开启

			末日铁拳
			{
				上勾重拳 冷却时间: 12%
				火箭重拳 冷却时间: 6%
				终极技能（毁天灭地）: 关闭
				裂地重拳 冷却时间: 6%
			}

			源氏
			{
				重生时终极技能充能完毕: 开启
			}

			破坏球
			{
				动力铁球始终激活: 开启
				终极技能（地雷禁区）: 关闭
				重力坠击 冷却时间: 0%
			}

			启用英雄
			{
				破坏球
			}
		}
	}

	地图工坊
	{
		X-position: -3.000
		Y-position: 0.000
	}
}

变量
{
	全局:
		98: xPos
		99: yPos
		100: textX
		101: textY
		102: scale
		104: button
		105: text
		106: textSize

	玩家:
		100: keyboard_enabled
		101: keyboard_status_space
		102: keyboard_status_ctrl
		103: keyboard_status_right
		104: keyboard_status_left
}


规则("Initial Global")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.xPos = 地图工坊设置实数(自定义字符串("键盘设置"), 自定义字符串("X-position"), -1.4, -3, 3, 0);
		全局.yPos = 地图工坊设置实数(自定义字符串("键盘设置"), 自定义字符串("Y-position"), -0.3, -2, 2, 0);
		全局.scale = 地图工坊设置实数(自定义字符串("键盘设置"), 自定义字符串("Scale"), 0.720, 0.300, 1, 1);
	}
}

规则("[热键] 开关键盘")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
	}

	动作
	{
		事件玩家.keyboard_enabled = !事件玩家.keyboard_enabled;
	}
}

规则("[热键] 按下跳跃")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
	}

	动作
	{
		事件玩家.keyboard_status_space = 真;
	}
}

规则("[热键] 松开跳跃")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
	}

	动作
	{
		事件玩家.keyboard_status_space = 假;
	}
}

规则("[热键] 按下蹲")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
	}

	动作
	{
		事件玩家.keyboard_status_ctrl = 真;
	}
}

规则("[热键] 松开蹲")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
	}

	动作
	{
		事件玩家.keyboard_status_ctrl = 假;
	}
}

规则("[热键] 按下右键")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		事件玩家.keyboard_status_right = 真;
	}
}

规则("[热键] 松开右键")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 假;
	}

	动作
	{
		事件玩家.keyboard_status_right = 假;
	}
}

规则("[热键] 按下左键")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
	}

	动作
	{
		事件玩家.keyboard_status_left = 真;
	}
}

规则("[热键] 松开左键")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 假;
	}

	动作
	{
		事件玩家.keyboard_status_left = 假;
	}
}

规则("Create Overlay - Classic keyboard layout")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.keyboard_enabled == 真;
	}

	动作
	{
		全局.textSize = 3.600;
		全局.textX = -0.353;
		全局.textY = 0.712;
		全局.text = 自定义字符串("Q");
		全局.button = 按钮(终极技能);
		全局.text = 自定义字符串("W");
		全局.textX += 0.269;
		创建地图文本(已过滤的数组(事件玩家, 事件玩家.keyboard_enabled == 真), 单次赋值(自定义字符串("▒")), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 4 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, 颜色(黑色), 始终不可见);
		等待(0.016, 无视条件);
		创建地图文本(已过滤的数组(事件玩家, 事件玩家.keyboard_enabled == 真), 单次赋值(全局.text), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 3.700 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, Z方向分量(阈值(事件玩家)) > 0.100 ? 颜色(白色) : 自定义颜色(33, 33, 33, 255),
			始终不可见);
		全局.text = 自定义字符串("E");
		全局.textX += 0.269;
		全局.button = 按钮(技能2);
		全局.text = 自定义字符串("R");
		全局.textX += 0.269;
		全局.button = 按钮(装填);
		全局.textX += 0.538;
		创建地图文本(已过滤的数组(事件玩家, 事件玩家.keyboard_enabled == 真), 事件玩家.keyboard_status_left ? 输入绑定字符串(按钮(主要攻击模式)) : 自定义字符串(""), 逐帧更新(眼睛位置(事件玩家)
			+ 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale)) * 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale)
			- 0.200 - 0.040 * 全局.scale) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家)) - 90) + 3 * 面朝方向(事件玩家))),
			3.200 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, 颜色(白色), 始终不可见);
		全局.textX += 0.269;
		创建地图文本(已过滤的数组(事件玩家, 事件玩家.keyboard_enabled == 真), 事件玩家.keyboard_status_right ? 输入绑定字符串(按钮(辅助攻击模式)) : 自定义字符串(""), 逐帧更新(眼睛位置(事件玩家)
			+ 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale)) * 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale)
			- 0.200 - 0.040 * 全局.scale) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家)) - 90) + 3 * 面朝方向(事件玩家))),
			3.200 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, 颜色(白色), 始终不可见);
		"Row 2"
		全局.textY -= 0.253;
		全局.text = 自定义字符串("A");
		全局.textX = -0.229;
		创建地图文本(已过滤的数组(事件玩家, 事件玩家.keyboard_enabled == 真), 单次赋值(自定义字符串("▒")), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 4 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, 颜色(黑色), 始终不可见);
		等待(0.016, 无视条件);
		创建地图文本(已过滤的数组(事件玩家, 事件玩家.keyboard_enabled == 真), 单次赋值(全局.text), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 3.700 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, X方向分量(阈值(事件玩家)) > 0.100 ? 颜色(白色) : 自定义颜色(33, 33, 33, 255),
			始终不可见);
		全局.text = 自定义字符串("S");
		全局.textX += 0.269;
		创建地图文本(已过滤的数组(事件玩家, 事件玩家.keyboard_enabled == 真), 单次赋值(自定义字符串("▒")), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 4 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, 颜色(黑色), 始终不可见);
		等待(0.016, 无视条件);
		创建地图文本(已过滤的数组(事件玩家, 事件玩家.keyboard_enabled == 真), 单次赋值(全局.text), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 3.700 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, Z方向分量(阈值(事件玩家)) < -0.100 ? 颜色(白色) : 自定义颜色(33, 33, 33, 255),
			始终不可见);
		全局.text = 自定义字符串("D");
		全局.textX += 0.269;
		创建地图文本(已过滤的数组(事件玩家, 事件玩家.keyboard_enabled == 真), 单次赋值(自定义字符串("▒")), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 4 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, 颜色(黑色), 始终不可见);
		等待(0.016, 无视条件);
		创建地图文本(已过滤的数组(事件玩家, 事件玩家.keyboard_enabled == 真), 单次赋值(全局.text), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 3.700 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, X方向分量(阈值(事件玩家)) < -0.100 ? 颜色(白色) : 自定义颜色(33, 33, 33, 255),
			始终不可见);
		全局.text = 自定义字符串("F");
		全局.textX += 0.269;
		全局.button = 按钮(互动);
		"Row 3"
		全局.textSize = 3;
		全局.textY -= 0.253;
		全局.text = 自定义字符串("Shift");
		全局.textX = -0.478;
		全局.button = 按钮(技能1);
		全局.text = 自定义字符串("V");
		全局.textX = 0.975;
		全局.button = 按钮(近身攻击);
		全局.textSize = 3.600;
		"Row 4"
		全局.textY -= 0.253;
		全局.text = 自定义字符串("Ctrl");
		全局.textX = -0.584;
		全局.button = 按钮(蹲下);
		全局.textSize = 2;
		创建地图文本(已过滤的数组(事件玩家, 事件玩家.keyboard_enabled == 真), 单次赋值(全局.text == 自定义字符串("Shift") ? 自定义字符串("▒▒") : (全局.text == 自定义字符串("Space")
			? 自定义字符串("▒▒▒▒▒▒") : 自定义字符串("▒"))), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale)) * 地图矢量(右, 事件玩家, 旋转) + (
			全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家)) - 90) + 3 * 面朝方向(事件玩家))),
			4 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, 自定义颜色(0, 0, 0, 180), 始终不可见);
		等待(0.016, 无视条件);
		创建地图文本(已过滤的数组(事件玩家, 事件玩家.keyboard_enabled == 真), 单次赋值(全局.text), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 单次赋值(全局.textSize * 全局.scale), 不要截取, 可见，位置，字符串和颜色, 事件玩家.keyboard_status_ctrl ? 颜色(白色) : 自定义颜色(33, 33,
			33, 255), 始终不可见);
		全局.text = 自定义字符串("Space");
		全局.textX = 0.446;
		全局.button = 按钮(跳跃);
		全局.textSize = 3;
		创建地图文本(已过滤的数组(事件玩家, 事件玩家.keyboard_enabled == 真), 单次赋值(全局.text == 自定义字符串("Shift") ? 自定义字符串("▒▒") : (全局.text == 自定义字符串("Space")
			? 自定义字符串("▒▒▒▒▒▒") : 自定义字符串("▒"))), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale)) * 地图矢量(右, 事件玩家, 旋转) + (
			全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家)) - 90) + 3 * 面朝方向(事件玩家))),
			4 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, 自定义颜色(0, 0, 0, 180), 始终不可见);
		等待(0.016, 无视条件);
		创建地图文本(已过滤的数组(事件玩家, 事件玩家.keyboard_enabled == 真), 单次赋值(全局.text), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 单次赋值(全局.textSize * 全局.scale), 不要截取, 可见，位置，字符串和颜色, 事件玩家.keyboard_status_space ? 颜色(白色) : 自定义颜色(33, 33,
			33, 255), 始终不可见);
	}
}
