设置
{
	主程序
	{
		描述: "作者：蛇                                                                                                                     地图代码：20026                                                                                                                     ERIS制作器  当前版本1.25 代码:RRR5K                                                                                                                     bug反馈/获取更新群号：1019712301"
	}

	大厅
	{
		比赛结束后转换队伍: 否
		比赛语音聊天: 启用
		观战者人数上限: 6
		队列中的玩家可以加入: 是
	}

	模式
	{
		突击模式
		{
			启用地图
			{
				伊利奥斯
			}
		}

		综合
		{
			允许切换英雄: 关闭
			复生时间: 0%
			急救包刷新: 禁用
			敌方生命条: 关闭
			消灭提示: 关闭
			消灭镜头: 关闭
			游戏模式开始: 手动
			英雄限制: 关闭
			随机英雄复生: 开启
		}
	}

	英雄
	{
		综合
		{
			D.Va
			{
				无机甲重生: 开启
				重生时终极技能充能完毕: 开启
			}

			法老之鹰
			{
				悬浮背包充能速度: 500%
				战斗时终极技能充能速度 火箭弹幕: 500%
				推进背包 冷却时间: 0%
				无需装弹: 开启
				终极技能充能速度（火箭弹幕）: 500%
				终极技能自动充能速度 火箭弹幕: 500%
				重生时终极技能充能完毕: 开启
				震荡冲击 冷却时间: 0%
			}

			源氏
			{
				影: 关闭
				无需装弹: 开启
				终极技能持续时间: 25%
				终极技能（斩）: 关闭
				闪 冷却时间: 0%
			}

			启用英雄
			{
				源氏
			}
		}
	}
}

变量
{
	全局:
		0: GameMode
		1: EditingPositionDataBuffer
		2: GlobalTextID
		3: GlobalEffectID
		4: ConveryPos
		5: CircleRadius
		6: FinishedPlayerArr
		7: EditingLevel
		8: EditingPositionDataIndex
		9: QData
		10: SData
		11: CameraPos
		12: MenuPos
		13: LevelNameArr
		14: Index
		15: OstacleBallPos
		16: OstacleBallRadius
		17: PinballPos
		18: PinballElasticForce
		19: flag
		20: ConveryPosArray
		21: EditingMode
		22: Trampoline
		23: TrampolinePos
		24: EditorName
		25: DVAPosArr
		26: Level1Data
		27: Level2Data
		28: Level3Data
		29: OstacleBallIndex
		30: PinballIndex
		31: Blacklist
		32: OptimizationFlag
		33: DestText
		34: AllEditorsCodeText
		35: HintText
		36: HintEffectPosArr
		37: HintEffectIndex
		38: MaxDeathNum

	玩家:
		0: myPosData
		1: currentPos
		2: timer
		3: myEffectID
		4: myTextID
		5: userBuffer
		6: level
		7: invincible
		8: optionNum
		9: posBuffer
		10: climbSign
		11: jumpSign
		12: leveFlag
		13: deathNum
		14: skipFlag
		15: delay
}

子程序
{
	0: resetGlobalData
	1: resetGlobalText
	2: createEditingModeText
	3: createPlayerModeText
	4: resetPlayerData
	5: resetPlayerText
	6: startTimer
	7: stopTimer
	8: resetDestEffect
	9: reachTarget
	10: playerDeath
	11: playerWin
	12: deliverPlayer
	18: importData
	20: sendPlayerToCurrentPos
	21: loadLevel
	23: refreashBallEffect
	25: importAllData
	26: resetCamera
	27: resetEditorName
	28: enableRecording
	29: disableRecording
	30: fixData
}

规则("开启该规则为玩家模式，关闭后则为编辑模式（作者应先关闭该规则后开始作图）")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.GameMode = 1;
	}
}

规则("---------------------数据导入 将复制的数据全粘贴进该规则（注：每次粘贴前记得全选动作并且删除）-------------------------")
{
	事件
	{
		子程序;
		importAllData;
	}

	动作
	{
		全局.EditingPositionDataBuffer = 数组(矢量(115.908, 60.367, -158.266), 矢量(97.896, 65.562, -156.721), 矢量(83.256, 60.072, -170.235), 矢量(
			65.466, 66.635, -178.617), 矢量(51.515, 65.245, -160.154), 矢量(33.036, 61.644, -146.773), 矢量(14.340, 62.698, -151.464), 矢量(-4.731,
			62.681, -165.011), 矢量(-18.569, 67.514, -168.503), 矢量(-43.980, 60.367, -172.903), 矢量(-43.355, 65.560, -156.661), 矢量(-63.282,
			61.253, -158.911), 矢量(-140.063, 1.240, -78.297), 矢量(-153.848, 2.893, -61.374), 矢量(-179.471, 0.846, -54.612), 矢量(-185.217,
			5.093, -32.686), 矢量(-197.724, 9.894, -12.751), 矢量(-207.432, 5.229, 10.764), 矢量(-232.643, 3.398, 2.177), 矢量(-260.734, -4.444,
			0.363), 矢量(-280.399, -0.202, 16.949), 矢量(-275.844, -3.288, 35.329), 矢量(306.919, -16.760, 27.555), 矢量(325.731, -17.196, 14.944),
			矢量(354.159, -24.779, 13.980), 矢量(351.813, -20.568, -5.609), 矢量(352.798, -25.643, -35.118), 矢量(349.743, -17.776, -54.537), 矢量(
			327.950, -18.460, -51.714), 矢量(304.742, -23.992, -57.370), 矢量(289.681, -17.453, -71.092), 矢量(276.175, -18.414, -74.678), 矢量(
			295.146, -20.642, -77.704), 矢量(304.390, -25.171, -97.634), 矢量(311.601, -20.392, -99.683), 矢量(322.801, -20.712, -74.523), 矢量(
			337.757, -23.999, -63.195), 矢量(342.263, -23.643, -42.994), 矢量(357.730, -27.642, -20.906), 矢量(349.747, -18.641, -24.468), 矢量(
			353.021, -20.567, -2.550));
		全局.GlobalTextID = 数组();
		全局.GlobalEffectID = 数组();
		全局.ConveryPos = 数组(矢量(0, 0, 0), 矢量(0, 0, 0), 矢量(0, 0, 0));
		全局.CircleRadius = 1.400;
		全局.FinishedPlayerArr = 数组();
		全局.EditingLevel = 1;
		全局.EditingPositionDataIndex = 6;
		全局.QData = 数组();
		全局.SData = 数组();
		全局.CameraPos = 矢量(-0.241, 97.202, 113.842);
		全局.MenuPos = 矢量(-0.003, 97.202, 106.085);
		全局.LevelNameArr = 数组(自定义字符串("难度1"), 自定义字符串("难度2"), 自定义字符串("难度3"));
		全局.Index = 5;
		全局.OstacleBallPos = 数组();
		全局.OstacleBallRadius = 数组();
		全局.PinballPos = 数组();
		全局.PinballElasticForce = 数组(9);
		全局.ConveryPosArray = 数组(13, 26, 261, 271, 511, 526);
		全局.Trampoline = 数组();
		全局.TrampolinePos = 数组();
		全局.EditorName = 自定义字符串("ERIS#5814");
		全局.DVAPosArr = 数组();
		全局.Level1Data = 数组(矢量(121.648, 61.566, -158.916), 矢量(107.043, 64.396, -155.877), 矢量(88.783, 68.515, -150.545), 矢量(68.132, 63.557,
			-146.074), 矢量(51.641, 65.203, -156.021), 矢量(33.303, 61.642, -145.129), 矢量(14.578, 62.701, -151.700), 矢量(8.050, 63.712,
			-171.813), 矢量(-4.456, 69.401, -180.516), 矢量(-18.808, 70.033, -180.955), 矢量(-24.022, 68.067, -157.718), 矢量(-40.812, 61.533,
			-166.035), 矢量(-56.429, 65.247, -170.997), 矢量(-58.373, 60.727, -148.952), 矢量(-179.749, 1.054, -95.978), 矢量(-167.462, -0.449,
			-79.304), 矢量(-152.593, 3, -70.930), 矢量(-161.652, 5.032, -53.917), 矢量(-173.875, 5.126, -32.746), 矢量(-188.086, 5.229, -15.556),
			矢量(-205.192, 9.894, -5.387), 矢量(-225.571, 5.238, 20.066), 矢量(-246.779, 4.858, 31.128), 矢量(-269.899, 0.440, 45.695), 矢量(
			-276.060, -5.001, 22.250), 矢量(-285.571, 1.318, 17.465), 矢量(-261.866, -5.106, 3.400), 矢量(272.288, -16.849, -69.768), 矢量(289.040,
			-17.805, -72.914), 矢量(305.466, -16.162, -75.446), 矢量(320.429, -24.086, -91.099), 矢量(337.610, -26.654, -81.381), 矢量(337.942,
			-23.759, -62.767), 矢量(325.090, -18.377, -56.535), 矢量(333.880, -23.658, -34.708), 矢量(319.580, -23.708, -16.761), 矢量(330.405,
			-24.641, 1.254), 矢量(335.442, -16.262, 10.544), 矢量(357.805, -24.484, -0.878), 矢量(364.473, -25.945, -17.217), 矢量(353.999,
			-23.731, -25.120));
		全局.Level2Data = 数组(矢量(115.908, 60.367, -158.266), 矢量(97.896, 65.562, -156.721), 矢量(83.256, 60.072, -170.235), 矢量(65.466, 66.635,
			-178.617), 矢量(51.515, 65.245, -160.154), 矢量(33.036, 61.644, -146.773), 矢量(14.340, 62.698, -151.464), 矢量(-4.731, 62.681,
			-165.011), 矢量(-18.569, 67.514, -168.503), 矢量(-43.980, 60.367, -172.903), 矢量(-43.355, 65.560, -156.661), 矢量(-63.282, 61.253,
			-158.911), 矢量(-140.063, 1.240, -78.297), 矢量(-153.848, 2.893, -61.374), 矢量(-179.471, 0.846, -54.612), 矢量(-185.217, 5.093,
			-32.686), 矢量(-197.724, 9.894, -12.751), 矢量(-207.432, 5.229, 10.764), 矢量(-232.643, 3.398, 2.177), 矢量(-260.734, -4.444, 0.363),
			矢量(-280.399, -0.202, 16.949), 矢量(-275.844, -3.288, 35.329), 矢量(306.919, -16.760, 27.555), 矢量(325.731, -17.196, 14.944), 矢量(
			354.159, -24.779, 13.980), 矢量(351.813, -20.568, -5.609), 矢量(352.798, -25.643, -35.118), 矢量(349.743, -17.776, -54.537), 矢量(
			327.950, -18.460, -51.714), 矢量(304.742, -23.992, -57.370), 矢量(289.681, -17.453, -71.092), 矢量(276.175, -18.414, -74.678), 矢量(
			295.146, -20.642, -77.704), 矢量(304.390, -25.171, -97.634), 矢量(311.601, -20.392, -99.683), 矢量(322.801, -20.712, -74.523), 矢量(
			337.757, -23.999, -63.195), 矢量(342.263, -23.643, -42.994), 矢量(357.730, -27.642, -20.906), 矢量(349.747, -18.641, -24.468), 矢量(
			353.021, -20.567, -2.550));
		全局.Level3Data = 数组(矢量(109.163, 64.444, -160.549), 矢量(107.891, 62.596, -182.949), 矢量(82.389, 60.322, -168.694), 矢量(68.666, 63.731,
			-145.451), 矢量(64.622, 66.662, -169.898), 矢量(40.257, 62.698, -151.960), 矢量(12.821, 60.366, -146.681), 矢量(-0.298, 62.911,
			-139.980), 矢量(-30.993, 60.939, -141.916), 矢量(-18.617, 67.515, -168.317), 矢量(-43.657, 63.499, -171.566), 矢量(-64.335, 60.367,
			-155.988), 矢量(276.188, -18.429, -74.359), 矢量(280.583, -25.671, -96.771), 矢量(304.699, -24.438, -94.992), 矢量(294.710, -20.642,
			-75.106), 矢量(311.179, -24.078, -82.938), 矢量(337.724, -26.646, -81.396), 矢量(338.229, -23.642, -58.236), 矢量(324.809, -17.282,
			-57.085), 矢量(344.741, -23.642, -36.890), 矢量(325.158, -20.642, -14.633), 矢量(349.111, -20.747, -10.317), 矢量(364.311, -24.495,
			4.801), 矢量(347.425, -25.651, 23.032), 矢量(332.107, -20.740, 11.074), 矢量(315.297, -16.079, 23.854), 矢量(-144.709, 4.754, -72.600),
			矢量(-179.798, 0.956, -95.821), 矢量(-173.619, -4.819, -65.084), 矢量(-161.495, 6.532, -50.428), 矢量(-188.653, 4.346, -57.544), 矢量(
			-201.827, 0.998, -37.905), 矢量(-213.448, 10.011, -25.147), 矢量(-204.285, 9.895, -5.719), 矢量(-228.735, 5.246, 22.558), 矢量(
			-253.807, 3.183, 39.016), 矢量(-275.768, -3.761, 33.266), 矢量(-267.533, -3.377, 8.413), 矢量(-243.027, -1, 7.229), 矢量(-213.242,
			5.229, 16.689));
		全局.OstacleBallIndex = 数组();
		全局.PinballIndex = 数组();
		全局.Blacklist = 数组(自定义字符串("黑白剑舞"));
		全局.OptimizationFlag = 1;
		全局.DestText = 自定义字符串("到这儿来！");
		全局.AllEditorsCodeText = 自定义字符串("");
		全局.HintEffectPosArr = 数组(矢量(109.618, 60.275, -156.663), 矢量(90.631, 60.363, -153.124), 矢量(74.858, 59.744, -147.606), 矢量(54.786,
			60.776, -155.219), 矢量(36.555, 58.345, -151.708), 矢量(30.416, 65.101, -148.755), 矢量(17.157, 60.842, -151.390), 矢量(14.715, 64.191,
			-162.813), 矢量(10.538, 61.294, -169.479), 矢量(2.140, 67.189, -172.397), 矢量(-23.512, 59.090, -163.046), 矢量(-32.525, 66.982,
			-161.188), 矢量(-57.076, 68.995, -165.241), 矢量(-172.076, 2.226, -87.501), 矢量(-156.274, -2.224, -76.807), 矢量(-153.902, -0.063,
			-71.304), 矢量(-158.157, 1.480, -61.720), 矢量(-161.512, 2.866, -54.671), 矢量(-164.332, 5.421, -50.013), 矢量(-170.506, 7.678,
			-41.835), 矢量(-177.748, 9.046, -26.020), 矢量(-199.667, 3.862, -13.118), 矢量(-210.516, 9.423, 6.912), 矢量(-222.007, 4.266, 19.469),
			矢量(-236.095, 4.239, 20.385), 矢量(-254.829, 2.835, 36.383), 矢量(-261.346, 2.745, 39.806), 矢量(-275.461, -4.324, 37.992), 矢量(
			-275.237, -5.583, 30.072), 矢量(-276.876, 0.386, 16.408), 矢量(279.084, -18.574, -71.699), 矢量(295.779, -16.879, -73.368), 矢量(
			309.479, -16.494, -79.094), 矢量(326.251, -24.272, -86.055), 矢量(332.333, -26.239, -84.740), 矢量(338.556, -24.696, -76.144), 矢量(
			338.186, -25.031, -65.894), 矢量(336.995, -21.073, -63.018), 矢量(329.310, -23.674, -45.097), 矢量(330.498, -22.737, -24.561), 矢量(
			338.382, -15.751, 8.840), 矢量(346.983, -16.136, 8.049), 矢量(365.402, -25.340, -12.854), 矢量(325.809, -23.660, -7.603), 矢量(110.204,
			60.650, -158.153), 矢量(101.097, 64.252, -156.889), 矢量(91.415, 66.742, -159.166), 矢量(76.747, 62.290, -174.529), 矢量(66.387,
			65.599, -178.466), 矢量(58.546, 65.766, -167.434), 矢量(54.525, 63.735, -161.139), 矢量(36.641, 58.410, -150.926), 矢量(30.320, 64.862,
			-148.404), 矢量(17.341, 61.212, -151.545), 矢量(-11.465, 62.730, -164.475), 矢量(-32.788, 59.594, -172.880), 矢量(-40.539, 58.849,
			-173.069), 矢量(-43.358, 60.899, -167.987), 矢量(-43.044, 63.541, -158.534), 矢量(-49.039, 64.210, -157.537), 矢量(-147.144, 0.026,
			-68.314), 矢量(-153.030, 1.964, -61.901), 矢量(-162.455, 2.766, -59.537), 矢量(-178.323, -1.937, -53.450), 矢量(-181.147, 3.613,
			-44.287), 矢量(-183.274, 7.217, -27.162), 矢量(-196.166, 8.582, -13.898), 矢量(-207.097, 3.701, 3.841), 矢量(-209.223, 7.592, 8.411),
			矢量(-230.832, 1.841, 2.559), 矢量(-237.947, 5.388, 1.619), 矢量(-262.731, -1.380, 0.798), 矢量(-269.807, 5.302, 10.657), 矢量(-276.104,
			-7.177, 29.524), 矢量(-276.606, -4.597, 33.293), 矢量(316.854, -18.709, 18.227), 矢量(338.475, -19.705, 12.055), 矢量(354.188, -21.303,
			12.948), 矢量(353.626, -21.889, -1.884), 矢量(351.469, -18.394, -10.175), 矢量(353.270, -24.445, -28.769), 矢量(354.552, -24.123,
			-40.620), 矢量(350.991, -19.703, -51.004), 矢量(337.268, -21.597, -55.785), 矢量(318.956, -21.067, -51.324), 矢量(308.433, -17.212,
			-52.330), 矢量(293.622, -23.975, -64.985), 矢量(289.481, -18.901, -70.636), 矢量(285.243, -16.008, -72.288), 矢量(280.893, -18.757,
			-75.221), 矢量(299.801, -18.817, -83.623), 矢量(306.645, -20.051, -89.958), 矢量(319.538, -21.542, -83.098), 矢量(320.914, -21.281,
			-79.192), 矢量(323.655, -18.120, -73.342), 矢量(330.219, -14.870, -70.282), 矢量(339.358, -22.625, -58.875), 矢量(341.499, -24.766,
			-45.972), 矢量(347.224, -24.719, -34.706), 矢量(351.793, -24.841, -30.133), 矢量(354.331, -24.656, -25.520), 矢量(352.447, -19.620,
			-25.266), 矢量(354.166, -16.985, -22.021), 矢量(109.883, 65.513, -170.373), 矢量(109.893, 65.357, -178.061), 矢量(100.929, 63.983,
			-181.115), 矢量(90.043, 63.048, -175.268), 矢量(80.663, 61.534, -163.312), 矢量(80.553, 66.854, -152.003), 矢量(56.860, 64.043,
			-166.970), 矢量(52.518, 64.301, -162.194), 矢量(31.505, 64.174, -148.745), 矢量(21.572, 60.156, -143.460), 矢量(5.880, 65.117,
			-149.292), 矢量(-0.052, 61.936, -141.169), 矢量(-10.354, 63.010, -145.082), 矢量(-27.667, 59.382, -141.799), 矢量(-28.322, 64.016,
			-150.354), 矢量(-21.400, 68.330, -162.807), 矢量(-32.573, 61.949, -172.961), 矢量(-43.501, 62.459, -172.041), 矢量(-50.407, 62.056,
			-162.057), 矢量(-53.548, 64.698, -156.689), 矢量(278.068, -19.958, -81.760), 矢量(276.181, -24.518, -88.179), 矢量(288.896, -22.076,
			-102.032), 矢量(302.783, -25.833, -98.543), 矢量(301.431, -21.542, -87.331), 矢量(297.822, -17.317, -79.727), 矢量(298.447, -19.558,
			-71.370), 矢量(309.115, -19.589, -78.532), 矢量(318.985, -22.528, -82.907), 矢量(332.328, -25.444, -84.727), 矢量(338.356, -25.004,
			-76.333), 矢量(338.442, -24.314, -63.401), 矢量(336.085, -21.107, -62.248), 矢量(329.739, -16.999, -52.768), 矢量(340.721, -24.593,
			-46.844), 矢量(337.463, -19.126, -24.791), 矢量(331.985, -17.636, -20.269), 矢量(332.721, -18.574, -14.948), 矢量(341.289, -21.630,
			-13.552), 矢量(363.057, -20.592, 8.409), 矢量(354.480, -17.763, 12.721), 矢量(343.353, -23.964, 13.162), 矢量(335.082, -17.526,
			11.093), 矢量(327.433, -19.419, 17.741), 矢量(318.557, -18.869, 22.843), 矢量(-140.942, 7.196, -72.738), 矢量(-140.623, 9.947,
			-80.783), 矢量(-177.036, 0.527, -83.328), 矢量(-174.300, -1.243, -72.069), 矢量(-165.095, 0.038, -60.057), 矢量(-161.231, 3.923,
			-54.767), 矢量(-169.683, 5.801, -52.658), 矢量(-177.822, -1.928, -53.865), 矢量(-196.167, 7.608, -54.983), 矢量(-201.412, 3.397,
			-47.141), 矢量(-205.888, 1.675, -33.452), 矢量(-213.183, 8.084, -25.517), 矢量(-198.759, 0.165, -13.773), 矢量(-199.430, 7.896,
			-13.808), 矢量(-210.332, 8.490, 6.016), 矢量(-222.615, 3.575, 19.509), 矢量(-236.611, 4.142, 20.033), 矢量(-250.573, 1.377, 34.679),
			矢量(-261.043, 0.982, 43.451), 矢量(-273.491, -5.113, 37.466), 矢量(-272.012, -4.802, 24.390), 矢量(-265.970, -2.032, 14.548), 矢量(
			-260.144, -1.186, 8.577), 矢量(-248.907, -4.130, 16.651), 矢量(-236.139, 5.035, 10.517), 矢量(69.609, 66.850, -150.752), 矢量(69.984,
			67.572, -162.956), 矢量(353.858, -19.878, -7.038), 矢量(360.093, -23.638, -5.820), 矢量(4.858, 63.035, -157.502), 矢量(-3.882, 61.540,
			-164.737));
		全局.HintEffectIndex = 数组(0, 1, 2, 3, 4, 5, 755, 6, 756, 7, 9, 10, 12, 14, 15, 765, 16, 766, 17, 767, 18, 19, 20, 770, 21, 22, 772,
			23, 773, 25, 27, 28, 29, 30, 780, 31, 781, 32, 33, 34, 37, 787, 38, 35, 250, 1000, 251, 252, 1002, 253, 1003, 254, 255, 1005,
			257, 258, 1008, 259, 1009, 260, 262, 1012, 263, 1013, 264, 265, 1015, 266, 267, 1017, 268, 269, 1019, 270, 1020, 272, 273, 274,
			1024, 275, 1025, 276, 1026, 277, 278, 1028, 279, 1029, 280, 281, 282, 1032, 284, 1034, 285, 1035, 286, 1036, 287, 1037, 288,
			1038, 289, 500, 1250, 501, 1251, 502, 1252, 504, 1254, 505, 1255, 506, 1256, 507, 1257, 508, 1258, 509, 1259, 510, 1260, 512,
			1262, 513, 1263, 514, 1264, 515, 1265, 516, 1266, 517, 1267, 518, 519, 1269, 520, 1270, 521, 1271, 523, 1273, 524, 1274, 525,
			1275, 527, 1277, 528, 1278, 529, 1279, 530, 1280, 531, 1281, 532, 1282, 533, 1283, 534, 1284, 535, 1285, 536, 1286, 537, 1287,
			538, 1288, 539, 503, 1253, 522, 1272, 290, 1040);
		全局.MaxDeathNum = 数组(10000, 10000, 10000);
	}
}

规则("这里写作者名字，下个点位文本，您的所有地图代码，以及设置玩家最大死亡次数（超过了允许玩家跳关）")
{
	事件
	{
		子程序;
		resetEditorName;
	}

	动作
	{
		禁用 调用子程序(disableRecording);
		"自定义字符串下面打上你的名字"
		全局.EditorName = 自定义字符串("蛇 本图代码：20026");
		"自定义字符串下面打上你需要的下一关提示文本"
		全局.DestText = 自定义字符串("快来玩呀~");
		"自定义字符串下面打上你的一系列地图代码"
		全局.AllEditorsCodeText = 自定义字符串("卡关有手动跳关提示\r\n抬头有文字技巧教学\r\n通关可尝试\r\n大佬进阶图：C\r\rDCD5");
		"0为难度1的最大死亡次数，1为难度2的最大死亡次数，2为难度3的最大死亡次数，默认1w不用修改。"
		全局.MaxDeathNum = 数组(50, 50, 50);
	}
}

禁用 规则("多难度模式需要关闭此规则，单难度的图开启该规则，制作3难度时也必须关闭此规则，如开启该规则编辑模式不能切换难度")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		事件玩家.leveFlag = 1;
	}
}

规则("手动录制镜头位置，以及编辑每个等级（难度）的描述（默认：难度1 难度2 难度3），以及新增手动录制3小图通关传送门坐标（下面的对应规则也打开）")
{
	事件
	{
		子程序;
		resetCamera;
	}

	动作
	{
		全局.ConveryPos = 数组(矢量(358.351, -24.442, -47.862), 矢量(-214.053, 1.199, -11.237), 矢量(28.347, 58.566, -159.569));
		全局.CameraPos = 矢量(233.307, -23.232, 153.394);
		全局.MenuPos = 矢量(238.974, -23.157, 162.759);
		全局.LevelNameArr = 数组(自定义字符串("不期而遇"), 自定义字符串("不言而喻"), 自定义字符串("神明在我耳边说“在劫难逃”"));
	}
}

规则("封禁表情跳，作者自己选择是否开启该规则。")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		正在使用表情交流(事件玩家) == 真;
		数组包含(全局.FinishedPlayerArr, 事件玩家) == 假;
	}

	动作
	{
		清除状态(事件玩家, 相移);
		设置状态(事件玩家, 无, 冰冻, 9999);
		等待(3, 无视条件);
		小字体信息(事件玩家, 自定义字符串("别偷了，妈妈怕"));
		击杀(事件玩家, 无);
		清除状态(事件玩家, 冰冻);
		设置状态(事件玩家, 无, 相移, 9999);
	}
}

规则("识别指定的用户ID（这里可以放你朋友们的ID和对他们进入房间时所进行的操作）")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		"空白处填写您好友的名字（示例： maple）"
		If(自定义字符串("MapLe") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("maple老闸总来了！"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串(" 狗 东 西"), 事件玩家, 2, 根据表面截取, 可见，位置和字符串, 颜色(红色), 默认可见度);
		Else If(自定义字符串("你们怎么这么熟练") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("熟练老男同来了"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串(" 男 同"), 事件玩家, 2, 根据表面截取, 可见，位置和字符串, 颜色(红色), 默认可见度);
		Else If(自定义字符串("Mayday") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("mayday老闸总来了来了来了来了啊啊啊啊啊啊啊"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串(" 闸 总"), 事件玩家, 2, 根据表面截取, 可见，位置和字符串, 颜色(红色), 默认可见度);
		Else If(自定义字符串("丶花间丶") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("花间老fw来了"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串(" F W"), 事件玩家, 2, 根据表面截取, 可见，位置和字符串, 颜色(红色), 默认可见度);
		Else If(自定义字符串("ERIS") == 自定义字符串("{0}", 事件玩家));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("   我"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		Else If(自定义字符串("Honor") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("honor老中医来了"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("老 中 医"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(红色), 默认可见度);
		Else If(自定义字符串("奶一个死一个") == 自定义字符串("{0}", 事件玩家));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("迪拜热巴"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(绿色), 默认可见度);
		Else If(自定义字符串("布尔什维克") == 自定义字符串("{0}", 事件玩家));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("无 产 者"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(红色), 默认可见度);
		End;
	}
}

规则("创建特定关卡可见的地图提示文本（可复制第一条然后手动录制坐标编辑）")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"记得打开该动作显示文本，操作提示在下面写了"
		禁用 创建地图文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.level == 0 && 当前数组元素.currentPos == 0), 自定义字符串(
			"这里写你的地图文本，上面的第一个数字是关卡数，再上面的第二个数字是等级，分为0，1，2。下面的坐标点红色摄像头录制。可复制粘贴，但是记得改上面的数字"), 矢量(0, 0, 0), 1, 根据表面截取, 可见，位置和字符串, 颜色(黄色),
			默认可见度);
	}
}

规则("创建特定关卡可见的hud文本（显示在屏幕左上角）")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.HintText = 数组(数组(自定义字符串("直接二段跳去爬"), 自定义字符串("走下去小跳去爬"), 自定义字符串("走下去跳爬，小跳进点"), 自定义字符串("小跳到石头爬"), 自定义字符串("同理~但要扒一下进点"), 自定义字符串(
			"先跳爬石柱，再跳过去扒石头"), 自定义字符串("二段交完爬石柱\r\n转身扒"), 自定义字符串("跳去爬高一点的墙\r\n到高点松空格再跳过去"), 自定义字符串("这么白给的关自己想！"), 自定义字符串("留个小跳，从下面爬石柱上去"),
			自定义字符串("走下去爬正前方的斜边，小跳进点"), 自定义字符串("白给自己想！"), 自定义字符串("二段跳去爬飞机，滑进点"), 自定义字符串("哇，穿越了呢~"), 自定义字符串("二段跳，继续爬一次飞机"), 自定义字符串(
			"留个小跳，爬左边的白房子\r\n滑一会，小跳花坛扒一下进点"), 自定义字符串("二段跳爬尖尖，惯性滑雨伞，再扒一下"), 自定义字符串("一段跳爬正前方，留个跳，滑一下\r\n差不多就跳，去扒一下边 进点\r\n滑的时候注意别踩到第二个箭"),
			自定义字符串("二段交完爬房子，滑~"), 自定义字符串("二段去爬右边的侧面墙（前方是正面）"), 自定义字符串("还是二段爬，滑~要扒一下进点"), 自定义字符串("走下去留个小跳爬右边的蓝色墙\r\n滑完蓝色顶小跳进点"), 自定义字符串(
			"再留个小跳，爬尖尖惯性去滑雨伞\r\n滑完落地小跳再上去白色顶 滑"), 自定义字符串("一段跳去爬板子，空格摁住！惯性出去\r\n再扒一下白边，最后跳进点"), 自定义字符串("白给关卡，自己悟!"), 自定义字符串(
			"留个小跳，爬 再滑一次白顶"), 自定义字符串("哇，穿越了呢~"), 自定义字符串("自己悟！"), 自定义字符串("留个小跳，爬太阳能"), 自定义字符串("跳 爬右边墙，差不多再跳进点"), 自定义字符串(
			"留个小跳，爬后甩门口上方的蓝色板子\r\n滑一下，落地小跳进花坛上进点"), 自定义字符串("跳出去爬墙，二段跳翻过去\r\n扒一下花坛进点~"), 自定义字符串("就爬你面前最高的这面墙\r\n滑一下，再跳进点"), 自定义字符串(
			"留个小跳，爬前面的房子\r\n到高点松空格出去，落地小跳"), 自定义字符串("二段全交，爬黄色的矮房子，滑~"), 自定义字符串("二段交完爬第二根石柱，滑进点"), 自定义字符串("白给关卡，自己悟！"), 自定义字符串(
			"跳爬，滑完继续再滑一下矮的，跳进点"), 自定义字符串("白给自己悟！"), 自定义字符串("悟！")), 数组(自定义字符串("一段跳爬石头，到顶松空格\r\n惯性出去，再跳，最后扒一下边"), 自定义字符串("跳 爬 跳 进点"), 自定义字符串(
			"留个小跳，跳爬紧贴石柱的墙\r\n 小跳过去扒第二个箭头"), 自定义字符串("小跳过去爬第一个箭头的栏杆\r\n到高点转身过去扒一下"), 自定义字符串("小跳过去爬箭头，惯性扒进点\r\n（记得松空格）"), 自定义字符串(
			"跳 爬第一根石柱\r\n转身跳向第二个箭头，扒一下进点"), 自定义字符串("留个小跳，爬箭头上去\r\n小跳在上去后石头上用，最后扒一下\r\n（记得松空格）"), 自定义字符串("跳 爬 跳 进点"), 自定义字符串(
			"留个小跳，爬箭头上去\r\n到高点松空格，落地小跳\r\n扒进点"), 自定义字符串("跳爬隔壁第一个箭头\r\n松完空格再跳过去扒一下"), 自定义字符串("跳 爬 跳 进点~"), 自定义字符串("哇，穿越了呢~"), 自定义字符串(
			"小跳过去爬石柱，最高点松空格\r\n转身滑一下雨伞（若不能直接进点，扒一下第二个箭头）"), 自定义字符串("留个小跳，爬房子上去\r\n滑到底，右边落地小跳，再扒一下"), 自定义字符串("二段全交，爬上去，滑进点"), 自定义字符串(
			"跳爬上去滑，滑突出的地方\r\n滑完跳 扒进点"), 自定义字符串("方法有很多，自行悟\r\n（总之就是过去扒两下）"), 自定义字符串("跳爬滑完白屋顶，跳过去扒一下"), 自定义字符串("跳 爬 滑 跳"), 自定义字符串(
			"跳 爬 滑 跳 滑"), 自定义字符串("走下去，小跳爬一下悬崖，再扒一下板子"), 自定义字符串("哇，穿越了呢~"), 自定义字符串("滑！自己悟"), 自定义字符串("滑！小跳进点 自己悟"), 自定义字符串("跳 爬 跳 过去扒一下箭头"),
			自定义字符串("跳爬，滑到左边下去\r\n跳到弹射再扒一下箭头"), 自定义字符串("跳 爬到最高点\r\n转身跳到箭头扒一下"), 自定义字符串("留个小跳，先爬 落地小跳"), 自定义字符串("留个小跳，爬完后滑 落地小跳进点"), 自定义字符串(
			"小跳过去爬 滑 最后扒一下"), 自定义字符串("自己悟！"), 自定义字符串("自己悟！"), 自定义字符串("留个小跳，继续滑，小跳进点"), 自定义字符串("自己悟！"), 自定义字符串("原地爬上去滑 过去扒两下 甩进点"), 自定义字符串(
			"原地爬上去滑，跳到第二个箭头\r\n下去后 扒一下进点"), 自定义字符串("跳出去爬树，再跳过去扒一下"), 自定义字符串("留个小跳，先去蹭一下箭头\r\n惯性过去再扒一下，小跳进点"), 自定义字符串("跳 爬 跳 扒 "), 自定义字符串(
			"一段跳出去爬\r\n然后这样 再那样就过了")), 数组(自定义字符串("留个小跳爬，第二个箭头使用小跳"), 自定义字符串("跳 爬 跳 扒 扒进点"), 自定义字符串("跳 爬 跳 扒一下箭头\r\n下去 继续扒"), 自定义字符串(
			"跳 爬 滑到第二个箭头，跳进点"), 自定义字符串("留个小跳，爬箭头，扒到第二个箭头\r\n小跳过去 扒一下进点"), 自定义字符串("留个小跳进点"), 自定义字符串("扒!自己悟"), 自定义字符串("留个小跳，最后小跳扒进点"),
			自定义字符串("小跳踩第二个箭头进点"), 自定义字符串("最后扒一下点位\r\n（不要贴太近）"), 自定义字符串("自己悟，小跳进点"), 自定义字符串("哇，穿越了呢~"), 自定义字符串("留个小跳，最后扒一下板子\r\n小跳进点"),
			自定义字符串("滑！自己悟"), 自定义字符串("留个小跳，先爬电线杆后滑\r\n扒一下第二个箭头，小跳在房子上过去"), 自定义字符串("重点过去滑阳台（第二个箭头）"), 自定义字符串(
			"留小跳，扒过去，滑蓝色板子\r\n第二个箭头那里，落地小跳进点"), 自定义字符串("最后扒一下箭头甩过去进点"), 自定义字符串("自己悟！"), 自定义字符串("留个小跳，走外面爬箭头\r\n甩过去到第二个箭头，扒过去"), 自定义字符串(
			"二段全交爬，翻过围栏，扒！\r\n最后扒一下甩到屋顶滑"), 自定义字符串("自己悟"), 自定义字符串("跳爬空格摁住，下去接一个扒\r\n再跳进点（不要松空格）"), 自定义字符串("自己悟"), 自定义字符串("自己悟"), 自定义字符串(
			"总之就是扒扒扒扒"), 自定义字符串("哇，穿越了呢~"), 自定义字符串("一段爬飞机，第二个箭头再跳\r\n滑完飞机进点"), 自定义字符串("小跳出去爬房子 滑~\r\n最后扒一下甩进点"), 自定义字符串("自己悟"), 自定义字符串(
			"留个小跳，滑完落地小跳\r\n然后扒扒扒扒（镜头甩快一点）"), 自定义字符串("爬侧面的墙，滑过去扒箭头\r\n小跳进门踩点~"), 自定义字符串("自己悟（不要贴太近，不然扒不了）"), 自定义字符串(
			"小跳过去爬墙，到高点松空格\r\n顺势甩过去滑进点"), 自定义字符串("自己悟"), 自定义字符串("留个小跳，爬蓝房子,滑！\r\n滑完蓝跟白，在第二个箭头使用小跳，扒一下进点"), 自定义字符串("自己悟"), 自定义字符串(
			"自己悟就是扒扒扒扒扒扒扒"), 自定义字符串("滑房子过去扒，最后弹过去进点\r\n（或者使用小跳过去）"), 自定义字符串("二段爬墙上去，先扒这里\r\n再扒那里，然后是这里，最后在扒一下进点")));
	}
}

规则("优化吃点（开启增加玩家游戏体验，如觉得对自己的图有影响可关闭，一般来说几乎无影响）")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		调用子程序(enableRecording);
		全局.OptimizationFlag = 1;
		调用子程序(disableRecording);
	}
}

禁用 规则("---------------------------------------------------分割---------------------------------------------------------------------------")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		事件玩家.currentPos < 数量(事件玩家.myPosData) - 1;
		事件玩家.userBuffer == 0;
		全局.GameMode == 1;
	}

	动作
	{
		事件玩家.invincible = 0;
		事件玩家.userBuffer = 1;
		传送(事件玩家, 事件玩家.myPosData[事件玩家.currentPos + 1]);
		等待(0.250, 无视条件);
		事件玩家.userBuffer = 0;
	}
}

规则("------------------------------------------以下为制作3小图模式，通关后的传送门位置设置-----------------------------（如非3小图地图，请关闭）")
{
	事件
	{
		持续 - 全局;
	}
}

规则("3小图传送门特效")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		创建效果(全局.FinishedPlayerArr, 光柱, 颜色(天蓝色), 全局.ConveryPos[0] - 矢量(0, 2, 0), 2, 可见);
		创建效果(全局.FinishedPlayerArr, 环, 颜色(天蓝色), 全局.ConveryPos[0], 2, 可见);
		创建图标(全局.FinishedPlayerArr, 全局.ConveryPos[0], 螺旋, 可见和位置, 颜色(蓝色), 真);
		创建地图文本(全局.FinishedPlayerArr, 自定义字符串("按下蹲键至图二"), 全局.ConveryPos[0], 2, 根据表面截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
		创建效果(全局.FinishedPlayerArr, 光柱, 颜色(天蓝色), 全局.ConveryPos[1] - 矢量(0, 2, 0), 2, 可见);
		创建效果(全局.FinishedPlayerArr, 环, 颜色(天蓝色), 全局.ConveryPos[1], 2, 可见);
		创建图标(全局.FinishedPlayerArr, 全局.ConveryPos[1], 螺旋, 可见和位置, 颜色(蓝色), 真);
		创建地图文本(全局.FinishedPlayerArr, 自定义字符串("按下蹲键至图三"), 全局.ConveryPos[1], 2, 根据表面截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
		创建效果(全局.FinishedPlayerArr, 光柱, 颜色(天蓝色), 全局.ConveryPos[2] - 矢量(0, 2, 0), 2, 可见);
		创建效果(全局.FinishedPlayerArr, 环, 颜色(天蓝色), 全局.ConveryPos[2], 2, 可见);
		创建图标(全局.FinishedPlayerArr, 全局.ConveryPos[2], 螺旋, 可见和位置, 颜色(蓝色), 真);
		创建地图文本(全局.FinishedPlayerArr, 自定义字符串("按下蹲键至图一"), 全局.ConveryPos[2], 2, 根据表面截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
	}
}

规则("图一到图二传送门程序")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		数组包含(全局.FinishedPlayerArr, 事件玩家) == 真;
		相距距离(事件玩家, 全局.ConveryPos[0]) <= 2;
	}

	动作
	{
		等待(0.250, 当为“假”时中止);
		传送(事件玩家, 全局.ConveryPos[1]);
		施加推力(事件玩家, 上, 50, 至地图, 取消相反运动);
		施加推力(事件玩家, 前, 50, 至地图, 取消相反运动);
	}
}

规则("图二到图三传送门程序")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		数组包含(全局.FinishedPlayerArr, 事件玩家) == 真;
		相距距离(事件玩家, 全局.ConveryPos[1]) <= 2;
	}

	动作
	{
		等待(0.250, 当为“假”时中止);
		传送(事件玩家, 全局.ConveryPos[2]);
		施加推力(事件玩家, 上, 50, 至地图, 取消相反运动);
		施加推力(事件玩家, 前, 50, 至地图, 取消相反运动);
	}
}

规则("图三到图一传送门程序")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		数组包含(全局.FinishedPlayerArr, 事件玩家) == 真;
		相距距离(事件玩家, 全局.ConveryPos[2]) <= 2;
	}

	动作
	{
		等待(0.250, 当为“假”时中止);
		传送(事件玩家, 全局.ConveryPos[0]);
		施加推力(事件玩家, 上, 50, 至地图, 取消相反运动);
		施加推力(事件玩家, 前, 50, 至地图, 取消相反运动);
	}
}

规则("---------------------------------------------------主规则部分------------------------------------------（从这开始的规则禁止删除）")
{
	事件
	{
		持续 - 全局;
	}
}

规则("开始游戏")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		调用子程序(resetGlobalData);
		调用子程序(importAllData);
		调用子程序(fixData);
		根据条件跳过(全局.GameMode == 1, 1);
		调用子程序(importData);
		调用子程序(refreashBallEffect);
		关闭游戏预设复生模式(所有玩家(所有队伍));
		关闭游戏预设完成条件;
		关闭游戏预设计分模式;
		关闭游戏预设音乐模式;
		比赛时间暂停;
		禁用查看器录制;
	}
}

规则("初始化玩家数据")
{
	事件
	{
		玩家加入比赛;
		双方;
		全部;
	}

	条件
	{
		禁用 已重生(事件玩家) == 真;
	}

	动作
	{
		调用子程序(resetPlayerData);
		调用子程序(resetDestEffect);
		调用子程序(resetPlayerText);
		根据条件跳过(全局.GameMode == 1, 4);
		事件玩家.level = 全局.EditingLevel;
		事件玩家.myPosData = 全局.EditingPositionDataBuffer;
		调用子程序(startTimer);
	}
}

规则("玩家已就绪")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		禁用 已重生(事件玩家) == 真;
		事件玩家.level != -1;
		全局.GameMode == 1;
	}

	动作
	{
		调用子程序(loadLevel);
		调用子程序(startTimer);
		调用子程序(sendPlayerToCurrentPos);
		调用子程序(refreashBallEffect);
	}
}

规则("判定到达点位")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		相距距离(事件玩家, 事件玩家.myPosData[事件玩家.currentPos + 1]) <= 全局.CircleRadius;
		(在地面上(事件玩家) || (全局.OptimizationFlag == 1 && 高度(事件玩家) <= 0.050)) == 真;
		事件玩家.currentPos < 数量(事件玩家.myPosData) - 1;
		事件玩家.userBuffer == 0;
		事件玩家.invincible == 0;
	}

	动作
	{
		调用子程序(reachTarget);
	}
}

规则("判定是否死亡")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		在地面上(事件玩家) == 真;
		事件玩家.currentPos < 数量(事件玩家.myPosData) - 1;
		相距距离(事件玩家, 事件玩家.myPosData[事件玩家.currentPos]) >= 全局.CircleRadius;
		事件玩家.userBuffer == 0;
		事件玩家.invincible == 0;
	}

	动作
	{
		调用子程序(playerDeath);
		如条件为”真“则循环;
	}
}

规则("判定是否通关")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		事件玩家.currentPos == 数量(事件玩家.myPosData) - 1;
		全局.GameMode == 1;
	}

	动作
	{
		调用子程序(playerWin);
	}
}

规则("-----------------------------------------------------玩家模式操作部分----------------------------------------------------")
{
	事件
	{
		持续 - 全局;
	}
}

规则("---开启/关闭无敌看点---（按键：近战键V+换弹键R）（编辑模式下共享，不可踩点）")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		数组包含(全局.FinishedPlayerArr, 事件玩家) == 假;
		正在使用技能 1(事件玩家) == 假;
		存活(事件玩家) == 真;
		事件玩家.userBuffer == 0;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		正在使用终极技能(事件玩家) == 假;
	}

	动作
	{
		If(事件玩家.invincible == 0);
			大字体信息(事件玩家, 自定义字符串("已开启无敌看点"));
			事件玩家.invincible = 1;
			停止追踪玩家变量(事件玩家, timer);
			设置启用技能 1(事件玩家, 真);
			设置启用终极技能(事件玩家, 真);
		Else;
			大字体信息(事件玩家, 自定义字符串("已关闭无敌看点"));
			设置启用技能 1(事件玩家, 假);
			设置启用终极技能(事件玩家, 假);
			等待(0.200, 无视条件);
			传送(事件玩家, 事件玩家.myPosData[事件玩家.currentPos]);
			追踪玩家变量频率(事件玩家, timer, 绝对值(9999999.000), 1, 速率及最终值);
			等待(0.200, 无视条件);
			根据条件跳过(正在使用技能 1(事件玩家) == 假, 1);
			传送(事件玩家, 事件玩家.myPosData[事件玩家.currentPos]);
			事件玩家.invincible = 0;
		End;
	}
}

规则("---重新开始模式---（按键：蹲+E+互动键)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.GameMode == 1;
		存活(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		事件玩家.userBuffer == 0;
		具有状态(事件玩家, 击倒) == 假;
	}

	动作
	{
		消除HUD文本(事件玩家.myTextID[1]);
		调用子程序(resetDestEffect);
		调用子程序(resetPlayerData);
		修改全局变量(FinishedPlayerArr, 根据值从数组中移除, 事件玩家);
		根据条件中止(事件玩家.leveFlag != 1);
		调用子程序(loadLevel);
		调用子程序(startTimer);
		事件玩家.userBuffer = 1;
		调用子程序(sendPlayerToCurrentPos);
		等待(0.250, 无视条件);
		事件玩家.userBuffer = 0;
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 100);
	}
}

规则("---死亡次数过多让玩家跳关---（按键：近战+鼠标左）")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.currentPos < 数量(事件玩家.myPosData) - 1;
		事件玩家.userBuffer == 0;
		全局.GameMode == 1;
		事件玩家.skipFlag == 1;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
	}

	动作
	{
		事件玩家.invincible = 0;
		事件玩家.userBuffer = 1;
		传送(事件玩家, 事件玩家.myPosData[事件玩家.currentPos + 1]);
		等待(0.250, 无视条件);
		事件玩家.userBuffer = 0;
	}
}

规则("---自杀开启/关闭观战---（按键：长按互动键）")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		全局.GameMode == 1;
		事件玩家.userBuffer == 0;
		具有状态(事件玩家, 击倒) == 假;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
	}

	动作
	{
		等待(1, 当为“假”时中止);
		小字体信息(事件玩家, 自定义字符串("长按互动键1s自杀进入/退出观战"));
		If(存活(事件玩家) == 真);
			设置最大复生时间(事件玩家, 9999);
			停止追踪玩家变量(事件玩家, timer);
			等待(0.250, 无视条件);
			击杀(事件玩家, 无);
		Else;
			复生(事件玩家);
			设置最大复生时间(事件玩家, 0.500);
			调用子程序(sendPlayerToCurrentPos);
			根据条件跳过(数组包含(全局.FinishedPlayerArr, 事件玩家) == 真 || 事件玩家.invincible == 1, 1);
			追踪玩家变量频率(事件玩家, timer, 10000, 1, 速率及最终值);
		End;
	}
}

规则("---通关后开启/关闭变成弹床---（按键：近战键V+换弹键R+终极技能）")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		数组包含(全局.FinishedPlayerArr, 事件玩家) == 真;
		全局.GameMode == 1;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
	}

	动作
	{
		等待(0.250, 当为“假”时中止);
		If(数组包含(全局.Trampoline, 事件玩家) == 真);
			清除状态(事件玩家, 击倒);
			修改全局变量(Trampoline, 根据值从数组中移除, 事件玩家);
			修改全局变量(TrampolinePos, 根据值从数组中移除, 事件玩家.posBuffer);
			小字体信息(事件玩家, 自定义字符串("你恢复了"));
			停止镜头(事件玩家);
			设置状态(事件玩家, 无, 无敌, 9999);
			设置状态(事件玩家, 无, 相移, 9999);
			消除效果(事件玩家.myEffectID[21]);
		Else;
			清除状态(事件玩家, 相移);
			等待(0.250, 无视条件);
			设置状态(事件玩家, 无, 击倒, 9999);
			修改全局变量(Trampoline, 添加至数组, 事件玩家);
			事件玩家.posBuffer = 所选位置(事件玩家);
			修改全局变量(TrampolinePos, 添加至数组, 事件玩家.posBuffer);
			小字体信息(事件玩家, 自定义字符串("你变成了一个弹床！近战键V+换弹键R+终极技能取消"));
			开始镜头(事件玩家, 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 上 - 面朝方向(事件玩家) * 3, 无, 事件玩家, 真) - 面朝方向(事件玩家) * 0.200, 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家)
				+ 面朝方向(事件玩家) * 1000, 所有玩家(所有队伍), 事件玩家, 假), 40);
			根据条件跳过(具有状态(事件玩家, 击倒) == 假, 1);
			设置状态(事件玩家, 无, 击倒, 9999);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 事件玩家, 3, 可见，位置和半径);
			事件玩家.myEffectID[21] = 最后创建的实体;
		End;
	}
}

规则("------------------------------------------------------状态响应部分----------------------------------------------------------")
{
	事件
	{
		持续 - 全局;
	}
}

规则("创建DVA")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		数量(所有玩家(队伍2)) < 6;
		数量(全局.DVAPosArr) >= 1;
		全局.Index <= 数量(全局.DVAPosArr);
	}

	动作
	{
		生成机器人(英雄(D.Va), 队伍2, 5, 全局.DVAPosArr[全局.Index], 上);
		全局.Index += 1;
		开始按下按钮(选择英雄的玩家(英雄(D.Va), 所有队伍), 按钮(终极技能));
		等待(6.500, 无视条件);
		停止按下按钮(选择英雄的玩家(英雄(D.Va), 所有队伍), 按钮(终极技能));
		移除机器人(队伍2, 5);
		根据条件循环(全局.Index < 数量(全局.DVAPosArr));
	}
}

规则("编辑模式开启技能")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(全局.GameMode != 1 || 事件玩家.invincible == 1 || 数组包含(全局.FinishedPlayerArr, 事件玩家) == 真) == 真;
		存活(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
	}

	动作
	{
		设置启用技能 1(事件玩家, 真);
		设置启用终极技能(事件玩家, 真);
		设置终极技能充能(事件玩家, 100);
	}
}

规则("终极技能关卡检测")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		全局.GameMode == 1;
		相距距离(事件玩家, 事件玩家.myPosData[事件玩家.currentPos]) <= 全局.CircleRadius;
		正在使用终极技能(事件玩家) == 假;
		数组包含(全局.FinishedPlayerArr, 事件玩家) == 假;
	}

	动作
	{
		If(数组包含(全局.QData, 事件玩家.currentPos + 事件玩家.level * 1000) == 真);
			小字体信息(事件玩家, 字符串("{0} {1}", 技能图标字符串(英雄(源氏), 按钮(终极技能)), 自定义字符串("当前关卡已启用终极技能！")));
			设置启用终极技能(事件玩家, 真);
			设置终极技能充能(事件玩家, 100);
		Else;
			设置启用终极技能(事件玩家, 假);
		End;
	}
}

规则("S技能关卡检测")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		全局.GameMode == 1;
		相距距离(事件玩家, 事件玩家.myPosData[事件玩家.currentPos]) <= 全局.CircleRadius;
		正在使用技能 1(事件玩家) == 假;
		数组包含(全局.FinishedPlayerArr, 事件玩家) == 假;
	}

	动作
	{
		If(数组包含(全局.SData, 事件玩家.currentPos + 事件玩家.level * 1000) == 真);
			小字体信息(事件玩家, 字符串("{0} {1}", 技能图标字符串(英雄(源氏), 按钮(技能1)), 自定义字符串("当前关卡已启用技能1！")));
			设置启用技能 1(事件玩家, 真);
		Else;
			设置启用技能 1(事件玩家, 假);
		End;
	}
}

规则("限制终极技能使用后关闭充能")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		全局.GameMode == 1;
		数组包含(全局.FinishedPlayerArr, 事件玩家) == 假;
		正在使用终极技能(事件玩家) == 真;
		事件玩家.invincible == 0;
	}

	动作
	{
		设置启用终极技能(事件玩家, 假);
	}
}

规则("限制shift技能使用一次")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		全局.GameMode == 1;
		数组包含(全局.FinishedPlayerArr, 事件玩家) == 假;
		正在使用技能 1(事件玩家) == 真;
		事件玩家.invincible == 0;
	}

	动作
	{
		设置启用技能 1(事件玩家, 假);
	}
}

规则("死亡传送")
{
	事件
	{
		玩家阵亡;
		双方;
		源氏;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		数组包含(全局.Blacklist, 自定义字符串("{0}", 事件玩家)) == 假;
	}

	动作
	{
		复活(事件玩家);
		调用子程序(playerDeath);
		根据条件中止(事件玩家.invincible == 0);
		设置启用技能 1(事件玩家, 真);
		设置启用终极技能(事件玩家, 真);
		设置终极技能充能(事件玩家, 100);
	}
}

规则("障碍球距离判定")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		相距距离(事件玩家, 全局.OstacleBallPos[数组值的索引(全局.OstacleBallIndex, 事件玩家.currentPos + 事件玩家.level * 250)]) <= 全局.OstacleBallRadius[数组值的索引(
			全局.OstacleBallIndex, 事件玩家.level * 250 + 事件玩家.currentPos)];
		事件玩家.invincible == 0;
	}

	动作
	{
		调用子程序(playerDeath);
	}
}

规则("弹球距离判定")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		相距距离(事件玩家, 全局.PinballPos[数组值的索引(全局.PinballIndex, 事件玩家.currentPos + 事件玩家.level * 250)]) <= 1;
	}

	动作
	{
		播放效果(事件玩家, 环状爆炸, 颜色(天蓝色), 全局.PinballPos[数组值的索引(全局.PinballIndex, 事件玩家.currentPos + 事件玩家.level * 250)], 4);
		施加推力(事件玩家, 上, 全局.PinballElasticForce[数组值的索引(全局.PinballIndex, 事件玩家.currentPos + 事件玩家.level * 250)], 至地图, 取消相反运动);
	}
}

规则("玩家互助弹床距离判定")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		数量(已过滤的数组(全局.TrampolinePos, 相距距离(事件玩家, 当前数组元素) <= 3)) != 0;
	}

	动作
	{
		根据条件中止(按钮被按下(事件玩家, 按钮(技能2)) == 真);
		根据条件中止(数组包含(全局.Trampoline, 事件玩家) == 真);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(天蓝色), 事件玩家, 3);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(水绿色), 事件玩家, 4);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(橙色), 事件玩家, 5);
		施加推力(事件玩家, 上, 15, 至地图, 取消相反运动);
	}
}

规则("死亡次数过多给跳关机会判定")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.GameMode == 1;
		事件玩家.deathNum > 全局.MaxDeathNum[事件玩家.level];
	}

	动作
	{
		事件玩家.skipFlag = 1;
	}
}

规则("刷新球体效果")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		全局.flag == 1;
	}

	动作
	{
		调用子程序(refreashBallEffect);
	}
}

规则("离开游戏删除部分玩家数据")
{
	事件
	{
		玩家离开比赛;
		双方;
		全部;
	}

	条件
	{
		数组包含(全局.Trampoline, 事件玩家) == 真;
	}

	动作
	{
		修改全局变量(TrampolinePos, 根据索引从数组中移除, 数组值的索引(全局.Trampoline, 事件玩家));
		修改全局变量(Trampoline, 根据值从数组中移除, 事件玩家);
	}
}

规则("落地重置跳跃和爬墙")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		在地面上(事件玩家) == 真;
	}

	动作
	{
		事件玩家.jumpSign = 0;
		根据条件循环((事件玩家.jumpSign != 0 && 在地面上(事件玩家) == 真) == 真);
		事件玩家.climbSign = 1;
	}
}

规则("爬墙判定")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		在墙上(事件玩家) == 真;
	}

	动作
	{
		事件玩家.climbSign = 2;
	}
}

规则("跳跃判定")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		事件玩家.jumpSign != 2;
	}

	动作
	{
		事件玩家.jumpSign += 1;
	}
}

规则("空中判定")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		事件玩家.jumpSign == 0;
		正在空中(事件玩家) == 真;
	}

	动作
	{
		事件玩家.jumpSign = 1;
	}
}

规则("刷新跳跃")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		事件玩家.jumpSign == 1;
	}

	动作
	{
		等待(0.100, 当为“假”时中止);
		事件玩家.jumpSign = 2;
	}
}

规则("封3段")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		垂直速度(事件玩家) >= 5.800;
		事件玩家.jumpSign == 1;
		正在使用技能 1(事件玩家) == 假;
		数组包含(全局.FinishedPlayerArr, 事件玩家) == 假;
		禁用 (数组包含(全局.PinballIndex, 事件玩家.currentPos + 事件玩家.level * 250) && 相距距离(事件玩家, 全局.PinballPos[数组值的索引(全局.PinballIndex,
			事件玩家.currentPos + 事件玩家.level * 250)]) > 1) == 真;
	}

	动作
	{
		根据条件中止(在墙上(事件玩家) == 真);
		施加推力(事件玩家, 下, 20, 至地图, 取消相反运动);
	}
}

规则("到达传送点位判定（传送门）")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		数组包含(全局.ConveryPosArray, 事件玩家.currentPos + 事件玩家.level * 250) == 真;
		事件玩家.currentPos != 数量(事件玩家.myPosData) - 1;
	}

	动作
	{
		调用子程序(deliverPlayer);
		如条件为”真“则循环;
	}
}

规则("----------------------------------------------------------------开局选择难度部分-------------------------------------------------------")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}
}

规则("选择界面初始化")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		创建地图文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.level == -1), 自定义字符串("请用「 W / S 」选择，用「 空格 」确认 要挑战的难度"), 全局.MenuPos + 上, 1.400, 不要截取, 可见，位置和字符串,
			颜色(白色), 默认可见度);
		创建地图文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.level == -1 && 当前数组元素.optionNum != 0), 全局.LevelNameArr[0], 全局.MenuPos + 下 * (0 / 1.500), 2, 不要截取,
			可见，位置和字符串, 颜色(白色), 默认可见度);
		创建地图文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.level == -1 && 当前数组元素.optionNum == 0), 全局.LevelNameArr[0], 全局.MenuPos + 下 * (0 / 1.500), 2.400,
			不要截取, 可见，位置和字符串, 颜色(蓝色), 默认可见度);
		创建地图文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.level == -1 && 当前数组元素.optionNum != 1), 全局.LevelNameArr[1], 全局.MenuPos + 下 * (1 / 1.500), 2, 不要截取,
			可见，位置和字符串, 颜色(白色), 默认可见度);
		创建地图文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.level == -1 && 当前数组元素.optionNum == 1), 全局.LevelNameArr[1], 全局.MenuPos + 下 * (1 / 1.500), 2.400,
			不要截取, 可见，位置和字符串, 颜色(亮紫色), 默认可见度);
		创建地图文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.level == -1 && 当前数组元素.optionNum != 2), 全局.LevelNameArr[2], 全局.MenuPos + 下 * (2 / 1.500), 2, 不要截取,
			可见，位置和字符串, 颜色(白色), 默认可见度);
		创建地图文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.level == -1 && 当前数组元素.optionNum == 2), 全局.LevelNameArr[2], 全局.MenuPos + 下 * (2 / 1.500), 2.400,
			不要截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
	}
}

规则("强制玩家选择难度")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.level == -1;
		全局.GameMode == 1;
	}

	动作
	{
		事件玩家.optionNum = 1;
		设置移动速度(事件玩家, 0);
		大字体信息(事件玩家, 自定义字符串("欢迎来到源氏跑酷！"));
		开始镜头(事件玩家, 全局.CameraPos, 全局.MenuPos, 2);
	}
}

规则("选择难度操作")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		全局.GameMode == 1;
		事件玩家.level == -1;
		(Z方向分量(阈值(事件玩家)) != 0 || 按钮被按下(事件玩家, 按钮(跳跃))) == 真;
	}

	动作
	{
		根据条件跳过(!(Z方向分量(阈值(事件玩家)) > 0), 4);
		事件玩家.optionNum -= 1;
		根据条件跳过(!(事件玩家.optionNum < 0), 1);
		事件玩家.optionNum = 2;
		中止;
		根据条件跳过(!(Z方向分量(阈值(事件玩家)) < 0), 4);
		事件玩家.optionNum += 1;
		根据条件跳过(!(事件玩家.optionNum > 2), 1);
		事件玩家.optionNum = 0;
		中止;
		根据条件跳过(!按钮被按下(事件玩家, 按钮(跳跃)), 12);
		事件玩家.level = 事件玩家.optionNum;
		设置移动速度(事件玩家, 100);
		停止镜头(事件玩家);
	}
}

规则("-----------------------------------------------------------------通关后特效------------------------------------------------------")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(全局.GameMode != 1 || 数组包含(全局.FinishedPlayerArr, 事件玩家)) == 真;
		终极技能充能百分比(事件玩家) <= 100;
	}

	动作
	{
		等待(0.250, 无视条件);
		设置终极技能充能(事件玩家, 100);
	}
}

规则("特效1")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在使用主要武器(事件玩家) == 真;
		存活(事件玩家) == 真;
		数组包含(全局.FinishedPlayerArr, 事件玩家) == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(天蓝色), 距离准星最近的玩家(事件玩家, 所有队伍), 3);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(水绿色), 距离准星最近的玩家(事件玩家, 所有队伍), 4);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(橙色), 距离准星最近的玩家(事件玩家, 所有队伍), 5);
	}
}

规则("特效2")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
		数组包含(全局.FinishedPlayerArr, 事件玩家) == 真;
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(白色), 事件玩家, 3);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(黄色), 事件玩家, 3);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(红色), 事件玩家, 3);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(亮紫色), 事件玩家, 3);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(天蓝色), 事件玩家, 3);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(水绿色), 事件玩家, 3);
	}
}

规则("特效3")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
		数组包含(全局.FinishedPlayerArr, 事件玩家) == 真;
		正在与人交流(事件玩家) == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 有害选择效果 , 颜色(白色), 事件玩家, 3);
		播放效果(所有玩家(所有队伍), 有害选择效果 , 颜色(黄色), 事件玩家, 3);
		播放效果(所有玩家(所有队伍), 有害选择效果 , 颜色(红色), 事件玩家, 3);
		播放效果(所有玩家(所有队伍), 有害选择效果 , 颜色(亮紫色), 事件玩家, 3);
		播放效果(所有玩家(所有队伍), 有害选择效果 , 颜色(天蓝色), 事件玩家, 3);
		播放效果(所有玩家(所有队伍), 有害选择效果 , 颜色(水绿色), 事件玩家, 3);
	}
}

规则("---------------------------------------------游戏主函数部分-----------------------------------------------")
{
	事件
	{
		持续 - 全局;
	}
}

规则("加载编辑模式")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		If(全局.GameMode != 1);
			创建效果(所有玩家(所有队伍), 环, 颜色(红色), 全局.EditingPositionDataBuffer[全局.EditingPositionDataIndex], 全局.CircleRadius - 0.400, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 光柱, 颜色(红色), 全局.EditingPositionDataBuffer[全局.EditingPositionDataIndex], 全局.CircleRadius - 0.400, 可见，位置和半径);
			创建图标(所有玩家(所有队伍), 全局.EditingPositionDataBuffer[全局.EditingPositionDataIndex], 高兴, 可见和位置, 颜色(红色), 真);
			创建地图文本(所有玩家(所有队伍), 自定义字符串("当前选中关卡位置"), 全局.EditingPositionDataBuffer[全局.EditingPositionDataIndex], 1.500, 不要截取, 可见，位置和字符串, 颜色(红色),
				默认可见度);
		End;
	}
}

规则("重置全局游戏数据（）")
{
	事件
	{
		子程序;
		resetGlobalData;
	}

	动作
	{
		调用子程序(enableRecording);
		全局.EditingPositionDataBuffer = 空数组;
		全局.GlobalTextID = 空数组;
		全局.GlobalEffectID = 空数组;
		全局.FinishedPlayerArr = 空数组;
		全局.EditingPositionDataIndex = 0;
		全局.Trampoline = 空数组;
		全局.TrampolinePos = 空数组;
		全局.CircleRadius = 1.400;
		全局.EditingLevel = 0;
		全局.Index = 0;
		全局.QData = 空数组;
		全局.SData = 空数组;
		全局.ConveryPosArray = 空数组;
		全局.OstacleBallPos = 空数组;
		全局.OstacleBallRadius = 空数组;
		全局.OstacleBallIndex = 空数组;
		全局.PinballPos = 空数组;
		全局.PinballElasticForce = 空数组;
		全局.PinballIndex = 空数组;
		全局.HintEffectPosArr = 空数组;
		全局.HintEffectIndex = 空数组;
		调用子程序(disableRecording);
	}
}

规则("创建编辑模式文本（）")
{
	事件
	{
		子程序;
		createEditingModeText;
	}

	动作
	{
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 全局.EditingMode != 0 && 全局.EditingMode <= 2), 字符串("{0} {1}", 自定义字符串("当前编辑模式："), 自定义字符串("{{0}}",
			全局.EditingMode, 自定义字符串("障碍球模式"), 自定义字符串("弹球模式"))), 无, 无, 顶部, 0, 颜色(橙色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 自定义字符串("按住互动键查看指引文本"), 无, 无, 右边, 0, 颜色(天蓝色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(互动)) == 真), 自定义字符串(""), 无, 自定义字符串(
			" --- 编辑模式操作部分---\r\n创建点位或球体（按键：互动键+鼠标左）\r\n删除点位或球体（按键：互动键+鼠标右）\r\n移动点位或移动球体位置（按键：R+左键）\r\n上移选中点位（按键：Q+左键）（点位编辑模式下生效）\r\n下移选中点位按键：Q+右键）"),
			左边, 1, 颜色(白色), 颜色(白色), 颜色(水绿色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(互动)) == 真), 自定义字符串(""), 无, 自定义字符串(
			" --- 编辑模式操作部分---\r\n创建点位或球体（按键：互动键+鼠标左）\r\n删除点位或球体（按键：互动键+鼠标右）\r\n移动点位或移动球体,指引位置（按键：R+左键）\r\n上移选中点位（按键：Q+左键）（点位编辑模式下生效）\r\n下移选中点位按键：Q+右键）"),
			左边, 2, 颜色(白色), 颜色(白色), 颜色(水绿色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(互动)) == 真), 自定义字符串(""), 无, 自定义字符串(
			"切换当前编辑难度（按键：长按shift2s）\r\n切换至点位编辑模式（按键：按住互动键3s）\r\n切换至障碍球编辑模式（每关一个）（按键：按住近战攻击键3s）\r\n切换至弹球编辑模式（每关一个）（按键：按住蹲键3s）\r\n切换至DVA编辑模式（按键：按住Q键3s）"),
			左边, 3, 颜色(白色), 颜色(白色), 颜色(水绿色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(互动)) == 真), 自定义字符串(""), 无, 自定义字符串(
			"创建地图指引（E+左键）（点位编辑模式下生效）\r\n删除地图指引（E+右键）（点位编辑模式下生效）\r\n放大圈范围,击杀球半径,弹球弹力（按键：按住蹲+左键）\r\n缩小圈范围,击杀球半径,弹球弹力（按键：按住蹲+右键）\r\n数据导出（按键：近战+跳跃+蹲）"),
			右边, 4, 颜色(白色), 颜色(白色), 颜色(水绿色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(互动)) == 真), 自定义字符串(""), 无, 自定义字符串(
			"设置/取消当前关卡给刀（按键：互动+Q）\r\n设置/取消当前关卡给S（按键：互动+S）\r\n设置/取消到达当前关卡直接传送至下一关卡（按键：R+右键）（传送门效果）\r\n跳关（按键：近战+鼠标左）\r\n退关（按键：近战+鼠标右）\r\n穿墙（按键：长按E）"),
			右边, 5, 颜色(白色), 颜色(白色), 颜色(水绿色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 事件玩家.leveFlag != 1), 字符串("{0} {1}", 自定义字符串("当前level（难度）："), 全局.EditingLevel), 无, 无, 顶部, 1, 颜色(蓝色), 颜色(
			白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 字符串("{0} {1} {2}", 自定义字符串("当前选中关卡："), 全局.EditingPositionDataIndex, 字符串("{0} {1}", 自定义字符串("/"), 数量(
			全局.EditingPositionDataBuffer) - 1)), 无, 无, 顶部, 3, 颜色(蓝色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 全局.EditingMode == 0), 字符串("{0} {1}", 自定义字符串("当前圈半径："), 全局.CircleRadius), 无, 无, 顶部, 2, 颜色(天蓝色), 颜色(白色),
			颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 全局.EditingMode == 1), 字符串("{0} {1}", 自定义字符串("当前击杀球半径："), 全局.OstacleBallRadius[数组值的索引(
			全局.OstacleBallIndex, 主机玩家.currentPos + 主机玩家.level * 250)]), 无, 无, 顶部, 2, 颜色(天蓝色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 全局.EditingMode == 2), 字符串("{0} {1}", 自定义字符串("当前球弹力："), 全局.PinballElasticForce[数组值的索引(全局.PinballIndex,
			主机玩家.currentPos + 主机玩家.level * 250)]), 无, 无, 顶部, 2, 颜色(天蓝色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 全局.EditingMode == 0), 字符串("{0} {1}", 自定义字符串("当前编辑模式："), 自定义字符串("点位模式")), 无, 无, 顶部, 0, 颜色(橙色), 颜色(白色),
			颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 全局.EditingMode == 3), 字符串("{0} {1}", 自定义字符串("当前编辑模式："), 自定义字符串("DVA模式（放置点位，开局dva在该位置自动爆炸，用于炸栏杆）")), 无,
			无, 顶部, 0, 颜色(橙色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(互动)) == 真), 图标字符串(警告), 无, 自定义字符串(
			"请不要保存编辑器预设，每次编辑地图时直接用代码QAQRC导入。 \n现在制作器尚未完全完善，经常导入代码更新才能得到最好的体验。\n获取更新日志或bug反馈请加群：1019712301。谢谢支持！"), 左边, 0, 颜色(红色), 颜色(白色),
			颜色(红色), 可见和字符串, 默认可见度);
		创建地图文本(已过滤的数组(所有玩家(所有队伍), 正在移动(当前数组元素) == 假), 自定义字符串(
			"编辑器版本1.25 代码：RRR5K \r\n相较前几个版本增加了非常多提示功能\r\n适用于新手教程，有地图图标以及文本\r\n操作方式变化很多，总体操作更方便\r\n增加天空文本，可用于提示\r\n获取更新/操作说明请加群：1019712301"),
			矢量(0, 500, 0), 3, 不要截取, 可见，位置和字符串, 颜色(水绿色), 默认可见度);
	}
}

规则("创建玩家模式文本（）")
{
	事件
	{
		子程序;
		createPlayerModeText;
	}

	动作
	{
		创建HUD文本(所有玩家(所有队伍), 自定义字符串("按住E查看操作文本"), 无, 无, 左边, 1, 颜色(蓝色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(技能2)) == 真), 自定义字符串(""), 无, 自定义字符串(
			"玩家模式 操作部分---\r\n开启/关闭无敌看点：按近战键V+换弹键R (编辑模式下共享，不可踩点)\r\n 重新开始模式：按蹲+E+互动键\r\n自杀开启/关闭观战：长按互动键\r\n通关后开启/关闭变成弹床：按近战键V+换弹键R+终极技能\r\n按住E可无视他人弹床"),
			左边, 2, 颜色(白色), 颜色(白色), 颜色(青绿色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 自定义字符串(""), 无, 字符串("{0} {1} {2}", 自定义字符串("房间关闭计时："), 取整(总计消耗时间 / 60, 下), 自定义字符串("/270分钟")), 右边, 1, 颜色(白色), 颜色(
			白色), 颜色(橙色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(技能2)) == 真), 自定义字符串(""), 无, 全局.AllEditorsCodeText, 右边, 3, 颜色(白色), 颜色(白色), 颜色(黄色),
			可见和字符串, 默认可见度);
		创建地图文本(已过滤的数组(所有玩家(所有队伍), 总计消耗时间 % 30 < 10 && 正在移动(当前数组元素) == 假), 自定义字符串("源氏跑酷技巧集结：\r\n首先得知道源氏技能，在源氏跑酷图中，\r\n开局源氏只有二次跳跃，一次爬墙"), 矢量(
			0, 500, 0), 3, 不要截取, 可见，位置和字符串, 颜色(蓝色), 默认可见度);
		创建地图文本(已过滤的数组(所有玩家(所有队伍), 总计消耗时间 % 30 > 10 && 总计消耗时间 % 30 < 20 && 正在移动(当前数组元素) == 假), 自定义字符串(
			"小跳:适用于钻狗洞，极限点位\r\n操作方法：当人物所处在高处时，\r\n对着低处走下去，是走下去！\r\n再跳跃，落地摁住空格即可小跳"), 矢量(0, 500, 0), 3, 不要截取, 可见，位置和字符串, 颜色(蓝色), 默认可见度);
		创建地图文本(已过滤的数组(所有玩家(所有队伍), 总计消耗时间 % 30 > 20 && 正在移动(当前数组元素) == 假), 自定义字符串(
			"扒边（猴子扒）：适用于远距离点位（不得不学的东西！）\r\n操作方法：人物跟某处能站的地方的边处于平行水平线时\r\n差不多在脖子的高度，不是重点无所谓）\r\n摁住空格，人物就会有类似爬墙的动作\r\n有此动作就可以松空格\r\n（不松人物直接撞在地面上导致si亡）\r\n"),
			矢量(0, 500, 0), 3, 不要截取, 可见，位置和字符串, 颜色(蓝色), 默认可见度);
	}
}

规则("重置全局游戏文本（）")
{
	事件
	{
		子程序;
		resetGlobalText;
	}

	动作
	{
		If(全局.GameMode == 1);
			调用子程序(createPlayerModeText);
		Else;
			调用子程序(createEditingModeText);
		End;
	}
}

规则("启用查看器（）")
{
	事件
	{
		子程序;
		enableRecording;
	}

	动作
	{
		启用查看器录制;
	}
}

规则("禁用查看器（）")
{
	事件
	{
		子程序;
		disableRecording;
	}

	动作
	{
		禁用查看器录制;
	}
}

规则("数据导入修复（）")
{
	事件
	{
		子程序;
		fixData;
	}

	动作
	{
		全局.GlobalTextID = 空数组;
		全局.GlobalEffectID = 空数组;
		全局.EditingPositionDataBuffer = 空数组;
		全局.EditingLevel = 0;
		全局.EditingPositionDataIndex = 0;
		全局.EditingMode = 0;
		全局.Index = 0;
		调用子程序(resetCamera);
		调用子程序(resetGlobalText);
		调用子程序(resetEditorName);
	}
}

规则("------------------------------------------------玩家主函数部分---------------------------------------------------")
{
	事件
	{
		持续 - 全局;
	}
}

规则("重置玩家数据（）")
{
	事件
	{
		子程序;
		resetPlayerData;
	}

	动作
	{
		开始强制玩家选择英雄(事件玩家, 英雄(源氏));
		对所有玩家启用死亡回放(事件玩家);
		启用死亡回放时目标的HUD(事件玩家);
		设置最大复生时间(事件玩家, 0);
		事件玩家.myPosData = 空数组;
		事件玩家.currentPos = 0;
		事件玩家.deathNum = 0;
		事件玩家.skipFlag = 0;
		事件玩家.timer = 0;
		事件玩家.optionNum = 0;
		事件玩家.invincible = 0;
		设置状态(事件玩家, 无, 无敌, 9999);
		设置状态(事件玩家, 无, 相移, 9999);
		事件玩家.level = -1;
		根据条件跳过(全局.GameMode == 1, 1);
		事件玩家.level = 0;
		根据条件跳过(事件玩家.leveFlag != 1, 1);
		事件玩家.level = 0;
		调用子程序(stopTimer);
	}
}

规则("加载难度等级（）")
{
	事件
	{
		子程序;
		loadLevel;
	}

	动作
	{
		If(事件玩家.level == 0);
			事件玩家.myPosData = 全局.Level1Data;
		Else If(事件玩家.level == 1);
			事件玩家.myPosData = 全局.Level2Data;
		Else;
			事件玩家.myPosData = 全局.Level3Data;
		End;
	}
}

规则("重置玩家文本（）")
{
	事件
	{
		子程序;
		resetPlayerText;
	}

	动作
	{
		设置目标点描述(事件玩家, 字符串("{0} {1} {2}", 自定义字符串("作者："), 全局.EditorName, 字符串("{0} {1} {2}", 自定义字符串("ERIS制作器 当前版本:1.25\r\n"), 字符串(
			"{0} {1} {2}", 自定义字符串("                         当前关卡："), 字符串("{0} / {1}", 事件玩家.currentPos, 数量(事件玩家.myPosData) - 1), 自定义字符串(
			"\r\n")), 字符串("{0} {1}", 自定义字符串("                         时间："), 字符串("{0}秒", 事件玩家.timer)))), 可见和字符串);
		创建HUD文本(事件玩家, 自定义字符串("{{0}}", 事件玩家.climbSign, 自定义字符串("爬墙未用"), 自定义字符串("爬墙已用")), 无, 无, 左边, 0, 颜色(橙色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(事件玩家, 全局.HintText[事件玩家.level][事件玩家.currentPos] != 0), 全局.HintText[事件玩家.level][事件玩家.currentPos], 无, 无, 左边, 3, 颜色(
			青绿色), 颜色(白色), 颜色(黄色), 可见和字符串, 默认可见度);
	}
}

规则("重置点位特效（）")
{
	事件
	{
		子程序;
		resetDestEffect;
	}

	动作
	{
		消除效果(事件玩家.myEffectID[0]);
		消除效果(事件玩家.myEffectID[1]);
		消除效果(事件玩家.myEffectID[2]);
		消除图标(事件玩家.myEffectID[3]);
		消除效果(事件玩家.myEffectID[4]);
		消除效果(事件玩家.myEffectID[5]);
		消除效果(事件玩家.myEffectID[7]);
		消除图标(事件玩家.myEffectID[8]);
		消除图标(事件玩家.myEffectID[9]);
		消除地图文本(事件玩家.myTextID[0]);
		创建效果(事件玩家, 环, 颜色(天蓝色), 事件玩家.myPosData[事件玩家.currentPos], 全局.CircleRadius - 0.400, 可见，位置和半径);
		事件玩家.myEffectID[0] = 最后创建的实体;
		创建效果(已过滤的数组(事件玩家, 事件玩家.currentPos < 数量(事件玩家.myPosData) - 1), 环, 颜色(橙色), 事件玩家.myPosData[事件玩家.currentPos + 1],
			全局.CircleRadius - 0.400, 可见，位置和半径);
		事件玩家.myEffectID[1] = 最后创建的实体;
		创建效果(已过滤的数组(事件玩家, 事件玩家.currentPos < 数量(事件玩家.myPosData) - 1), 光柱, 颜色(天蓝色), 事件玩家.myPosData[事件玩家.currentPos + 1],
			全局.CircleRadius - 0.400, 可见，位置和半径);
		事件玩家.myEffectID[2] = 最后创建的实体;
		创建图标(已过滤的数组(事件玩家, 事件玩家.currentPos < 数量(事件玩家.myPosData) - 1), 事件玩家.myPosData[事件玩家.currentPos + 1], 旗帜, 可见和位置, 颜色(橙色), 真);
		事件玩家.myEffectID[3] = 最后创建的实体;
		创建地图文本(已过滤的数组(事件玩家, 事件玩家.currentPos < 数量(事件玩家.myPosData) - 1), 全局.DestText, 事件玩家.myPosData[事件玩家.currentPos + 1], 1.500, 不要截取,
			可见，位置和字符串, 颜色(白色), 默认可见度);
		事件玩家.myTextID[0] = 上一个文本ID;
		创建效果(已过滤的数组(事件玩家, 事件玩家.currentPos < 数量(事件玩家.myPosData) && 数组包含(全局.OstacleBallIndex, 事件玩家.currentPos + 事件玩家.level * 250)), 球体, 颜色(
			红色), 全局.OstacleBallPos[数组值的索引(全局.OstacleBallIndex, 事件玩家.currentPos + 事件玩家.level * 250)], 全局.OstacleBallRadius[数组值的索引(
			全局.OstacleBallIndex, 事件玩家.currentPos + 事件玩家.level * 250)], 可见，位置和半径);
		事件玩家.myEffectID[4] = 最后创建的实体;
		创建效果(已过滤的数组(事件玩家, 事件玩家.currentPos < 数量(事件玩家.myPosData) - 1 && 数组包含(全局.PinballIndex, 事件玩家.currentPos + 事件玩家.level * 250)), 球, 颜色(
			蓝色), 全局.PinballPos[数组值的索引(全局.PinballIndex, 事件玩家.currentPos + 事件玩家.level * 250)], 0.700, 可见，位置和半径);
		事件玩家.myEffectID[5] = 最后创建的实体;
		创建图标(已过滤的数组(事件玩家, 事件玩家.currentPos < 数量(事件玩家.myPosData) - 1 && 数组包含(全局.PinballIndex, 事件玩家.currentPos + 事件玩家.level * 250)),
			全局.PinballPos[数组值的索引(全局.PinballIndex, 事件玩家.currentPos + 事件玩家.level * 250)], 回收, 可见和位置, 颜色(天蓝色), 真);
		事件玩家.myEffectID[7] = 最后创建的实体;
		根据条件跳过(数量(全局.HintEffectPosArr) == 0 && 全局.GameMode == 1, 4);
		创建图标(已过滤的数组(事件玩家, 数组包含(全局.HintEffectIndex, 事件玩家.currentPos + 事件玩家.level * 250)), 全局.HintEffectPosArr[数组值的索引(全局.HintEffectIndex,
			事件玩家.currentPos + 事件玩家.level * 250)], 箭头：向上, 可见和位置, 颜色(蓝色), 假);
		事件玩家.myEffectID[8] = 最后创建的实体;
		创建图标(已过滤的数组(事件玩家, 数组包含(全局.HintEffectIndex, 事件玩家.currentPos + (事件玩家.level + 3) * 250)), 全局.HintEffectPosArr[数组值的索引(
			全局.HintEffectIndex, 事件玩家.currentPos + (事件玩家.level + 3) * 250)], 箭头：向上, 可见和位置, 颜色(蓝色), 假);
		事件玩家.myEffectID[9] = 最后创建的实体;
	}
}

规则("传送玩家至当前位置（）")
{
	事件
	{
		子程序;
		sendPlayerToCurrentPos;
	}

	动作
	{
		根据条件跳过(数量(事件玩家.myPosData) <= 0, 1);
		传送(事件玩家, 事件玩家.myPosData[事件玩家.currentPos]);
		等待(0.120, 无视条件);
	}
}

规则("开始计时（）")
{
	事件
	{
		子程序;
		startTimer;
	}

	动作
	{
		追踪玩家变量频率(事件玩家, timer, 10000, 1, 速率及最终值);
		追踪玩家变量频率(事件玩家, delay, 10000, 1, 速率及最终值);
	}
}

规则("停止计时（）")
{
	事件
	{
		子程序;
		stopTimer;
	}

	动作
	{
		停止追踪玩家变量(事件玩家, timer);
	}
}

规则("到达点位动作（）")
{
	事件
	{
		子程序;
		reachTarget;
	}

	动作
	{
		事件玩家.currentPos += 1;
		小字体信息(已过滤的数组(所有玩家(所有队伍), 当前数组元素 == 事件玩家 || 数组包含(全局.FinishedPlayerArr, 事件玩家) == 真), 字符串("{0} {1} {2}", 事件玩家, 自定义字符串("已抵达"), 字符串(
			"{0} {1} {2}", 字符串("{0} / {1}", 事件玩家.currentPos, 数量(事件玩家.myPosData) - 1), 全局.LevelNameArr[事件玩家.level], 自定义字符串(""))));
		播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(橙色), 事件玩家, 3);
		播放效果(事件玩家, 状态爆炸声音, 颜色(橙色), 事件玩家, 100);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(天蓝色), 事件玩家, 3);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(水绿色), 事件玩家, 4);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(橙色), 事件玩家, 5);
		事件玩家.deathNum = 0;
		事件玩家.skipFlag = 0;
	}
}

规则("落地死亡动作（）")
{
	事件
	{
		子程序;
		playerDeath;
	}

	动作
	{
		调用子程序(sendPlayerToCurrentPos);
		根据条件中止(全局.GameMode == 0);
		根据条件中止(事件玩家.delay < 2);
		事件玩家.deathNum += 1;
		事件玩家.delay = 0;
		追踪玩家变量频率(事件玩家, delay, 10000, 1, 速率及最终值);
		根据条件跳过(事件玩家.skipFlag == 0, 3);
		小字体信息(事件玩家, 自定义字符串("不要灰心~ 给你跳关机会噢。近战+左键跳过当前关卡。"));
		根据条件跳过(事件玩家.deathNum <= 全局.MaxDeathNum[事件玩家.level] * 3, 1);
		小字体信息(事件玩家, 自定义字符串("大佬，别肝了，我错了我再也不做难的点了，求您跳了吧！"));
	}
}

规则("通关动作（）")
{
	事件
	{
		子程序;
		playerWin;
	}

	动作
	{
		消除HUD文本(事件玩家.myTextID[1]);
		调用子程序(stopTimer);
		修改全局变量(FinishedPlayerArr, 添加至数组, 事件玩家);
		大字体信息(所有玩家(所有队伍), 字符串("{0} {1} {2}", 事件玩家, 自定义字符串("已通关"), 字符串("{0} {1} {2}", 全局.LevelNameArr[事件玩家.level], 自定义字符串("！ 所用时间： "),
			事件玩家.timer)));
		If(事件玩家.level == 0);
			创建HUD文本(所有玩家(所有队伍), 字符串("{0} {1} {2}", 英雄图标字符串(英雄(源氏)), 事件玩家, 字符串("{0} {1} {2}", 自定义字符串("："), 字符串("{0}秒", 事件玩家.timer),
				全局.LevelNameArr[事件玩家.level])), 无, 无, 右边, 事件玩家.timer, 颜色(天蓝色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		Else If(事件玩家.level == 1);
			创建HUD文本(所有玩家(所有队伍), 字符串("{0} {1} {2}", 英雄图标字符串(英雄(源氏)), 事件玩家, 字符串("{0} {1} {2}", 自定义字符串("："), 字符串("{0}秒", 事件玩家.timer),
				全局.LevelNameArr[事件玩家.level])), 无, 无, 右边, 事件玩家.timer / 5, 颜色(亮紫色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		Else If(事件玩家.level == 2);
			创建HUD文本(所有玩家(所有队伍), 字符串("{0} {1} {2}", 英雄图标字符串(英雄(源氏)), 事件玩家, 字符串("{0} {1} {2}", 自定义字符串("："), 字符串("{0}秒", 事件玩家.timer),
				全局.LevelNameArr[事件玩家.level])), 无, 无, 右边, 事件玩家.timer / 10, 颜色(橙色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		End;
		事件玩家.myTextID[1] = 上一个文本ID;
		设置启用技能 1(事件玩家, 真);
		设置启用终极技能(事件玩家, 真);
		消除效果(事件玩家.myEffectID[0]);
		消除效果(事件玩家.myEffectID[1]);
		消除效果(事件玩家.myEffectID[2]);
		消除图标(事件玩家.myEffectID[3]);
		消除效果(事件玩家.myEffectID[4]);
		消除效果(事件玩家.myEffectID[5]);
		消除效果(事件玩家.myEffectID[7]);
		消除图标(事件玩家.myEffectID[8]);
		消除图标(事件玩家.myEffectID[9]);
		消除地图文本(事件玩家.myTextID[0]);
	}
}

规则("传送动作及效果（）  （非3小图模式下不需要）")
{
	事件
	{
		子程序;
		deliverPlayer;
	}

	动作
	{
		事件玩家.invincible = 0;
		事件玩家.userBuffer = 1;
		停止追踪玩家变量(事件玩家, timer);
		开始镜头(事件玩家, 事件玩家.myPosData[事件玩家.currentPos], 事件玩家.myPosData[事件玩家.currentPos + 1], 1);
		等待(0.250, 无视条件);
		开始镜头(事件玩家, 事件玩家.myPosData[事件玩家.currentPos + 1] + 矢量(0, 2, 0), 事件玩家.myPosData[事件玩家.currentPos + 2], 1);
		等待(8, 无视条件);
		停止镜头(事件玩家);
		追踪玩家变量频率(事件玩家, timer, 绝对值(9999999.000), 1, 速率及最终值);
		事件玩家.userBuffer = 0;
		调用子程序(reachTarget);
		调用子程序(sendPlayerToCurrentPos);
	}
}

规则("球体效果刷新（）")
{
	事件
	{
		子程序;
		refreashBallEffect;
	}

	动作
	{
		根据条件跳过(数组包含(全局.OstacleBallIndex, 事件玩家.currentPos + 事件玩家.level * 250) == 假, 3);
		消除效果(事件玩家.myEffectID[4]);
		创建效果(事件玩家, 球体, 颜色(红色), 全局.OstacleBallPos[数组值的索引(全局.OstacleBallIndex, 事件玩家.currentPos + 事件玩家.level * 250)],
			全局.OstacleBallRadius[数组值的索引(全局.OstacleBallIndex, 事件玩家.currentPos + 事件玩家.level * 250)], 可见，位置和半径);
		事件玩家.myEffectID[4] = 最后创建的实体;
		根据条件跳过(数组包含(全局.PinballIndex, 事件玩家.currentPos + 事件玩家.level * 250) == 假, 3);
		消除效果(事件玩家.myEffectID[5]);
		创建效果(事件玩家, 球, 颜色(天蓝色), 全局.PinballPos[数组值的索引(全局.PinballIndex, 事件玩家.currentPos + 事件玩家.level * 250)], 0.700, 可见，位置和半径);
		事件玩家.myEffectID[5] = 最后创建的实体;
	}
}

规则("")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		禁用查看器录制;
		全局.Blacklist = 数组(自定义字符串("黑白剑舞"));
		启用查看器录制;
	}
}

规则("")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		数组包含(全局.Blacklist, 自定义字符串("{0}", 事件玩家)) == 真;
		存活(事件玩家) == 真;
	}

	动作
	{
		击杀(事件玩家, 无);
		等待(0.250, 无视条件);
		如条件为”真“则循环;
	}
}