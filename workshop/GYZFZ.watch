设置
{
	主程序
	{
		描述: "仓鼠跑酷开拓者, by喜欢跑酷的小伙伴们. GYZFZ 2.43加入超级跳模式 ! ver2.50加入传送点  直接更换地图即可游玩不同点位 更多跑酷点位和教学前往熔火工坊查看  其他合集代码：9ZDS3 | G7V27 | 13GT0R | HSCNX(备用)"
		模式名称: "十元の仓鼠跑酷"
	}

	大厅
	{
		比赛语音聊天: 启用
		玩家上限 队伍1: 12
		玩家上限 队伍2: 0
		观战者人数上限: 6
		返回大厅: 从不
		队列中的玩家可以加入: 是
	}

	模式
	{
		团队死斗
		{
			启用地图
			{
				绿洲城中心
				马莱温多
			}
		}

		突击模式
		{
			启用地图
			{
				66号公路
				万圣节艾兴瓦尔德
				哈瓦那
			}
		}

		训练靶场
		{
			启用地图
			{
			}
		}

		禁用 运载目标
		{
			运载目标速度: 10%
		}

		综合
		{
			允许切换英雄: 关闭
			复生时间: 5%
			急救包刷新: 禁用
			消灭提示: 关闭
			消灭镜头: 关闭
			游戏模式开始: 即时
			英雄限制: 关闭
			随机英雄复生: 开启
		}
	}

	英雄
	{
		综合
		{
			无需装弹: 开启
			终极技能充能速度: 10%
			终极技能自动充能速度: 0%
			重生时终极技能充能完毕: 开启

			末日铁拳
			{
				上勾重拳 冷却时间: 12%
				火箭重拳 冷却时间: 6%
				终极技能（毁天灭地）: 关闭
				裂地重拳 冷却时间: 6%
			}

			源氏
			{
				重生时终极技能充能完毕: 开启
			}

			破坏球
			{
				终极技能（地雷禁区）: 关闭
				重力坠击 冷却时间: 0%
			}

			启用英雄
			{
				破坏球
			}
		}
	}

	地图工坊
	{
		是否允许开拓: 开启
		目标点圈不透明度: 244
		目标点圈大小: 1.800
		跳关提醒: 关闭
	}
}

变量
{
	全局:
		0: CheckpointPosition
		1: Ability1State
		2: Ability2State
		3: SecondaryFireState
		4: UltimateState
		5: Creator
		6: RingRadius
		7: JudgeWhenLanding
		8: DefaultAliblty1Enabled
		9: DefaultAliblty2Enabled
		10: DefaultSecondaryEnabled
		11: DefaultUltimateEnabled
		12: UltimateCD
		13: OneTimeAbility
		14: DisableContinuousCreation
		15: PioneerModeEnabled
		16: Pioneer
		17: PioneerStarted
		18: PioneerLandingPosition
		19: RoomAliveHoursLeft
		20: BestScore
		22: CurrentMap
		23: TeleportWhenEnterNextPosition
		24: _unused_var_24
		26: RGB
		27: JumpState
		28: CheatRecord

	玩家:
		0: Level
		1: BestScore
		2: LastScore
		3: ScoreOfThisRound
		4: GameComplete
		5: IsReady
		6: Invisible
		7: FreeMode
		8: InteractPressState
		9: FacingDirection
		10: UltimateCharge
		11: Ability1Used
		12: Ability2Used
		13: SecondaryFireUsed
		14: UltimateUsed
		15: IsSpectating
		16: _unused_var_16
		17: _unused_var_17
		18: _unused_var_18
		19: _unused_var_19
		20: _unused_var_20
		21: _unused_var_21
		24: _unused_var_24
		26: pioneer_mode
}

子程序
{
	0: SetAbility
	1: Reset
	3: MessageCall
	4: ResetBall
}

规则("禁用查看器")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		禁用查看器录制;
	}
}

规则("房主发感谢即可更新导出数据,随后在查看器导出全局数据")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在交流(主机玩家, 感谢) == 真;
	}

	动作
	{
		全局.CurrentMap = 当前地图;
		启用查看器录制;
		禁用查看器录制;
		小字体信息(主机玩家, 自定义字符串("点位数据已导出,请打开查看器复制"));
		小字体信息(主机玩家, 自定义字符串("别忘了选择当前地图和当前比赛模式哦！"));
	}
}


规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 马莱温多")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(马莱温多);
		当前游戏模式 == 游戏模式(团队死斗);
	}

	动作
	{
		全局.CheckpointPosition = 数组(矢量(16.671, 0.981, -26.167), 矢量(16.556, 3, -19.696), 矢量(8.527, -1, -22.178), 矢量(7.228, 4.652, -19.076),
			矢量(-0.814, -3.500, -34.108), 矢量(-14.248, -2.990, -30.901), 矢量(-33.766, -2, 6.872), 矢量(-33.911, 4, 5.544), 矢量(-33.521, -2,
			10.577), 矢量(-34.833, 0.010, 19.375), 矢量(-19.744, 0, 11.620), 矢量(-12.911, 4.103, 13.443), 矢量(-0.027, 10.096, 0.739), 矢量(-5.195,
			5.037, 13.689), 矢量(-0.262, 10.103, 25.955), 矢量(0.169, 1.750, 34.510), 矢量(2.900, 2.282, 10.224), 矢量(31.990, 5.117, 31.136), 矢量(
			21.840, 8.314, 34.156), 矢量(31.538, 3.155, 26.356), 矢量(24.234, 8.713, 21.428), 矢量(32.704, 7.492, 23.932), 矢量(21.763, 9.046,
			35.607), 矢量(25.336, 8.822, 21.704), 矢量(17.680, 6.523, 6.135), 矢量(1.446, -1, -8.110), 矢量(-1.970, -1, -17.884), 矢量(-8.827, 5.114,
			-21.205), 矢量(-28.450, -2.041, -16.828), 矢量(-27.884, 3.010, -0.475), 矢量(-25.980, -2.070, -21.695), 矢量(-20.008, 2.004, -17.528),
			矢量(-7.754, 5.120, -19.574), 矢量(9.506, 3.095, -8.672), 矢量(-1.744, 5.125, -18.637), 矢量(-0.571, 2.673, 42.960), 矢量(-30.556, 4.750,
			20.132), 矢量(-33.340, 4, 9.512), 矢量(7.661, -2.046, -32.677), 矢量(8.150, -1, -27.877), 矢量(0.360, -3.478, -37.379), 矢量(-16.445, -3,
			-28.918), 矢量(22.512, 2.573, -17.646), 矢量(-19.053, -3, -31.734), 矢量(25.211, 8.828, 21.859), 矢量(16.766, 9, 31.436), 矢量(0.708,
			10.288, 0.880), 矢量(0.864, 1.751, 33.339), 矢量(-15.550, -2.692, -26.547), 矢量(-34.439, -6.063, 41.478));
		全局.SecondaryFireState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 真, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真,
			真, 假, 真, 假, 假, 真, 假, 真, 真, 假, 假, 真, 假, 假);
		全局.UltimateState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 矢量(-14.678, 0.187, -26.220), 假, 假, 假, 假, 假);
		全局.Creator = 数组(自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"),
			自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"),
			自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"),
			自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"),
			自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("冰泽"), 自定义字符串("冰泽"), 自定义字符串("冰泽"), 自定义字符串("Exit"), 自定义字符串(
			"Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"));
		全局.CurrentMap = 地图(马莱温多);
		全局.JumpState = 数组(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假);
	}
}


规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 66号公路（十元）")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(66号公路);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		全局.CheckpointPosition = 数组(矢量(62.435, 2.449, 15.489), 矢量(63.866, 9.279, 12.599), 矢量(52.595, 7.778, -0.755), 矢量(37.225, 2.175,
			3.927), 矢量(50.166, 7.936, 13.003), 矢量(37.063, 7.842, -0.964), 矢量(13.122, 4.052, 11.161), 矢量(18.287, 2.095, 8.861), 矢量(47.442,
			2.221, -2.129), 矢量(43.369, 6.980, -1.100), 矢量(35.367, 0.312, 59.334), 矢量(31.900, 5.807, 48.797), 矢量(42.443, 0.779, 41.795), 矢量(
			50.171, 6.277, 24.162), 矢量(66.419, 5.316, 35.913), 矢量(56.238, 0.273, 46.206), 矢量(49.511, 7.075, 46.483), 矢量(55.630, 9.365,
			42.772), 矢量(38.857, 0.902, 39.562), 矢量(53.428, 6.845, 20.911), 矢量(53.960, 12.869, 9.897), 矢量(71.693, -0.053, 7.492), 矢量(35.727,
			7.871, -0.021), 矢量(13.638, 8.921, -20.951), 矢量(15.662, 2.231, -15.483), 矢量(14.897, 8.364, -21.303), 矢量(13.731, 7.609, 1.777),
			矢量(30.618, 7.057, 9.146), 矢量(8.944, 8.688, -24.446), 矢量(-0.899, 2.627, -16.691), 矢量(-8.115, 8.136, -9.475), 矢量(-15.053, 8.533,
			-14.194), 矢量(-21.709, 14.561, -12.959), 矢量(-41.480, 3.347, 2.360), 矢量(-36.983, 10.584, 5.085), 矢量(-33.156, 12.752, -9.599), 矢量(
			-13.263, 12.033, -38.300), 矢量(-1.138, 6.932, -21.578), 矢量(-4.746, 8.617, -40.562), 矢量(-24.981, 8.699, -30.917), 矢量(-35.469,
			3.308, -30.241), 矢量(-31.459, 12.752, -25.591), 矢量(-24.025, 3.978, 9.925), 矢量(-35.836, 10.579, 6.051), 矢量(0.815, 7.358,
			-20.684), 矢量(-40.599, 8.656, -21.617), 矢量(-41.892, 3.346, 1.558), 矢量(-59.847, 11.751, 21.247), 矢量(-68.108, 10.867, 5.771), 矢量(
			-69.879, 12.846, 13.313), 矢量(-79.237, 12.500, -1.351), 矢量(-97.844, 6.500, -34.312), 矢量(-102.876, 12.500, -25.229), 矢量(-55.825,
			12.639, 15.423), 矢量(-72.599, 12.557, 16.384), 矢量(-94.840, 8.500, 8.891), 矢量(-84.700, 6.500, 16.008), 矢量(-80.988, 13.085,
			15.894), 矢量(-90.007, 9.985, 4.759), 矢量(-93.197, 6.500, -12.108), 矢量(-105.513, 14.106, -10.702));
		全局.SecondaryFireState = 数组(假, 假, 假, 真, 真, 真, 假, 真, 假, 真, 假, 假, 真, 假, 假, 假, 假, 假, 真, 真, 假, 真, 真, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 假,
			真, 假, 假, 真, 假, 假, 真, 假, 真, 真, 真, 真, 假, 假, 假, 真, 假, 真, 假, 假, 假, 假, 假, 假, 假);
		全局.UltimateState = 数组(假, 假, 假, 假, 矢量(30.937, 2.190, 17.084), 矢量(31.609, 7.021, 19.943), 矢量(24.158, 6.726, 0.169), 假, 矢量(38.898,
			2.187, 10.476), 假, 假, 假, 假, 矢量(49.478, 0.315, 35.893), 假, 假, 假, 假, 假, 矢量(49.706, 0.317, 35.885), 矢量(53.073, 9.592, 11.993), 假,
			假, 矢量(25.771, 8.114, -10.338), 假, 假, 假, 假, 矢量(25.784, 8.192, -16.950), 假, 假, 假, 假, 假, 假, 假, 矢量(-29.089, 12.776, -25.617), 假, 假,
			矢量(-10.605, 8.627, -42.196), 假, 假, 假, 假, 假, 假, 假, 矢量(-52.135, 6.592, 23.756), 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假);
		全局.Creator = 数组(自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("花开堪折直须折"), 自定义字符串("花开堪折直须折"), 自定义字符串("花开堪折直须折"), 自定义字符串("花开堪折直须折"), 自定义字符串(
			"石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"),
			自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"),
			自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("MrCoco"), 自定义字符串("MrCoco"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串(
			"石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"),
			自定义字符串("石原里美"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"),
			自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("石原里美"), 自定义字符串("柠檬"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("柠檬"),
			自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("Exit"), 自定义字符串("Exit"));
	}
}

规则("艾兴瓦尔德dddd")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(万圣节艾兴瓦尔德);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		全局.CheckpointPosition = 数组(矢量(4.030, 5, -12.215), 矢量(-13.604, 1.681, -22.860), 矢量(9.728, 10.361, -38.730), 矢量(-31.968, -1.140,
			-17.910), 矢量(12.141, 3.834, -29.569), 矢量(12.728, 10.307, -42.250), 矢量(6.370, 13.613, -44.386), 矢量(25.936, 5, -53.187), 矢量(
			9.715, 5.813, -69.829), 矢量(22.285, 4.834, -54.943), 矢量(25.278, 5.106, -64.922), 矢量(25.300, 11.536, -69.832), 矢量(45.185, 8.289,
			-93.065), 矢量(33.407, 13.999, -86.650), 矢量(42.982, 5.752, -62.737), 矢量(57.116, 11.702, -59.466), 矢量(63.081, 16.096, -60.218),
			矢量(72.226, 14.123, -65.652), 矢量(68.367, 10.567, -79.101));
		全局.SecondaryFireState = 数组(假, 真, 假, 真, 假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假);
		全局.UltimateState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假);
		全局.Creator = 数组(自定义字符串("小小十元"), 自定义字符串("小小十元"), 自定义字符串("小小十元"), 自定义字符串("小小十元"), 自定义字符串("小小十元"), 自定义字符串("小小十元"), 自定义字符串("小小十元"),
			自定义字符串("小小十元"), 自定义字符串("小小十元"), 自定义字符串("小小十元"), 自定义字符串("小小十元"), 自定义字符串("小小十元"), 自定义字符串("小小十元"), 自定义字符串("小小十元"), 自定义字符串("小小十元"),
			自定义字符串("小小十元"), 自定义字符串("小小十元"), 自定义字符串("小小十元"));
		全局.CurrentMap = 地图(万圣节艾兴瓦尔德);
		全局.RGB = 数组(255, 255, 0, 244, 208, 68, 180, 255);
	}
}

规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 绿洲城（吃货十元）")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(绿洲城中心);
		当前游戏模式 == 游戏模式(团队死斗);
	}

	动作
	{
		全局.CheckpointPosition = 数组(矢量(98.028, 1.001, 313.191), 矢量(116.353, 4.608, 281.949), 矢量(102.023, 1, 272.342), 矢量(99.683, 0.850,
			278.267), 矢量(110.831, 2, 277.815), 矢量(107.271, 1, 264.734), 矢量(109.054, 3.932, 262.338), 矢量(109.003, 2.010, 273.090), 矢量(
			94.599, 1, 271.296), 矢量(104.316, 0.850, 273.487), 矢量(96.771, 1, 265.435), 矢量(114.936, 0.850, 290.941), 矢量(126.488, 1.850,
			287.899), 矢量(121.342, 2.914, 288.458), 矢量(126.363, 4, 253.821), 矢量(131.162, 1.851, 244.181), 矢量(129.342, 2.345, 252.827), 矢量(
			102.676, 0.850, 274.842), 矢量(93.705, 0.855, 263.483), 矢量(98.491, 2.322, 244.691), 矢量(112.646, 0.527, 239.136), 矢量(118.919,
			3.783, 238.481), 矢量(138.547, 10.010, 245.003), 矢量(153.322, 11.542, 257.063), 矢量(171.622, 4.001, 254.780), 矢量(167.183, 6.942,
			253.925), 矢量(166.260, 11.522, 252.707), 矢量(161.737, 11.531, 262.865), 矢量(164.610, 4.176, 268.672), 矢量(143.437, 10, 251.989),
			矢量(149.259, 11.522, 261.565), 矢量(138.672, 10, 250.092), 矢量(147.916, 11.707, 261.721), 矢量(157.702, 11.746, 251.723), 矢量(159.693,
			4.001, 256.769), 矢量(159.413, 11.634, 255.921), 矢量(151.512, 4, 232.313), 矢量(138.689, 1.851, 234.775), 矢量(149.596, 11.562,
			260.694), 矢量(175.019, 2, 220.472), 矢量(206.853, 2.002, 227.459), 矢量(179.633, 0.850, 200.063), 矢量(159.603, 11.522, 255.090), 矢量(
			165.998, 4.093, 265.335), 矢量(146.784, 11.522, 273.846), 矢量(131.747, 2, 293.670), 矢量(153.902, 11.648, 261.712), 矢量(141.549,
			2.001, 253.483), 矢量(142.697, 10, 252.539), 矢量(144.325, 4.001, 264.789), 矢量(149.305, 11.549, 261.045), 矢量(172.023, 4.118,
			276.882), 矢量(176.604, 0.850, 200.795), 矢量(155.851, 0.500, 195.781), 矢量(110.313, 0.850, 293.611));
		全局.SecondaryFireState = 数组(真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 真, 假, 假, 真, 假, 真, 假, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 真, 真, 真, 真, 真, 假, 假, 假, 真, 假, 假, 假, 假, 真, 真, 真, 真);
		全局.UltimateState = 数组(假, 矢量(104.963, 1.092, 301.731), 假, 假, 假, 假, 假, 假, 假, 假, 假, 矢量(92.822, 1.092, 285.022), 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 矢量(156.200, 1.942, 250.037), 矢量(159.425, 11.614, 256.222), 矢量(181.071,
			2.092, 225.415), 矢量(203.229, 1.102, 218.665), 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 矢量(164.368, 6.394, 268.131), 假, 假);
		全局.Creator = 数组(自定义字符串("十元爱吃麻辣烫"), 自定义字符串("十元爱吃汤菠饺"), 自定义字符串("十元爱吃宫廷糕"), 自定义字符串("十元爱吃糯米团"), 自定义字符串("十元爱吃炒河粉"), 自定义字符串("十元爱吃甜皮鸭"),
			自定义字符串("十元爱吃糖油果子"), 自定义字符串("十元爱吃麻辣兔头"), 自定义字符串("十元爱吃红烧鱼"), 自定义字符串("十元爱吃虾仁面"), 自定义字符串("十元爱吃豆花菜"), 自定义字符串("十元爱吃甜水面"), 自定义字符串(
			"十元爱吃卤猪蹄"), 自定义字符串("十元爱吃泡椒凤爪"), 自定义字符串("十元爱吃小龙虾"), 自定义字符串("十元爱吃橡皮糖"), 自定义字符串("十元爱吃钵钵鸡"), 自定义字符串("十元爱吃酸辣粉"), 自定义字符串("十元爱吃酱骨架"),
			自定义字符串("十元爱吃炸酱面"), 自定义字符串("十元爱吃水煮鱼"), 自定义字符串("十元爱吃海白菜"), 自定义字符串("十元爱吃飘香排骨"), 自定义字符串("十元爱吃叉烧包"), 自定义字符串("十元爱吃葱油饼"), 自定义字符串(
			"十元爱吃黄金饺"), 自定义字符串("十元爱吃烤玉米"), 自定义字符串("十元爱吃东坡肉"), 自定义字符串("十元爱吃猫耳朵"), 自定义字符串("十元爱吃葱包烩"), 自定义字符串("十元爱吃海棠糕"), 自定义字符串("十元爱吃酥油饼"),
			自定义字符串("十元爱吃麻球王"), 自定义字符串("十元爱吃鲜虾小笼"), 自定义字符串("十元爱吃炒栗子"), 自定义字符串("十元爱吃荷叶饼"), 自定义字符串("十元爱吃桂花糕"), 自定义字符串("十元爱吃京酱面"), 自定义字符串(
			"十元爱吃梨膏糖"), 自定义字符串("十元爱吃白斩鸡"), 自定义字符串("十元爱吃烤冷面"), 自定义字符串("十元爱吃酒酿饼"), 自定义字符串("十元爱吃蟹脚面"), 自定义字符串("十元爱吃云吞面"), 自定义字符串("十元爱吃柴火鸡"),
			自定义字符串("十元爱吃蛋烘糕"), 自定义字符串("十元爱吃麻抄手"), 自定义字符串("十元爱吃乌冬面"), 自定义字符串("十元爱吃铜锣烧"), 自定义字符串("十元爱吃天妇罗"), 自定义字符串("十元爱吃可乐饼"), 自定义字符串(
			"十元爱吃关东煮"), 自定义字符串("十元爱吃三文鱼"), 自定义字符串("十元永远吃不胖~"));
	}
}


禁用 规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 哈瓦那（十元）")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(哈瓦那);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		全局.CheckpointPosition = 数组(矢量(-30.072, 6, -70.890), 矢量(-24.397, 12, -64.485), 矢量(-24.194, 6.025, -56.781), 矢量(-28.851, 15.448,
			-83.194), 矢量(-24.712, 12.010, -65.273), 矢量(-7.715, 12, -64.293), 矢量(1.866, 6, -95.020), 矢量(-24.938, 12, -63.754), 矢量(-75.020,
			3.850, -50.590), 矢量(-83.771, 3.850, -57.962), 矢量(-84.294, 7.972, -48.083), 矢量(-92.923, 3.850, -44.780), 矢量(-81.298, 3.850,
			-43.689), 矢量(-48.974, 9.983, -42.837), 矢量(-44.095, 9.994, -44.187), 矢量(-29.514, 12, -49.974), 矢量(0.729, 12, -78.799), 矢量(
			14.871, 5.906, -78.363), 矢量(14.652, 8.448, -86.077), 矢量(36.047, 6, -78.490), 矢量(63.772, 12, -83.252), 矢量(67.540, 11.054,
			-72.563), 矢量(76.142, 4.993, -97.033), 矢量(80.979, 10.895, -70.282), 矢量(70.047, 5.993, -88.142), 矢量(82.747, 6.996, -59.233), 矢量(
			80.868, 11.266, -68.741), 矢量(81.459, 3.993, -78.431), 矢量(80.974, 10.367, -76.431), 矢量(98.039, 2.964, -67.092), 矢量(113.057,
			6.938, -53.527), 矢量(89.298, 9.135, -33.801), 矢量(88.556, 12.492, -44.511), 矢量(126.897, 4.913, -16.536), 矢量(100.124, 8.940,
			-27.326), 矢量(102.438, 2.607, -27.386), 矢量(99.804, 8.940, -27.893), 矢量(102.584, 6.969, -42.423), 矢量(120.938, 12.870, -59.501),
			矢量(135.494, 6, -59.038), 矢量(146.323, 8.987, -34.007), 矢量(124.156, 12.040, -52.520), 矢量(98.100, 1.995, -71.097), 矢量(91.352,
			6.069, -93.267), 矢量(79.032, 7.003, -51.735), 矢量(117.559, 13.043, -57.890), 矢量(145.885, 9.030, -63.980), 矢量(132.348, 10.263,
			-32.757), 矢量(136.168, 6.002, -31.007), 矢量(132.295, 10.284, -33.163), 矢量(100.407, 4.695, -38.995), 矢量(119.453, 4.350, -23.729),
			矢量(113.101, 6.969, -34.198), 矢量(98.415, 2.962, -66.314), 矢量(75.862, 6.993, -75.066), 矢量(73.438, 9.313, -88.548), 矢量(54.185, 6,
			-92.632), 矢量(36.277, 6, -78.165), 矢量(34.543, 11.927, -85.928), 矢量(34.820, 17.371, -83.787), 矢量(16.279, 12.659, -70.056), 矢量(
			36.454, 6, -78.330), 矢量(34.438, 16.353, -77.661));
		全局.SecondaryFireState = 数组(假, 假, 真, 假, 假, 假, 真, 真, 假, 真, 假, 假, 真, 假, 假, 真, 真, 真, 真, 真, 真, 真, 真, 假, 真, 假, 假, 假, 假, 真, 真, 假, 真, 真, 假,
			假, 假, 真, 假, 真, 真, 真, 真, 真, 真, 假, 真, 假, 假, 真, 真, 假, 真, 真, 假, 真, 真, 假, 假, 假, 真, 假);
		全局.UltimateState = 数组(假, 假, 假, 矢量(-36.606, 5.952, -68.745), 假, 假, 假, 矢量(-11.976, 5.941, -72.826), 假, 假, 矢量(-89.654, 3.941,
			-48.255), 假, 假, 矢量(-66.288, 3.941, -52.777), 假, 假, 假, 假, 矢量(17.164, 6.092, -91.569), 假, 矢量(44.178, 6.092, -76.134), 假, 矢量(
			76.041, 7.085, -76.661), 矢量(80.159, 4.004, -90.751), 假, 矢量(72.466, 6.083, -76.924), 假, 假, 假, 假, 矢量(98.446, 5.192, -58.816), 矢量(
			108.869, 7.076, -42.947), 假, 假, 矢量(117.497, 5.174, -24.206), 假, 假, 假, 矢量(108.796, 7.077, -49.304), 假, 矢量(145.375, 9.103,
			-56.231), 矢量(134.987, 6.188, -35.372), 假, 矢量(105.609, 2.121, -80.513), 假, 矢量(97.461, 6.147, -55.989), 假, 假, 假, 假, 矢量(120.325,
			10.334, -33.156), 矢量(109.814, 1.330, -24.542), 假, 矢量(110.648, 7.127, -49.309), 矢量(84.548, 4.497, -63.139), 假, 假, 矢量(52.047,
			6.092, -79.193), 假, 假, 假, 假, 假);
		全局.Creator = 数组(自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"),
			自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"),
			自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"),
			自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"),
			自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"),
			自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"),
			自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("Exit"), 自定义字符串(
			"Exit"));
	}
}

规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 哈瓦那")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(哈瓦那);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		全局.CheckpointPosition = 数组(矢量(36.765, 6, -87.623), 矢量(34.358, 11.680, -86.145), 矢量(34.626, 17.556, -83.672), 矢量(36.771, 6,
			-78.605), 矢量(34.237, 16.353, -77.684), 矢量(12.210, 12, -79.896), 矢量(-21.028, 14.441, -84.829), 矢量(25.370, 8.344, -47.190), 矢量(
			32.326, 12.067, -54.955), 矢量(36.121, 12.066, -63.673), 矢量(5.674, 6, -88.325), 矢量(-8.146, 12, -63.943), 矢量(15.215, 12.885,
			-68.653), 矢量(41.388, 6, -55.800), 矢量(34.402, 17.674, -75.275), 矢量(0.983, 6, -95.727), 矢量(-23.724, 12, -63.772), 矢量(-21.855, 12,
			-51.602), 矢量(-49.571, 10, -42.669), 矢量(-29.606, 12.010, -35.063), 矢量(-29.555, 12, -59.067), 矢量(-2.892, 12, -51.869), 矢量(-7.138,
			12.010, -65.140), 矢量(-15.032, 6, -90.738), 矢量(-8.015, 12, -64.643), 矢量(15.245, 6, -57.875), 矢量(31.575, 12, -62.652), 矢量(61.089,
			6.077, -93.254), 矢量(66.594, 6.087, -93.268), 矢量(81.194, 11.043, -67.001), 矢量(98.614, 1.995, -73.242), 矢量(117.049, 13.179,
			-58.560), 矢量(102.181, 1.977, -74.834), 矢量(109.262, 0.049, -53.204), 矢量(119.927, 3.987, -24.045), 矢量(133.178, 6, -60.199), 矢量(
			82.142, 6.303, -97.420), 矢量(100.190, 2.627, -66.314), 矢量(117.309, 5.082, -23.044), 矢量(110.178, 3.298, -21.044), 矢量(104.693,
			3.281, -21.415));
		全局.SecondaryFireState = 数组(假, 假, 假, 假, 假, 真, 真, 假, 真, 真, 真, 真, 真, 真, 真, 真, 真, 真, 真, 假, 真, 假, 假, 真, 真, 真, 真, 假, 真, 真, 真, 假, 真, 真, 真,
			真, 真, 真, 假, 假);
		全局.UltimateState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假);
		全局.Creator = 数组(自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串(
			"今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串(
			"今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串(
			"今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串(
			"今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串(
			"今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串(
			"今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"), 自定义字符串("今天要来点十元吗"));
	}
}

规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 万圣节艾兴瓦尔德（十元）")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(万圣节艾兴瓦尔德);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		全局.CheckpointPosition = 数组(矢量(24.564, 11.162, -75.205), 矢量(22.744, 6.207, -77.980), 矢量(25.047, 11.774, -75.594), 矢量(7.359, 11.012,
		-85.220), 矢量(20.887, 11.010, -73.259), 矢量(26.106, 5, -52.438), 矢量(9.964, 5.813, -70.081), 矢量(21.857, 11, -73.737), 矢量(49.519,
		11.493, -75.644), 矢量(51.435, 18.188, -76.275), 矢量(51.931, 21.486, -65.229), 矢量(33.616, 13.797, -85.510), 矢量(48.438, 10.060,
		-97.137), 矢量(32.817, 14.010, -86.309), 矢量(50.074, 10.154, -97.590), 矢量(52.907, 17.886, -99.868), 矢量(58.244, 10.964, -87.964),
		矢量(58.903, 18.046, -85.523), 矢量(81.648, 21.153, -65.086), 矢量(89.399, 12.783, -61.355), 矢量(89.825, 20.806, -62.012), 矢量(88.999,
		13.340, -95.627), 矢量(67.336, 4.723, -82.916), 矢量(68.166, 10.570, -79.765), 矢量(78.188, 13.106, -85.196), 矢量(95.907, 12.666,
		-78.044), 矢量(102.987, 17.708, -71.881), 矢量(13.227, 11.012, -82.311), 矢量(23.805, 4.814, -57.276), 矢量(17.327, 10.401, -42.665),
		矢量(7.015, 5.562, -45.193), 矢量(6.554, 13.623, -44.420), 矢量(16.643, 4.640, -45.604), 矢量(8.969, 9.779, -40.639), 矢量(6.074, 4,
		-34.450), 矢量(8.782, 9.875, -38.612), 矢量(-29.935, 0.580, -26.272), 矢量(-2.627, 5, -14.749), 矢量(53.480, 6.696, -60.735), 矢量(
		49.936, 11.503, -72.848), 矢量(32.730, 6.024, -73.196), 矢量(21.881, 4.854, -53.931), 矢量(-12.052, 1.822, -29.142), 矢量(-29.303,
		1.967, -32.208), 矢量(6.802, 11.012, -86.519), 矢量(81.537, 21.153, -65.689), 矢量(6.802, 11.012, -86.519));
		全局.SecondaryFireState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假,
		假, 真, 真, 假, 假, 假, 真, 假, 假, 真, 假);
		全局.UltimateState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
		假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假);
		全局.Creator = 数组(自定义字符串("十元的妹妹"), 自定义字符串("十元的妹妹"), 自定义字符串("十元的妹妹"), 自定义字符串("十元的妹妹"), 自定义字符串("十元的妹妹"), 自定义字符串("十元的妹妹"), 自定义字符串(
		"十元的妹妹"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"),
		自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("哔哩哔哩第一帅"), 自定义字符串("哔哩哔哩第一帅"), 自定义字符串("哔哩哔哩第一帅"),
		自定义字符串("哔哩哔哩第一帅"), 自定义字符串("哔哩哔哩第一帅"), 自定义字符串("哔哩哔哩第一帅"), 自定义字符串("哔哩哔哩第一帅"), 自定义字符串("哔哩哔哩第一帅"), 自定义字符串("哔哩哔哩第一帅"), 自定义字符串("柠檬"),
		自定义字符串("柠檬"), 自定义字符串("哔哩哔哩第一帅"), 自定义字符串("哔哩哔哩第一帅"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("哔哩哔哩第一帅"), 自定义字符串(
		"哔哩哔哩第一帅"), 自定义字符串("哔哩哔哩第一帅"), 自定义字符串("哔哩哔哩第一帅"), 自定义字符串("哔哩哔哩第一帅"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("冰泽"), 自定义字符串(
		"Exit"));
		全局.JumpState = 数组(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 真, 假, 假);
	}
}

规则("[自定义]允许开拓? 否则将使用导入的点位进行常规计时跑酷模式")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		禁用 全局.PioneerModeEnabled = 真;
		全局.PioneerModeEnabled = 地图工坊设置开关(自定义字符串("模式设置开关"), 自定义字符串("是否允许开拓"), 假, 0);
		全局.RGB[0] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("目标点圈红"), 255, 0, 255, 0);
		全局.RGB[1] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("目标点圈绿"), 255, 0, 255, 1);
		全局.RGB[2] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("目标点圈蓝"), 0, 0, 255, 2);
		全局.RGB[3] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("目标点圈不透明度"), 255, 0, 255, 3);
		全局.RGB[4] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串(" 起飞点圈红"), 208, 0, 255, 4);
		全局.RGB[5] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串(" 起飞点圈绿"), 68, 0, 255, 5);
		全局.RGB[6] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串(" 起飞点圈蓝"), 180, 0, 255, 6);
		全局.RGB[7] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串(" 起飞点圈不透明度"), 255, 0, 255, 7);
	}
}

规则("[自定义]禁止连续开拓")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		禁用 全局.DisableContinuousCreation = 假;
		全局.DisableContinuousCreation = 地图工坊设置开关(自定义字符串("模式设置开关"), 自定义字符串("连续开拓"), 假, 1);
		全局.CheatRecord = 地图工坊设置开关(自定义字符串("快捷键"), 自定义字符串("跳关提醒"), 真, 0);
	}
}

规则("[自定义]落地判定是否开启")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.JudgeWhenLanding = 真;
	}
}

规则("[自定义]判定圈的大小")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.RingRadius[0] = 地图工坊设置实数(自定义字符串("参数"), 自定义字符串("目标点圈大小"), 1.500, 0.500, 4, 0);
		全局.RingRadius[1] = 地图工坊设置实数(自定义字符串("参数"), 自定义字符串(" 起始点圈大小"), 2, 0.200, 5, 1);
		全局.RingRadius[2] = 地图工坊设置实数(自定义字符串("参数"), 自定义字符串("起飞点圈大小"), 2, 0.200, 4, 2);
	}
}

规则("[自定义] 进点传送")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.TeleportWhenEnterNextPosition = 假;
	}
}

规则("[自定义]一次性技能(如开启本功能,请确保技能CD大于0.5秒)")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.OneTimeAbility = 真;
	}
}

规则("[自定义]哪些技能可以使用(如果要开启大招,请关掉 英雄-设置-大招自动充能 )")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"技能1(S)"
		全局.DefaultAliblty1Enabled = 真;
		"技能2(E)"
		全局.DefaultAliblty2Enabled = 真;
		"辅助攻击模式(右键)"
		全局.DefaultSecondaryEnabled = 真;
		"终极技能"
		全局.DefaultUltimateEnabled = 假;
	}
}

规则("[自定义]终极技能的冷却时间")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.UltimateCD = 15;
	}
}

规则("全局初始化")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		关闭游戏预设通告模式;
		关闭游戏预设计分模式;
		关闭游戏预设完成条件;
		关闭游戏预设音乐模式;
		根据条件跳过(!(数量(全局.CheckpointPosition) == 0), 6);
		全局.CheckpointPosition = 空数组;
		全局.Ability1State = 空数组;
		全局.Ability2State = 空数组;
		全局.SecondaryFireState = 空数组;
		全局.Creator = 空数组;
		全局.UltimateState = 空数组;
		全局.RoomAliveHoursLeft = 4;
		设置比赛时间(1800);
		设置目标点描述(所有玩家(所有队伍), 自定义字符串("本局游戏时间还剩：​{0}小时​{1}分钟​", 全局.RoomAliveHoursLeft, 取整(比赛时间 / 60, 下)), 可见和字符串);
		全局.PioneerLandingPosition = 无;
		创建HUD文本(所有玩家(所有队伍), 自定义字符串("模式名称：仓鼠跑酷\r\n代码：GYZFZ\r\n记得在近期游玩里收藏\r\n会不定期更新，保存代码，不要保存预设\r\n更换地图游玩不同关卡\r\n更多跑酷点位和教学前往熔火工坊查看"), 无, 无, 左边, 0, 颜色(亮紫色),
			颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串(" "), 左边, 1, 颜色(白色), 颜色(白色), 颜色(橙色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串(" "), 右边, 1, 颜色(白色), 颜色(白色), 颜色(橙色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), !按钮被按下(当前数组元素, 按钮(互动))), 自定义字符串("按下互动键({0})查看快捷键说明​以及操作说明", 输入绑定字符串(按钮(互动))), 无, 无, 左边, 2, 颜色(黄色), 颜色(
			白色), 颜色(黄色), 可见和字符串, 默认可见度);
		根据条件跳过(!全局.PioneerModeEnabled, 8);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), !实体存在(全局.Pioneer) && 数量(全局.CheckpointPosition) == 0 && 在地面上(当前数组元素)), 自定义字符串("互动{0}+装填{1} 在当前位置开拓​",
			输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(装填))), 无, 无, 左边, 1, 颜色(橙色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.GameComplete && !实体存在(全局.Pioneer) && 数量(全局.CheckpointPosition) != 0), 自定义字符串(
			"互动{0}+装填{1} 成为开拓者,继续开拓​", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(装填))), 无, 无, 左边, 2, 颜色(橙色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.GameComplete && 实体存在(全局.Pioneer)), 自定义字符串("当前开拓者: {0}", 全局.Pioneer), 无, 无, 左边, 0, 颜色(橙色), 颜色(白色),
			颜色(白色), 可见和字符串, 始终不可见);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("已开拓关卡数:{0}", 数量(全局.CheckpointPosition) - 1), 右边, 0, 颜色(白色), 颜色(白色), 颜色(橙色), 可见和字符串, 默认可见度);
		创建HUD文本(添加至数组(添加至数组(空数组, 全局.Pioneer), 无)[1 * !(全局.PioneerLandingPosition != 无)], 自定义字符串("已开拓 长按互动确认,短按互动重新开拓​"), 无, 无, 顶部, 1, 颜色(
			橙色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		创建效果(已过滤的数组(全局.Pioneer, 全局.PioneerLandingPosition != 假), 环, 颜色(黄色), 全局.PioneerLandingPosition, 全局.RingRadius[0], 可见，位置和半径);
		创建效果(已过滤的数组(全局.Pioneer, 全局.PioneerLandingPosition != 假), 光柱, 颜色(黄色), 全局.PioneerLandingPosition, 全局.RingRadius[0], 可见，位置和半径);
		创建效果(已过滤的数组(全局.Pioneer, 全局.Pioneer.UltimateUsed != (假 || 0)), 环, 颜色(亮紫色), 全局.Pioneer.UltimateUsed, 全局.RingRadius[2], 可见，位置和半径);
		创建效果(已过滤的数组(全局.Pioneer, 全局.Pioneer.UltimateUsed != (假 || 0)), 光柱, 颜色(亮紫色), 全局.Pioneer.UltimateUsed, 全局.RingRadius[2], 可见，位置和半径);
		根据条件跳过(全局.PioneerModeEnabled == 真, 2);
		全局.BestScore[0] = 自定义字符串("无");
		全局.BestScore[1] = 0;
		创建HUD文本(所有玩家(所有队伍), 自定义字符串("最好成绩: {0}/{1}S", 全局.BestScore[0], 全局.BestScore[1]), 无, 无, 左边, 0, 颜色(绿色), 颜色(白色), 颜色(白色), 可见和字符串,
			默认可见度);
	}
}

规则("玩家初始化")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		事件玩家.Level = 0;
		传送(事件玩家, 全局.CheckpointPosition[事件玩家.Level]);
		禁用 调用子程序(ResetBall);
		事件玩家.InteractPressState = 0;
		事件玩家.IsReady = 真;
		事件玩家.FreeMode = 假;
		事件玩家.Invisible = 真;
		事件玩家.IsSpectating = 假;
		禁用 设置不可见(事件玩家, 全部);
		对所有玩家启用死亡回放(事件玩家);
		启用死亡回放时目标的HUD(事件玩家);
		创建地图文本(所有玩家(所有队伍), 事件玩家, 事件玩家, 1, 不要截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
		创建效果(已过滤的数组(事件玩家, 数量(全局.CheckpointPosition) != 0), 环, 颜色(绿色), 全局.CheckpointPosition[事件玩家.Level], 全局.RingRadius[1], 可见，位置和半径);
		禁用 创建效果(已过滤的数组(事件玩家, !事件玩家.GameComplete), 环, 颜色(黄色), 全局.CheckpointPosition[事件玩家.Level + 1], 全局.RingRadius, 可见，位置和半径);
		禁用 创建地图文本(已过滤的数组(事件玩家, !事件玩家.GameComplete), 自定义字符串("在这里起飞"), 全局.UltimateState[事件玩家.Level + 1], 2, 不要截取, 可见，位置和字符串, 颜色(白色), 始终不可见);
		禁用 创建效果(已过滤的数组(事件玩家, !事件玩家.GameComplete), 环, 颜色(亮紫色), 全局.UltimateState[事件玩家.Level + 1], 全局.RingRadius, 可见，位置和半径);
		禁用 创建效果(已过滤的数组(事件玩家, !事件玩家.GameComplete), 光柱, 颜色(黄色), 全局.CheckpointPosition[事件玩家.Level + 1], 全局.RingRadius, 可见，位置和半径);
		禁用 创建效果(已过滤的数组(事件玩家, !事件玩家.GameComplete), 光柱, 颜色(亮紫色), 全局.UltimateState[事件玩家.Level + 1], 全局.RingRadius, 可见，位置和半径);
		禁用 创建地图文本(已过滤的数组(事件玩家, !事件玩家.GameComplete), 自定义字符串("到这里来"), 全局.CheckpointPosition[事件玩家.Level + 1], 2, 不要截取, 可见，位置和字符串, 颜色(白色), 始终不可见);
		创建图标(已过滤的数组(事件玩家, !事件玩家.GameComplete), 全局.CheckpointPosition[事件玩家.Level + 1], 旗帜, 可见和位置, 颜色(黄色), 真);
		创建HUD文本(已过滤的数组(事件玩家, !事件玩家.GameComplete), 自定义字符串("第​{0}关 作者: {1}", 事件玩家.Level + 1, 全局.Creator[事件玩家.Level]), 无, 无, 左边, 0, 颜色(橙色),
			颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		根据条件跳过(!全局.PioneerModeEnabled, 2);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("{0}:{1}", 事件玩家, 事件玩家.Level), 右边, 1000 - 事件玩家.Level, 颜色(白色), 颜色(白色), 颜色(橙色), 可见性，排序规则和字符串, 默认可见度);
		跳过(3);
		创建HUD文本(已过滤的数组(事件玩家, !事件玩家.GameComplete), 无, 无, 自定义字符串("检查点: {0} / {1}", 事件玩家.Level + 1, 数量(全局.CheckpointPosition) - 1), 顶部, -1,
			颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 事件玩家.BestScore != 0), 无, 无, 自定义字符串("{0}：{2}S/第{1}关", 事件玩家, 事件玩家.Level, 事件玩家.ScoreOfThisRound), 右边,
			事件玩家.BestScore, 颜色(白色), 颜色(白色), 颜色(橙色), 可见性，排序规则和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(事件玩家, 事件玩家.ScoreOfThisRound != 0), 无, 无, 事件玩家.ScoreOfThisRound, 顶部, 1, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		禁用 创建HUD文本(所有玩家(所有队伍), 全局.Pioneer.UltimateUsed, 全局.Pioneer._unused_var_16, 全局.Pioneer._unused_var_24, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		禁用 创建HUD文本(事件玩家, 相距距离(全局.CheckpointPosition[事件玩家.Level], 所选位置(事件玩家)), 无, 无, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建效果(已过滤的数组(事件玩家, !事件玩家.GameComplete), 环, 自定义颜色(全局.RGB[0], 全局.RGB[1], 全局.RGB[2], 全局.RGB[3]), 全局.CheckpointPosition[事件玩家.Level + 1],
			全局.RingRadius[0], 可见，位置和半径);
		事件玩家.BestScore[0] = 最后创建的实体;
		创建效果(已过滤的数组(事件玩家, !事件玩家.GameComplete), 光柱, 自定义颜色(全局.RGB[0], 全局.RGB[1], 全局.RGB[2], 全局.RGB[3]),
			全局.CheckpointPosition[事件玩家.Level + 1], 全局.RingRadius[0], 可见，位置和半径);
		事件玩家.BestScore[1] = 最后创建的实体;
		创建地图文本(已过滤的数组(事件玩家, !事件玩家.GameComplete), 自定义字符串("快到碗里来"), 全局.CheckpointPosition[事件玩家.Level + 1], 2, 不要截取, 可见，位置和字符串, 颜色(白色),
			始终不可见);
		事件玩家.BestScore[2] = 上一个文本ID;
		创建效果(已过滤的数组(事件玩家, 全局.UltimateState[事件玩家.Level + 1] != 假), 环, 自定义颜色(全局.RGB[4], 全局.RGB[5], 全局.RGB[6], 全局.RGB[7]),
			全局.UltimateState[事件玩家.Level + 1], 全局.RingRadius[2], 可见，位置和半径);
		事件玩家.BestScore[3] = 最后创建的实体;
		创建效果(已过滤的数组(事件玩家, 全局.UltimateState[事件玩家.Level + 1] != 假), 光柱, 自定义颜色(全局.RGB[4], 全局.RGB[5], 全局.RGB[6], 全局.RGB[7]),
			全局.UltimateState[事件玩家.Level + 1], 全局.RingRadius[2], 可见，位置和半径);
		事件玩家.BestScore[4] = 最后创建的实体;
		创建地图文本(已过滤的数组(事件玩家, 全局.UltimateState[事件玩家.Level + 1] != 假), 自定义字符串("在这里起飞"), 全局.UltimateState[事件玩家.Level + 1], 2, 不要截取, 可见，位置和字符串,
			颜色(白色), 始终不可见);
		事件玩家.BestScore[5] = 上一个文本ID;
		小字体信息(事件玩家, 自定义字符串("按下互动有惊喜哦"));
		创建HUD文本(所有玩家(所有队伍), 自定义字符串(""), 无, 无, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		调用子程序(ResetBall);
		禁用 小字体信息(事件玩家, 自定义字符串("玩家初始化"));
	}
}

规则("删除关卡后修复玩家关卡数")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.Level >= 数量(全局.CheckpointPosition);
	}

	动作
	{
		事件玩家.Level = 数量(全局.CheckpointPosition) - 1;
		事件玩家.Level = 较大(事件玩家.Level, 0);
	}
}

规则("是否完成所有关卡 假")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.Level < 数量(全局.CheckpointPosition) - 1;
	}

	动作
	{
		传送(事件玩家, 全局.CheckpointPosition[事件玩家.Level]);
		根据条件跳过(事件玩家.GameComplete == 假, 1);
		事件玩家.BestScore[6] = 0;
		等待(0.100, 当为“假”时中止);
		事件玩家.GameComplete = 假;
		调用子程序(Reset);
	}
}

规则("是否完成所有关卡 真")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(数量(全局.CheckpointPosition) == 0 || 事件玩家.Level >= 数量(全局.CheckpointPosition) - 1) == 真;
	}

	动作
	{
		事件玩家.GameComplete = 真;
		调用子程序(SetAbility);
		根据条件跳过(全局.PioneerModeEnabled, 10);
		根据条件跳过(!(事件玩家.ScoreOfThisRound != 0), 8);
		事件玩家.LastScore = 事件玩家.ScoreOfThisRound;
		小字体信息(所有玩家(所有队伍), 自定义字符串("{0}耗时​{1}完成比赛!", 事件玩家, 事件玩家.LastScore));
		根据条件跳过(事件玩家._unused_var_21 != 0, 5);
		事件玩家.BestScore = 事件玩家.ScoreOfThisRound;
		根据条件跳过(全局.BestScore[1] == 0, 1);
		根据条件跳过(事件玩家.BestScore >= 全局.BestScore[1], 2);
		全局.BestScore[0] = 自定义字符串("{0}", 事件玩家);
		全局.BestScore[1] = 事件玩家.LastScore;
		停止追踪玩家变量(事件玩家, ScoreOfThisRound);
		禁用 事件玩家.ScoreOfThisRound = 0;
		跳过(3);
		根据条件跳过(!(!实体存在(全局.Pioneer) && 数量(全局.CheckpointPosition) != 0 && 事件玩家 != 最后(全局.Creator)), 2);
		全局.PioneerStarted = 假;
		禁用 全局.Pioneer = 事件玩家;
	}
}

规则("当玩家成为开拓者")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
	}

	动作
	{
		根据条件跳过(!(数量(全局.CheckpointPosition) < 1000), 4);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 100);
		事件玩家.FreeMode = 假;
		调用子程序(Reset);
		跳过(3);
		小字体信息(事件玩家, 自定义字符串("不能再继续开拓了​"));
		全局.PioneerStarted = 假;
		全局.Pioneer = 无;
		If(全局.UltimateState[事件玩家.Level + 1] != 假);
			施加推力(事件玩家, 速率(事件玩家) * -1, 0.010, 至地图, 取消相反运动);
			大字体信息(事件玩家, 自定义字符串("不要乱跑"));
			传送(事件玩家, 全局.CheckpointPosition[事件玩家.Level]);
		End;
		事件玩家._unused_var_17 = 自定义字符串("已关闭");
		根据条件中止(事件玩家 != 全局.Pioneer);
		If(事件玩家._unused_var_17 == 自定义字符串("已开启"));
			事件玩家._unused_var_16 = 真;
			小字体信息(事件玩家, 自定义字符串("切换到超级跳开拓模式"));
		Else;
			事件玩家._unused_var_16 = 假;
			小字体信息(事件玩家, 自定义字符串("切换到正常开拓模式"));
		End;
		事件玩家.UltimateUsed = 假;
	}
}

规则("记录玩家辅助攻击使用情况")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.SecondaryFireUsed == 假;
		正在使用辅助武器(事件玩家) == 真;
	}

	动作
	{
		事件玩家.SecondaryFireUsed = 真;
	}
}

规则("终极技能模拟CD(开始CD)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DefaultUltimateEnabled == 真;
		正在使用终极技能(事件玩家) == 假;
	}

	动作
	{
		根据条件跳过(!(终极技能充能百分比(事件玩家) <= 1), 1);
		事件玩家.UltimateCharge = 0;
	}
}

规则("一次性辅助攻击模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.OneTimeAbility == 真;
		事件玩家.FreeMode == 假;
		(!事件玩家.GameComplete || 事件玩家 == 全局.Pioneer) == 真;
		事件玩家.SecondaryFireUsed == 真;
		正在使用辅助武器(事件玩家) == 假;
	}

	动作
	{
		等待(0.500, 当为“假”时中止);
		根据条件跳过(!(相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius || !在地面上(事件玩家)), 2);
		根据条件跳过(!(事件玩家 != 全局.Pioneer || 全局.PioneerLandingPosition == 无), 1);
		设置辅助攻击模式启用(事件玩家, 假);
	}
}

规则("一次性技能2")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.OneTimeAbility == 真;
		事件玩家.FreeMode == 假;
		(!事件玩家.GameComplete || 事件玩家 == 全局.Pioneer) == 真;
		事件玩家.Ability2Used == 真;
		正在使用技能 2(事件玩家) == 假;
	}

	动作
	{
		等待(0.500, 当为“假”时中止);
		根据条件跳过(!(相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius || !在地面上(事件玩家)), 2);
		根据条件跳过(!(事件玩家 != 全局.Pioneer || 全局.PioneerLandingPosition == 无), 1);
		设置启用技能 2(事件玩家, 假);
	}
}

规则("终极技能模拟CD")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DefaultUltimateEnabled == 真;
		终极技能充能百分比(事件玩家) != 100;
		正在使用终极技能(事件玩家) == 假;
	}

	动作
	{
		等待(0.160, 当为“假”时中止);
		事件玩家.UltimateCharge += 16 / 全局.UltimateCD;
		设置终极技能充能(事件玩家, 事件玩家.UltimateCharge);
		如条件为”真“则循环;
	}
}

规则("在地面上时 重置一次性技能")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.IsReady == 真;
		在地面上(事件玩家) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) <= 全局.RingRadius;
	}

	动作
	{
		禁用 等待(0.032, 当为“假”时中止);
		调用子程序(SetAbility);
	}
}

规则("在地面上时 重置技能CD")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.IsReady == 真;
		在地面上(事件玩家) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) <= 全局.RingRadius;
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) + 技能冷却时间(事件玩家, 按钮(技能1)) + 技能冷却时间(事件玩家, 按钮(技能2)) != 0;
	}

	动作
	{
		等待(0.032, 当为“假”时中止);
		设置技能冷却(事件玩家, 按钮(辅助攻击模式), 0);
		设置技能冷却(事件玩家, 按钮(技能1), 0);
		设置技能冷却(事件玩家, 按钮(技能2), 0);
	}
}

规则("禁用重生室")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		在重生室中(事件玩家) == 真;
		数量(全局.CheckpointPosition) != 0;
		(事件玩家 == 全局.Pioneer || !事件玩家.GameComplete) == 真;
	}

	动作
	{
		调用子程序(Reset);
	}
}

规则("闯关者到达下一关")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.IsReady == 真;
		事件玩家.FreeMode == 假;
		全局.Pioneer != 事件玩家;
		事件玩家.GameComplete == 假;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level + 1]) <= 全局.RingRadius;
		(!全局.JudgeWhenLanding || 在地面上(事件玩家)) == 真;
		事件玩家._unused_var_16 == 假;
	}

	动作
	{
		播放效果(事件玩家, 状态爆炸声音, 颜色(白色), 事件玩家, 100);
		事件玩家.Level += 1;
		根据条件跳过(!(事件玩家.Level < 数量(全局.CheckpointPosition)), 1);
		调用子程序(Reset);
	}
}

规则("闯关者圈外触地")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.Pioneer != 事件玩家;
		事件玩家.FreeMode == 假;
		事件玩家.GameComplete == 假;
		在地面上(事件玩家) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		禁用 事件玩家._unused_var_16 == 假;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level + 1]) > 全局.RingRadius[0];
	}

	动作
	{
		If(事件玩家._unused_var_16 == 假);
			等待(0.016, 当为“假”时中止);
			调用子程序(Reset);
			禁用 Else;
			禁用 等待(1, 无视条件);
			禁用 根据条件跳过(事件玩家._unused_var_16 == 假 || 相距距离(全局.CheckpointPosition[事件玩家.Level], 事件玩家) <= 全局.RingRadius || 水平速度(事件玩家) <= 12, 1);
			禁用 调用子程序(Reset);
		End;
	}
}

规则("开拓者圈外触地")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
		事件玩家.FreeMode == 假;
		全局.PioneerLandingPosition == 无;
		全局.PioneerStarted == 真;
		在地面上(事件玩家) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
	}

	动作
	{
		If(事件玩家._unused_var_16 == 假);
			根据条件跳过(!(相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) < 全局.RingRadius[1] * 2), 7);
			开始规则(MessageCall, 无动作);
			调用子程序(Reset);
			根据条件跳过(事件玩家.UltimateUsed == (假 || 0), 3);
			根据条件跳过(相距距离(事件玩家.UltimateUsed, 所选位置(事件玩家)) < 2 * 全局.RingRadius[2], 2);
			开始规则(MessageCall, 无动作);
			调用子程序(Reset);
			跳过(7);
			根据条件跳过(在重生室中(事件玩家), 6);
			播放效果(事件玩家, 状态爆炸声音, 颜色(白色), 事件玩家, 100);
			全局.PioneerLandingPosition = 所选位置(事件玩家);
			禁用 设置启用技能 1(事件玩家, 事件玩家.Ability1Used);
			设置启用技能 2(事件玩家, 事件玩家.Ability2Used);
			设置辅助攻击模式启用(事件玩家, 事件玩家.SecondaryFireUsed);
			设置启用终极技能(事件玩家, 事件玩家.UltimateUsed);
			禁用 创建效果(全局.Pioneer, 环, 颜色(黄色), 全局.PioneerLandingPosition, 全局.RingRadius, 可见，位置和半径);
			禁用 事件玩家.BestScore[0] = 最后创建的实体;
			禁用 创建效果(全局.Pioneer, 光柱, 颜色(黄色), 全局.PioneerLandingPosition, 全局.RingRadius, 可见，位置和半径);
			禁用 事件玩家.BestScore[1] = 最后创建的实体;
			禁用 根据条件跳过(事件玩家.UltimateUsed == (假 || 0), 4);
			禁用 创建效果(全局.CheckpointPosition, 环, 颜色(亮紫色), 全局.Pioneer.UltimateUsed, 全局.RingRadius, 可见，位置和半径);
			禁用 事件玩家.BestScore[3] = 最后创建的实体;
			禁用 创建效果(全局.Pioneer, 光柱, 颜色(亮紫色), 全局.Pioneer.UltimateUsed, 全局.RingRadius, 可见，位置和半径);
			禁用 事件玩家.BestScore[4] = 最后创建的实体;
		Else;
	}
}

规则("开拓者离开比赛")
{
	事件
	{
		玩家离开比赛;
		双方;
		全部;
	}

	条件
	{
		全局.PioneerModeEnabled == 真;
		事件玩家 == 全局.Pioneer;
	}

	动作
	{
		全局.PioneerStarted = 假;
		全局.PioneerLandingPosition = 无;
		全局.Pioneer = 数组随机取值(已过滤的数组(所有玩家(所有队伍), 当前数组元素.GameComplete && 当前数组元素 != 事件玩家 && 当前数组元素 != 最后(全局.Creator)));
	}
}

规则("[子程序] 设置技能")
{
	事件
	{
		子程序;
		SetAbility;
	}

	动作
	{
		事件玩家.Ability1Used = 假;
		事件玩家.Ability2Used = 假;
		事件玩家.SecondaryFireUsed = 假;
		If(事件玩家.GameComplete || 事件玩家.FreeMode);
			If(全局.Pioneer != 事件玩家);
				可用按钮(事件玩家, 按钮(技能1));
			End;
			设置启用技能 1(事件玩家, 全局.DefaultAliblty1Enabled && 全局.Pioneer != 事件玩家);
			设置启用技能 2(事件玩家, 全局.DefaultAliblty2Enabled);
			设置辅助攻击模式启用(事件玩家, 全局.DefaultSecondaryEnabled);
			设置启用终极技能(事件玩家, 全局.DefaultUltimateEnabled);
			可用按钮(事件玩家, 按钮(主要攻击模式));
		Else;
			设置启用技能 1(事件玩家, 全局.Ability1State[事件玩家.Level]);
			设置启用技能 2(事件玩家, 全局.Ability2State[事件玩家.Level]);
			设置辅助攻击模式启用(事件玩家, 全局.SecondaryFireState[事件玩家.Level]);
			设置终极技能充能(事件玩家, 100);
			禁用 事件玩家._unused_var_19 = 假;
			禁用按钮(事件玩家, 按钮(主要攻击模式));
		End;
	}
}

规则("消散")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		具有状态(事件玩家, 消散) == 假;
	}

	动作
	{
		等待(0.250, 无视条件);
		清除状态(事件玩家, 消散);
		设置状态(事件玩家, 无, 消散, 9999);
	}
}

规则("房间存活倒计时")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		比赛时间 == 0;
		全局.RoomAliveHoursLeft != 0;
	}

	动作
	{
		等待(1, 无视条件);
		全局.RoomAliveHoursLeft -= 1;
		设置比赛时间(3600);
	}
}

规则("定时更新目标点描述")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		根据条件跳过(!(全局.RoomAliveHoursLeft == 0 && 比赛时间 == 0), 2);
		设置目标点描述(所有玩家(所有队伍), 自定义字符串("房间即将重启​"), 可见和字符串);
		跳过(1);
		设置目标点描述(所有玩家(所有队伍), 自定义字符串("本局游戏时间还剩：​{0}小时​{1}分钟​", 全局.RoomAliveHoursLeft, 取整(比赛时间 / 60, 下)), 可见和字符串);
		等待(1, 无视条件);
		禁用 If(全局._unused_var_24[2] == 真);
		禁用 全局._unused_var_24 = 空数组;
		禁用 End;
		根据条件跳过(全局.CheatRecord == 假, 4);
		根据条件跳过(数量(全局._unused_var_24) < 1, 3);
		大字体信息(所有玩家(所有队伍), 全局._unused_var_24[0]);
		等待(1, 无视条件);
		修改全局变量(_unused_var_24, 根据索引从数组中移除, 0);
		循环;
	}
}

规则("[子程序 ] 重置当前关卡")
{
	事件
	{
		子程序;
		Reset;
	}

	动作
	{
		禁用 小字体信息(事件玩家, 自定义字符串("reset"));
		While(全局.JumpState[事件玩家.Level] == 自定义字符串("跳跃点"));
			事件玩家.Level += 1;
		End;
		根据条件跳过(全局.Pioneer == 事件玩家, 1);
		事件玩家._unused_var_17 = 空数组;
		事件玩家._unused_var_18 = 空数组;
		调用子程序(ResetBall);
		设置状态(事件玩家, 无, 定身, 0.250);
		事件玩家.UltimateUsed = 假;
		事件玩家.IsReady = 假;
		根据条件跳过(!(水平速度(事件玩家) >= 6.900), 4);
		设置辅助攻击模式启用(事件玩家, 假);
		设置启用技能 1(事件玩家, 假);
		设置启用技能 2(事件玩家, 假);
		设置启用终极技能(事件玩家, 假);
		根据条件跳过(!(事件玩家 == 全局.Pioneer), 2);
		全局.PioneerStarted = 假;
		全局.PioneerLandingPosition = 无;
		根据条件跳过(!(!全局.PioneerModeEnabled && 事件玩家.Level == 0), 2);
		停止追踪玩家变量(事件玩家, ScoreOfThisRound);
		事件玩家.ScoreOfThisRound = 0;
		施加推力(事件玩家, 方向(眼睛位置(事件玩家) + 眼睛位置(事件玩家) * 面朝方向(事件玩家), 所选位置(事件玩家)), 1, 至地图, 取消相反运动);
		等待(0.032, 无视条件);
		If((全局.TeleportWhenEnterNextPosition || 相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius) && 数量(
			全局.CheckpointPosition) != 0);
			传送(事件玩家, 全局.CheckpointPosition[事件玩家.Level]);
		End;
		事件玩家.IsReady = 真;
		根据条件跳过(!(事件玩家 == 全局.Pioneer), 1);
		全局.PioneerStarted = 真;
		设置技能冷却(事件玩家, 按钮(辅助攻击模式), 0);
		设置技能冷却(事件玩家, 按钮(技能1), 0);
		设置技能冷却(事件玩家, 按钮(技能2), 0);
		施加推力(事件玩家, 速率(事件玩家) * -1, 0.010, 至地图, 取消相反运动);
		If(全局.UltimateState[事件玩家.Level + 1] != (假 || 0));
			事件玩家._unused_var_18[0] = 全局.CheckpointPosition[事件玩家.Level];
			事件玩家._unused_var_18[1] = 全局.UltimateState[事件玩家.Level + 1];
			事件玩家._unused_var_18[2] = 事件玩家._unused_var_18[0] + 方向(事件玩家._unused_var_18[0], 事件玩家._unused_var_18[1]) * 1000;
			事件玩家._unused_var_18[3] = 与此方向的水平角度(方向(事件玩家._unused_var_18[2], 事件玩家._unused_var_18[0]));
			事件玩家._unused_var_16 = 真;
		Else;
			事件玩家._unused_var_16 = 假;
			事件玩家._unused_var_18 = 空数组;
		End;
		If(事件玩家._unused_var_17 == 自定义字符串("已开启"));
			事件玩家._unused_var_16 = 真;
		End;
		根据条件跳过(事件玩家.Level >= 事件玩家._unused_var_21, 1);
		事件玩家._unused_var_21 = 0;
	}
}

规则("阵亡复位")
{
	事件
	{
		玩家阵亡;
		双方;
		全部;
	}

	条件
	{
		被攻击方.IsSpectating == 假;
	}

	动作
	{
		被攻击方.IsReady = 假;
		If(全局.Pioneer == 事件玩家 && 全局.PioneerLandingPosition == 无);
			全局.PioneerStarted = 假;
		End;
		If(!全局.PioneerModeEnabled && 事件玩家.Level == 0);
			停止追踪玩家变量(被攻击方, ScoreOfThisRound);
			被攻击方.ScoreOfThisRound = 0;
		End;
		被攻击方.FacingDirection = 面朝方向(被攻击方);
		清除状态(被攻击方, 消散);
		设置状态(被攻击方, 无, 消散, 16200);
		等待(0.032, 无视条件);
		If(全局.Pioneer == 事件玩家);
			禁用 根据条件跳过(!(被攻击方 == 全局.Pioneer), 7);
			If(全局.PioneerLandingPosition != 无);
				传送(被攻击方, 全局.PioneerLandingPosition);
			Else;
				传送(被攻击方, 全局.CheckpointPosition[被攻击方.Level]);
			End;
			等待(0.016, 无视条件);
			复生(被攻击方);
		Else;
			If(事件玩家.FreeMode || 事件玩家.GameComplete);
				禁用 小字体信息(事件玩家, 自定义字符串("传送到可行走位置"));
				传送(被攻击方, 最近的可行走位置(所选位置(被攻击方)));
				复活(被攻击方);
			Else If(数量(全局.CheckpointPosition) != 0);
				禁用 小字体信息(事件玩家, 自定义字符串("传送到闯关点"));
				传送(被攻击方, 全局.CheckpointPosition[被攻击方.Level]);
				等待(0.016, 无视条件);
				复生(被攻击方);
			End;
		End;
		等待(0.500, 无视条件);
		设置朝向(被攻击方, 被攻击方.FacingDirection, 至地图);
		禁用 调用子程序(ResetBall);
		被攻击方.IsReady = 真;
		禁用 根据条件跳过(!(被攻击方 == 全局.Pioneer && 全局.PioneerLandingPosition == 无), 1);
		If(全局.Pioneer == 事件玩家 && 全局.PioneerLandingPosition == 无);
			全局.PioneerStarted = 真;
		End;
		调用子程序(ResetBall);
		禁用 If(!(事件玩家.FreeMode || 事件玩家.GameComplete));
		禁用 End;
		禁用 小字体信息(事件玩家, 自定义字符串("重生结束"));
	}
}

规则("[子程序] 对开拓者的提醒")
{
	事件
	{
		子程序;
		MessageCall;
	}

	动作
	{
		大字体信息(事件玩家, 自定义字符串("点位间距必须大于​{0}米​", 2 * 全局.RingRadius));
		等待(3, 无视条件);
	}
}

规则("设置互动键按下状态")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		按钮被按下(全局.Pioneer, 按钮(互动)) == 真;
		全局.PioneerLandingPosition != 无;
	}

	动作
	{
		全局.Pioneer.InteractPressState = 1;
		等待(1, 当为“假”时中止);
		全局.Pioneer.InteractPressState = 2;
	}
}

规则("松开1帧后清除按下状态")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		按钮被按下(全局.Pioneer, 按钮(互动)) == 假;
	}

	动作
	{
		等待(0.016, 无视条件);
		全局.Pioneer.InteractPressState = 0;
	}
}

规则("[热键] 开拓者确认开拓")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
		全局.PioneerLandingPosition != 无;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		事件玩家.InteractPressState == 2;
	}

	动作
	{
		If(事件玩家.UltimateUsed != (0 || 假) || 事件玩家._unused_var_17 == 自定义字符串("已关闭"));
			全局.JumpState[事件玩家.Level] = 事件玩家.pioneer_mode == 自定义字符串("传送点");
			事件玩家.InteractPressState = 0;
			全局.CheckpointPosition[事件玩家.Level + 1] = 全局.PioneerLandingPosition;
			禁用 修改全局变量(Ability1State, 添加至数组, 事件玩家.Ability1Used);
			禁用 修改全局变量(Ability2State, 添加至数组, 事件玩家.Ability2Used);
			全局.SecondaryFireState[事件玩家.Level] = 事件玩家.SecondaryFireUsed;
			全局.UltimateState[事件玩家.Level + 1] = 事件玩家.UltimateUsed;
			修改全局变量(Creator, 添加至数组, 自定义字符串("{0}", 事件玩家));
			全局.PioneerStarted = 假;
			全局.PioneerLandingPosition = 无;
			全局.Pioneer = 无;
			小字体信息(所有玩家(所有队伍), 自定义字符串("开拓者已开拓​"));
			事件玩家.Level += 1;
			调用子程序(SetAbility);
		Else;
			事件玩家.InteractPressState = 0;
			全局.PioneerLandingPosition = 无;
			调用子程序(Reset);
			If(事件玩家._unused_var_17 == 自定义字符串("已开启"));
				事件玩家._unused_var_16 = 真;
			Else;
				事件玩家._unused_var_16 = 假;
			End;
			事件玩家.UltimateUsed = 假;
			小字体信息(事件玩家, 自定义字符串("坐标错误"));
		End;
	}
}

规则("[热键] 开拓者取消开拓")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
		全局.PioneerLandingPosition != 无;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		事件玩家.InteractPressState == 1;
	}

	动作
	{
		设置辅助攻击模式启用(事件玩家, 真);
		可用按钮(事件玩家, 按钮(辅助攻击模式));
		事件玩家.InteractPressState = 0;
		全局.PioneerLandingPosition = 无;
		调用子程序(Reset);
		If(事件玩家.pioneer_mode == 自定义字符串("超级跳"));
			事件玩家._unused_var_16 = 真;
			事件玩家.UltimateUsed = 假;
			小字体信息(事件玩家, 自定义字符串("切换到超级跳开拓模式"));
		Else If(事件玩家.pioneer_mode == 自定义字符串("正常模式"));
			事件玩家._unused_var_16 = 假;
			事件玩家.UltimateUsed = 假;
			小字体信息(事件玩家, 自定义字符串("切换到正常开拓模式"));
		Else If(事件玩家.pioneer_mode == 自定义字符串("传送点"));
			事件玩家._unused_var_16 = 假;
			事件玩家.UltimateUsed = 假;
			小字体信息(事件玩家, 自定义字符串("切换到传送点模式"));
		End;
	}
}

规则("[热键] 删除最后一关")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.PioneerModeEnabled == 真;
		按钮被按下(主机玩家, 按钮(跳跃)) == 真;
		按钮被按下(主机玩家, 按钮(蹲下)) == 真;
	}

	动作
	{
		根据条件跳过(!(数量(全局.CheckpointPosition) != 0), 16);
		等待(0.500, 当为“假”时中止);
		小字体信息(主机玩家, 自定义字符串("继续长按将清除最后一关​"));
		等待(1.500, 当为“假”时中止);
		修改全局变量(CheckpointPosition, 根据索引从数组中移除, 数量(全局.CheckpointPosition) - 1);
		修改全局变量(Ability1State, 根据索引从数组中移除, 数量(全局.Ability1State) - 1);
		修改全局变量(Ability2State, 根据索引从数组中移除, 数量(全局.Ability2State) - 1);
		修改全局变量(SecondaryFireState, 根据索引从数组中移除, 数量(全局.SecondaryFireState) - 1);
		修改全局变量(UltimateState, 根据索引从数组中移除, 数量(全局.UltimateState) - 1);
		全局.Pioneer = 最后(全局.Creator);
		修改全局变量(Creator, 根据索引从数组中移除, 数量(全局.Creator) - 1);
		全局.PioneerStarted = 假;
		全局.PioneerLandingPosition = 无;
		根据条件跳过(!(数量(全局.CheckpointPosition) == 0), 2);
		小字体信息(所有玩家(所有队伍), 自定义字符串("起点已清除​"));
		跳过(1);
		小字体信息(所有玩家(所有队伍), 自定义字符串("最后一关已删除​"));
	}
}

规则("[热键] 重新开始游戏")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		存活(事件玩家) == 真;
	}

	动作
	{
		事件玩家.FreeMode = 假;
		根据条件跳过(!(事件玩家 == 全局.Pioneer), 3);
		全局.Pioneer = 无;
		全局.PioneerLandingPosition = 无;
		全局.PioneerStarted = 假;
		事件玩家.Level = 0;
		调用子程序(Reset);
	}
}

规则("[热键] 到上一关")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
	}

	动作
	{
		根据条件跳过(!(事件玩家.Level > 0), 1);
		事件玩家.Level -= 1;
		While(全局.JumpState[事件玩家.Level] == 自定义字符串("跳跃点"));
			事件玩家.Level -= 1;
		End;
		根据条件跳过(!(事件玩家 == 全局.Pioneer), 3);
		全局.Pioneer = 无;
		全局.PioneerLandingPosition = 无;
		全局.PioneerStarted = 假;
		调用子程序(Reset);
	}
}

规则("[热键] 成为开拓者")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.PioneerModeEnabled == 真;
		事件玩家.GameComplete == 真;
		实体存在(全局.Pioneer) == 假;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		在地面上(事件玩家) == 真;
	}

	动作
	{
		根据条件跳过(!(全局.DisableContinuousCreation && 事件玩家 == 最后(全局.Creator)), 2);
		小字体信息(事件玩家, 自定义字符串("请不要连续开拓​"));
		跳过(11);
		根据条件跳过(!(数量(全局.CheckpointPosition) == 0), 10);
		根据条件跳过(!在重生室中(事件玩家), 2);
		小字体信息(事件玩家, 自定义字符串("请离开重生室​"));
		跳过(5);
		根据条件跳过(在地面上(事件玩家), 2);
		小字体信息(事件玩家, 自定义字符串("请站在地上设置开拓起点​"));
		跳过(2);
		修改全局变量(CheckpointPosition, 添加至数组, 所选位置(事件玩家));
		修改全局变量(UltimateState, 添加至数组, 假);
		全局.Pioneer = 事件玩家;
		跳过(1);
		全局.Pioneer = 事件玩家;
		事件玩家._unused_var_16 = 假;
		事件玩家._unused_var_17 = 自定义字符串("已关闭");
		事件玩家.UltimateUsed = 假;
		事件玩家.pioneer_mode = 自定义字符串("正常模式");
		调用子程序(ResetBall);
	}
}

规则("[热键] 死亡观战")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
	}

	动作
	{
		事件玩家.IsSpectating = !事件玩家.IsSpectating;
		If(事件玩家.IsSpectating);
			关闭游戏预设复生模式(事件玩家);
			击杀(事件玩家, 无);
		Else;
			开启游戏预设复生模式(事件玩家);
			复活(事件玩家);
			调用子程序(ResetBall);
		End;
	}
}

禁用 规则("按下互动时 禁用所有按钮")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
	}

	动作
	{
		禁用 禁用按钮(事件玩家, 按钮(技能1));
		禁用 禁用按钮(事件玩家, 按钮(技能2));
		禁用 禁用按钮(事件玩家, 按钮(蹲下));
		禁用 禁用按钮(事件玩家, 按钮(跳跃));
		禁用 禁用按钮(事件玩家, 按钮(近身攻击));
		禁用 禁用按钮(事件玩家, 按钮(主要攻击模式));
		禁用 禁用按钮(事件玩家, 按钮(辅助攻击模式));
		禁用 禁用按钮(事件玩家, 按钮(终极技能));
		设置状态(事件玩家, 无, 定身, 9999);
	}
}

禁用 规则("没按下互动时 可用所有按钮")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 假;
	}

	动作
	{
		禁用 等待(0.500, 当为“假”时中止);
		禁用 可用按钮(事件玩家, 按钮(技能1));
		禁用 可用按钮(事件玩家, 按钮(技能2));
		禁用 可用按钮(事件玩家, 按钮(蹲下));
		禁用 可用按钮(事件玩家, 按钮(跳跃));
		禁用 可用按钮(事件玩家, 按钮(近身攻击));
		禁用 可用按钮(事件玩家, 按钮(主要攻击模式));
		禁用 可用按钮(事件玩家, 按钮(辅助攻击模式));
		禁用 可用按钮(事件玩家, 按钮(终极技能));
		清除状态(事件玩家, 定身);
	}
}

规则("[多行字符串] 快捷键说明")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		If(全局.PioneerModeEnabled);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(互动))), 无, 无, 自定义字符串(
				"重新开始       =  互动 + Q\r\n阵亡观战       =  互动 + E\r\n开关隐身       =  任意表情\r\n到上一关       =  互动 + 蹲\r\n自由移动       =  互动 + 近战\r\n{0}",
				自定义字符串("到下一关       =  蹲 + Q + R\r\n阵亡复位       =  长按Q\r\n切换模式       =  R + 空格")), 左边, 2, 颜色(白色), 颜色(白色), 颜色(黄色), 可见和字符串, 默认可见度);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(全局.Pioneer, 按钮(互动)) == 真), 自定义字符串(
				"超级跳开拓模式下抓钩只能在起点启用\r\n否则出圈以后会被禁用，禁止起跳前腾空\r\n出圈后在起跳前需须保持高速移动（火球）\r\n请保持起点和紫色圈形成两点一线，遇到\r\n坐标错误就是没有紫圈，重新开拓就行\r\nR+跳=切换开拓模式。当前模式：{0}",
				全局.Pioneer.pioneer_mode), 无, 无, 左边, 3, 颜色(亮紫色), 颜色(白色), 颜色(红色), 可见和字符串, 默认可见度);
		Else;
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(互动))), 无, 无, 自定义字符串(
				"重新开始       =  互动 + Q\r\n阵亡观战       =  互动 + E\r\n开关隐身       =  任意表情\r\n到上一关       =  互动 + 蹲\r\n自由移动       =  互动 + 近战\r\n{0}",
				自定义字符串("到下一关       =  蹲 + Q + R\r\n阵亡复位       =  长按Q")), 左边, 2, 颜色(白色), 颜色(白色), 颜色(黄色), 可见和字符串, 默认可见度);
		End;
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(互动))), 无, 无, 自定义字符串("仓鼠跑酷地图合集代码：G7V27 | 13GT0R | 9ZDS3 | GYZFZ"), 左边, 2, 颜色(白色), 颜色(白色), 颜色(
			白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(互动))), 自定义字符串("自由模式或开拓者传送点模式下按左键可以向前移动"), 无, 无, 顶部, 10, 颜色(红色), 颜色(白色), 颜色(黄色), 可见和字符串,
			默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(互动))), 自定义字符串(
			"超级跳:钩住一个可以让自身加速的位置，在到达紫圈前松钩并保证速度已达最大(火焰效果)，在紫色圈内瞬间起跳。\r\n原理:起跳正确的情况下高速撞击大角度斜面会获得上升动力。\r\nTIPS:紫圈圆心即为最佳起跳位，出圈钩子会被禁用，加速过程中离地会失效。"),
			无, 无, 顶部, 10, 颜色(天蓝色), 颜色(白色), 颜色(黄色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(互动))), 无, 自定义字符串("保存点位教学：b站up:Stan_sin\r\n  BV1da4y1W7uA"), 无, 左边, 4, 颜色(白色), 颜色(白色),
			颜色(白色), 可见和字符串, 默认可见度);
	}
}

规则("通关或自由模式下无CD")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 != 全局.Pioneer;
		(事件玩家.GameComplete || 事件玩家.FreeMode) == 真;
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) + 技能冷却时间(事件玩家, 按钮(技能1)) + 技能冷却时间(事件玩家, 按钮(技能2)) != 0;
	}

	动作
	{
		设置技能冷却(事件玩家, 按钮(辅助攻击模式), 0);
		设置技能冷却(事件玩家, 按钮(技能1), 0);
		设置技能冷却(事件玩家, 按钮(技能2), 0);
	}
}

规则("祝大家玩得愉快~")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		地图工坊设置开关(自定义字符串("快捷键"), 自定义字符串("跳关"), 真, 0) == 真;
	}

	动作
	{
		事件玩家.Level += 1;
		事件玩家._unused_var_21 = 事件玩家.Level;
		If(全局.CheatRecord);
			If(数量(全局._unused_var_24) == 0);
				全局._unused_var_24[0] = 自定义字符串("{0}玩家{1}采用取巧的方式过了第{2}关", 英雄图标字符串(英雄(破坏球)), 事件玩家, 事件玩家.Level);
			Else;
				修改全局变量(_unused_var_24, 添加至数组, 自定义字符串("{2}玩家{0}采用取巧的方式过了第{1}关", 事件玩家, 事件玩家.Level, 英雄图标字符串(英雄(破坏球))));
			End;
		End;
		等待(1, 当为“假”时中止);
		While(按钮被按下(事件玩家, 按钮(蹲下)) == 真 && 按钮被按下(事件玩家, 按钮(终极技能)) == 真 && 按钮被按下(事件玩家, 按钮(装填)) == 真);
			事件玩家.Level += 1;
			If(全局.CheatRecord);
				修改全局变量(_unused_var_24, 添加至数组, 自定义字符串("{2}玩家{0}采用取巧的方式过了第{1}关", 事件玩家, 事件玩家.Level, 英雄图标字符串(英雄(破坏球))));
			End;
			等待(0.100, 无视条件);
		End;
		事件玩家._unused_var_21 = 事件玩家.Level;
	}
}

规则("[热键]开拓者切换模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		地图工坊设置开关(自定义字符串("快捷键"), 自定义字符串("超级跳模式开拓"), 真, 1) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) < 全局.RingRadius[1];
	}

	动作
	{
		If(事件玩家.pioneer_mode == 自定义字符串("正常模式"));
			事件玩家.pioneer_mode = 自定义字符串("超级跳");
			事件玩家._unused_var_17 = 自定义字符串("已开启");
			事件玩家._unused_var_16 = 真;
			小字体信息(事件玩家, 自定义字符串("切换到超级跳开拓模式"));
		Else If(事件玩家.pioneer_mode == 自定义字符串("超级跳"));
			事件玩家.pioneer_mode = 自定义字符串("传送点");
			事件玩家._unused_var_17 = 自定义字符串("已关闭");
			事件玩家._unused_var_16 = 假;
			小字体信息(事件玩家, 自定义字符串("切换到传送点模式"));
			事件玩家._unused_var_18 = 空数组;
		Else If(事件玩家.pioneer_mode == 自定义字符串("传送点"));
			事件玩家.pioneer_mode = 自定义字符串("正常模式");
			小字体信息(事件玩家, 自定义字符串("切换到正常模式"));
		End;
	}
}

规则("开拓者超级跳")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家._unused_var_16 == 真;
		禁用 正在使用辅助武器(事件玩家) == 假;
		禁用 相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 6;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		垂直速度(事件玩家) != 0;
		事件玩家 == 全局.Pioneer;
		水平速度(事件玩家) > 12;
	}

	动作
	{
		If(相距距离(全局.CheckpointPosition[事件玩家.Level], 所选位置(事件玩家)) > 6);
			事件玩家._unused_var_18 = 空数组;
			设置辅助攻击模式启用(事件玩家, 假);
			事件玩家._unused_var_20 = 50;
			事件玩家.UltimateUsed = 所选位置(事件玩家);
			事件玩家._unused_var_16 = 假;
			While(Y方向分量(所选位置(事件玩家)) - Y方向分量(事件玩家.UltimateUsed) <= 3 && 事件玩家._unused_var_20 >= 1);
				等待(0.020, 无视条件);
				事件玩家._unused_var_20 -= 1;
			End;
			If(事件玩家._unused_var_20 < 1);
				施加推力(事件玩家, 速率(事件玩家) * -1, 0.010, 至地图, 取消相反运动);
				设置状态(事件玩家, 无, 冰冻, 0.500);
				传送(事件玩家, 全局.CheckpointPosition[事件玩家.Level]);
				等待(0.250, 无视条件);
				事件玩家._unused_var_16 = 真;
				事件玩家.UltimateUsed = 假;
				事件玩家.InteractPressState = 0;
				全局.PioneerLandingPosition = 无;
			End;
		Else;
			大字体信息(事件玩家, 自定义字符串("点位间距必须大于​{0}米​", 6));
		End;
	}
}

规则("防止乱跑")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		禁用 全局.Pioneer != 事件玩家;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		事件玩家._unused_var_16 == 真;
		垂直速度(事件玩家) > 0;
		相距距离(所选位置(事件玩家), 全局.UltimateState[事件玩家.Level + 1]) > 全局.RingRadius;
		事件玩家.GameComplete == 假;
		事件玩家.FreeMode == 假;
	}

	动作
	{
		等待(0.200, 当为“假”时中止);
		设置状态(事件玩家, 无, 定身, 0.500);
		调用子程序(Reset);
		禁用 大字体信息(事件玩家, 自定义字符串("不要乱跑"));
		小字体信息(事件玩家, 自定义字符串("按下互动键（{0}）有惊喜哦", 输入绑定字符串(按钮(互动))));
	}
}

规则("超级跳")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家._unused_var_16 == 真;
		正在使用辅助武器(事件玩家) == 假;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		垂直速度(事件玩家) > 5;
		禁用 事件玩家._unused_var_18[4] == 真;
		事件玩家 != 全局.Pioneer;
		相距距离(所选位置(事件玩家), 全局.UltimateState[事件玩家.Level + 1]) <= 全局.RingRadius[2];
	}

	动作
	{
		事件玩家._unused_var_16 = 假;
		禁用 设置辅助攻击模式启用(事件玩家, 假);
	}
}

规则("两点一线检测")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"宽度是最下面那个值"
		与此方向的水平角度(方向(事件玩家._unused_var_18[2], 所选位置(事件玩家))) < 事件玩家._unused_var_18[3] + 0.350;
		"宽度是最下面那个值"
		与此方向的水平角度(方向(事件玩家._unused_var_18[2], 所选位置(事件玩家))) > 事件玩家._unused_var_18[3] - 0.350;
		"这是长度"
		相距距离(事件玩家._unused_var_18[2], 所选位置(事件玩家)) <= 相距距离(事件玩家._unused_var_18[2], 事件玩家._unused_var_18[0]) + 2;
		"这是长度"
		相距距离(事件玩家._unused_var_18[2], 所选位置(事件玩家)) >= 相距距离(事件玩家._unused_var_18[2], 事件玩家._unused_var_18[1]) - 2;
		全局.UltimateState[事件玩家.Level + 1] != (假 || 0);
		事件玩家.FreeMode == 假;
	}

	动作
	{
		事件玩家._unused_var_19 = 2;
		等待(0.050, 当为“假”时中止);
		如条件为”真“则循环;
	}
}

规则("超出两点一线范围")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家._unused_var_19 > 0;
		事件玩家.FreeMode == 假;
		事件玩家 != 全局.Pioneer;
	}

	动作
	{
		事件玩家._unused_var_19 -= 1;
		等待(0.100, 无视条件);
		如条件为”真“则循环;
		If((全局.UltimateState[事件玩家.Level + 1] && 事件玩家._unused_var_16) != 假);
			设置状态(事件玩家, 无, 定身, 0.500);
			大字体信息(事件玩家, 自定义字符串("不要乱跑"));
			调用子程序(Reset);
		End;
	}
}

规则("超级跳模式圈外低速复位")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		水平速度(事件玩家) <= 12;
		正在使用辅助武器(事件玩家) == 假;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		事件玩家.FreeMode == 假;
		(全局.Pioneer != 事件玩家 ? 事件玩家.GameComplete == 假 : 真) == 真;
		在地面上(事件玩家) == 真;
		(事件玩家._unused_var_16 == 假 ? 全局.UltimateState[事件玩家.Level + 1] != (假 || 0) : 真) == 真;
	}

	动作
	{
		等待(0.016, 当为“假”时中止);
		调用子程序(Reset);
	}
}

规则("超级跳模式出圈禁用抓钩")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		事件玩家._unused_var_16 == 真;
		正在使用辅助武器(事件玩家) == 假;
		事件玩家.FreeMode == 假;
		禁用 事件玩家.GameComplete == 假;
		(全局.Pioneer != 事件玩家 ? 事件玩家.GameComplete == 假 : 真) == 真;
	}

	动作
	{
		设置辅助攻击模式启用(事件玩家, 假);
	}
}

规则("防止起步在空中")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家._unused_var_17 == 自定义字符串("已开启");
		正在空中(事件玩家) == 真;
		事件玩家 == 全局.Pioneer;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		事件玩家.FreeMode == 假;
		事件玩家.UltimateUsed == 假;
	}

	动作
	{
		等待(0.200, 无视条件);
		根据条件中止(事件玩家._unused_var_16 == 假);
		小字体信息(事件玩家, 自定义字符串("{0}你想原地起飞？", 英雄图标字符串(英雄(破坏球))));
		调用子程序(Reset);
	}
}

规则("开拓者两点一线写入")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.Pioneer == 事件玩家;
		禁用 事件玩家._unused_var_17 == 自定义字符串("已开启");
		禁用 事件玩家.FreeMode == 假;
		事件玩家._unused_var_16 == 真;
		事件玩家._unused_var_18 == 空数组;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 5;
	}

	动作
	{
		禁用 If(相距距离(全局.CheckpointPosition[事件玩家.Level], 所选位置(事件玩家)) > 3);
		事件玩家._unused_var_18[0] = 全局.CheckpointPosition[事件玩家.Level];
		事件玩家._unused_var_18[1] = 所选位置(事件玩家);
		事件玩家._unused_var_18[2] = 事件玩家._unused_var_18[0] + 方向(事件玩家._unused_var_18[0], 事件玩家._unused_var_18[1]) * 1000;
		事件玩家._unused_var_18[3] = 与此方向的水平角度(方向(事件玩家._unused_var_18[2], 事件玩家._unused_var_18[0]));
		禁用 Else;
		禁用 事件玩家._unused_var_18 = 空数组;
		禁用 End;
	}
}

规则("开拓者两点一线清除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.Pioneer == 事件玩家;
		禁用 事件玩家._unused_var_17 == 自定义字符串("已开启");
		事件玩家.FreeMode == 假;
		禁用 事件玩家._unused_var_16 == 假;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) <= 5;
	}

	动作
	{
		事件玩家._unused_var_18 = 空数组;
	}
}

规则("开拓者两点一线检测")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"宽度是最下面那个值"
		与此方向的水平角度(方向(事件玩家._unused_var_18[2], 所选位置(事件玩家))) < 事件玩家._unused_var_18[3] + 0.300;
		"宽度是最下面那个值"
		与此方向的水平角度(方向(事件玩家._unused_var_18[2], 所选位置(事件玩家))) > 事件玩家._unused_var_18[3] - 0.300;
		"这是长度"
		禁用 相距距离(事件玩家._unused_var_18[2], 所选位置(事件玩家)) <= 相距距离(事件玩家._unused_var_18[2], 事件玩家._unused_var_18[0]) + 2;
		"这是长度"
		禁用 相距距离(事件玩家._unused_var_18[2], 所选位置(事件玩家)) >= 相距距离(事件玩家._unused_var_18[2], 事件玩家._unused_var_18[1]) - 2;
		事件玩家.FreeMode == 假;
		事件玩家._unused_var_17 == 自定义字符串("已开启");
		事件玩家 == 全局.Pioneer;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 5;
	}

	动作
	{
		禁用 事件玩家._unused_var_19 = 2;
		禁用 等待(0.050, 当为“假”时中止);
		禁用 如条件为”真“则循环;
		等待(0.500, 无视条件);
		如条件为”真“则循环;
		根据条件中止(事件玩家._unused_var_18 == 空数组);
		根据条件中止(事件玩家._unused_var_16 == 假);
		播放效果(事件玩家, 负面状态施加声音, 颜色(白色), 事件玩家, 30);
		大字体信息(事件玩家, 自定义字符串("{0}球球你做个人吧", 英雄图标字符串(英雄(破坏球))));
		事件玩家._unused_var_18 = 空数组;
		调用子程序(Reset);
	}
}

规则("当玩家离开比赛")
{
	事件
	{
		玩家离开比赛;
		双方;
		全部;
	}

	动作
	{
		消除效果(事件玩家.BestScore[0]);
		消除效果(事件玩家.BestScore[1]);
		消除地图文本(事件玩家.BestScore[2]);
		消除效果(事件玩家.BestScore[3]);
		消除效果(事件玩家.BestScore[4]);
		消除地图文本(事件玩家.BestScore[5]);
	}
}

规则("【热键】位移")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		(事件玩家.FreeMode || (事件玩家.GameComplete && 全局.Pioneer != 事件玩家) || (全局.Pioneer == 事件玩家 && 事件玩家.pioneer_mode == 自定义字符串("传送点"))) == 真;
		事件玩家.IsSpectating == 假;
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		传送(事件玩家, 所选位置(事件玩家) + 面朝方向(事件玩家) * 5);
		设置引力(事件玩家, 0);
		While(按钮被按下(事件玩家, 按钮(主要攻击模式)));
			传送(事件玩家, 所选位置(事件玩家) + 面朝方向(事件玩家) * 0.500);
			施加推力(事件玩家, 速率(事件玩家) * -1, 0.010, 至地图, 取消相反运动);
			等待(0.010, 当为“真”时重新开始);
		End;
		设置引力(事件玩家, 100);
	}
}

规则("【热键】杀死玩家")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
	}

	动作
	{
		等待(0.500, 当为“假”时中止);
		击杀(事件玩家, 无);
	}
}

规则("规则 115")
{
	事件
	{
		子程序;
		ResetBall;
	}

	动作
	{
		While(!正在使用技能 1(事件玩家));
			事件玩家.IsReady = 假;
			设置启用技能 1(事件玩家, 真);
			可用按钮(事件玩家, 按钮(技能1));
			等待(0.250, 无视条件);
			按下按键(事件玩家, 按钮(技能1));
			禁用 小字体信息(事件玩家, 自定义字符串("激活动力铁球"));
			等待直到 (正在使用技能 1(事件玩家), 0.500);
			事件玩家.IsReady = 真;
		End;
		If(!(事件玩家.FreeMode || 事件玩家.GameComplete) || 事件玩家 == 全局.Pioneer);
			禁用按钮(事件玩家, 按钮(技能1));
		End;
		禁用 小字体信息(事件玩家, 自定义字符串("ResetBallEnd"));
	}
}

禁用 规则("规则 111")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串("正在使用技能1：{0}", 正在使用技能 1(事件玩家)), 无, 无, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
	}
}

规则("开关隐身")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在使用表情交流(事件玩家) == 真;
	}

	动作
	{
		事件玩家.Invisible = !事件玩家.Invisible;
		If(事件玩家.Invisible);
			设置不可见(事件玩家, 全部);
			大字体信息(事件玩家, 自定义字符串("开启隐身​"));
		Else;
			大字体信息(事件玩家, 自定义字符串("关闭隐身​"));
			设置不可见(事件玩家, 全部禁用);
		End;
	}
}

规则("跑酷模式计时开始")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.PioneerModeEnabled == 假;
		事件玩家.FreeMode == 假;
		事件玩家.Level == 0;
		事件玩家.IsReady == 真;
		相距距离(所选位置(事件玩家), 首个(全局.CheckpointPosition)) > 全局.RingRadius;
	}

	动作
	{
		停止追踪玩家变量(事件玩家, ScoreOfThisRound);
		事件玩家.ScoreOfThisRound = 0;
		追踪玩家变量频率(事件玩家, ScoreOfThisRound, 16200, 1, 全部禁用);
	}
}

规则("[热键] 开关自由模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		在地面上(事件玩家) == 真;
	}

	动作
	{
		等待(0.500, 当为“真”时重新开始);
		事件玩家.FreeMode = !事件玩家.FreeMode;
		If(事件玩家.FreeMode);
			修改全局变量(Pioneer, 根据值从数组中移除, 事件玩家);
			小字体信息(事件玩家, 自定义字符串("自由移动​"));
			调用子程序(SetAbility);
			根据条件跳过(!(事件玩家.ScoreOfThisRound != 0), 1);
			停止追踪玩家变量(事件玩家, ScoreOfThisRound);
		Else;
			小字体信息(事件玩家, 自定义字符串("关闭自由移动​"));
			调用子程序(Reset);
			If(事件玩家.ScoreOfThisRound != 0);
				追踪玩家变量频率(事件玩家, ScoreOfThisRound, 16200, 1, 全部禁用);
			End;
		End;
	}
}

规则("设置主要攻击模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		设置主要攻击模式启用(事件玩家, 假);
	}
}

规则("设置主要攻击模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 假;
		(事件玩家.FreeMode || 事件玩家.GameComplete) == 真;
	}

	动作
	{
		设置主要攻击模式启用(事件玩家, 真);
	}
}