设置
{
	主程序
	{
		描述: "仓鼠跑酷教学, 作者Exit. 代码Z4DBC. 更多跑酷点位和教学前往熔火工坊查看  其他合集代码：9ZDS3 | GYZFZ| G7V27 | 13GT0R  通关教学：b站up：Stan_sin"
		模式名称: "仓鼠跑酷教学"
	}

	大厅
	{
		比赛语音聊天: 启用
		玩家上限 队伍1: 12
		玩家上限 队伍2: 0
		观战者人数上限: 6
		返回大厅: 从不
		队列中的玩家可以加入: 是
	}

	模式
	{
		团队死斗
		{
			启用地图
			{
			}
		}

		突击模式
		{
			启用地图
			{
				监测站：直布罗陀
			}
		}

		训练靶场
		{
			启用地图
			{
			}
		}

		禁用 运载目标
		{
			运载目标速度: 10%
		}

		综合
		{
			允许切换英雄: 关闭
			复生时间: 5%
			急救包刷新: 禁用
			消灭提示: 关闭
			消灭镜头: 关闭
			游戏模式开始: 即时
			英雄限制: 关闭
			随机英雄复生: 开启
		}
	}

	英雄
	{
		综合
		{
			无需装弹: 开启
			终极技能充能速度: 10%
			终极技能自动充能速度: 0%
			重生时终极技能充能完毕: 开启

			末日铁拳
			{
				上勾重拳 冷却时间: 12%
				火箭重拳 冷却时间: 6%
				终极技能（毁天灭地）: 关闭
				裂地重拳 冷却时间: 6%
			}

			源氏
			{
				重生时终极技能充能完毕: 开启
			}

			破坏球
			{
				终极技能（地雷禁区）: 关闭
				重力坠击 冷却时间: 0%
			}

			启用英雄
			{
				破坏球
			}
		}
	}

	地图工坊
	{
		小球不透明度: 109
		小球判定大小: 2.200
		小球显示大小: 2.500
		小球红: 255
		小球绿: 105
		小球蓝: 180
		是否允许开拓: 关闭
		目标点圈不透明度: 161
		目标点圈大小: 1.800
		起飞点圈不透明度: 94
		跳关提醒: 关闭
	}
}

变量
{
	全局:
		0: CheckpointPosition
		1: Ability1State
		2: Ability2State
		3: SecondaryFireState
		4: UltimateState
		5: Creator
		6: RingRadius
		7: JudgeWhenLanding
		8: DefaultAliblty1Enabled
		9: DefaultAliblty2Enabled
		10: DefaultSecondaryEnabled
		11: DefaultUltimateEnabled
		12: UltimateCD
		13: OneTimeAbility
		14: DisableContinuousCreation
		15: PioneerModeEnabled
		16: Pioneer
		17: PioneerStarted
		18: PioneerLandingPosition
		19: PioneerSpherePosition
		20: BestScore
		22: CurrentMap
		23: TeleportWhenEnterNextPosition
		24: cheat_log
		26: RGB
		27: JumpState
		28: CheatRecord
		29: PlayersData
		30: RoomAliveHoursLeft
		31: SpherePosition
		32: SphereRadius
		33: SphereJudgeRadius
		34: Tips

	玩家:
		0: Level
		1: BestScore
		2: LastScore
		3: ScoreOfThisRound
		4: GameComplete
		5: IsReady
		6: Invisible
		7: FreeMode
		8: InteractPressState
		9: FacingDirection
		10: UltimateCharge
		11: Ability1Used
		12: Ability2Used
		13: SecondaryFireUsed
		14: UltimateUsed
		15: IsSpectating
		16: ultimate_worked
		17: ultimate_log
		18: ultimate_info
		19: ultimate_outline_countdown
		20: pioneer_outline_countdown
		21: cheat
		22: mistake
		23: dataIndex
		25: sphere_state
		26: pioneer_mode
		27: HintFreq
}

子程序
{
	0: SetAbility
	1: Reset
	3: MessageCall
	4: ResetBall
	5: EditPlayerData
	6: ValidationPlayerData
}

规则("禁用查看器")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		禁用查看器录制;
	}
}

规则("房主发感谢即可更新导出数据,随后在查看器导出全局数据")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在交流(主机玩家, 感谢) == 真;
	}

	动作
	{
		全局.CurrentMap = 当前地图;
		启用查看器录制;
		禁用查看器录制;
		小字体信息(主机玩家, 自定义字符串("点位数据已导出,请打开查看器复制"));
		小字体信息(主机玩家, 自定义字符串("别忘了选择当前地图和当前比赛模式哦！"));
	}
}

规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 花村124 m酱 柠檬")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(花村);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		创建HUD文本(所有玩家(所有队伍), 自定义字符串("通关教学: b站up:Stancossin\r\nBV1ii4y1M7dq(部分关卡有改动)"), 无, 无, 左边, 1, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		全局.CheckpointPosition = 数组(矢量(-7.970, 5, -36.646), 矢量(-17.827, -1.249, -34.834), 矢量(-23.522, -1, -46.785), 矢量(-16.423, 3.010,
			-44.076), 矢量(-10.224, 7, -27.020), 矢量(-5.472, 5, -35.787), 矢量(12.879, 7.071, -49.094), 矢量(-0.059, 4, -58.664), 矢量(15.211, 4,
			-73.960), 矢量(6.704, 7.010, -83.536), 矢量(-8.287, 2.540, -76.757), 矢量(13.113, 7.071, -48.991), 矢量(0.974, 5, -40.761), 矢量(13.647,
			6.748, -21.739), 矢量(12.188, 11.229, 18.132), 矢量(-8.885, 3.939, 21.055), 矢量(-14.029, -0.985, -23.838), 矢量(-13.728, 1, -34.073),
			矢量(-38.340, 1, -61.726), 矢量(-8.717, 5, -36.720), 矢量(-15.095, -1.175, -18.227), 矢量(-5.603, 1, -14.827), 矢量(-6.218, 7.983,
			-10.297), 矢量(29.771, 10.463, -4.001), 矢量(4.936, 7.724, -0.271), 矢量(1.896, 1, 0.963), 矢量(24.571, 6, 10.505), 矢量(17.430, 9.582,
			17.291), 矢量(5.330, 7.965, 11.858), 矢量(5.295, 3.989, 26.929), 矢量(10.419, -0.645, 27.035), 矢量(7.024, 4, 27.758), 矢量(2.948, 2.374,
			37.042), 矢量(-2.681, 3.982, 28.844), 矢量(-12.652, -0.984, -10.839), 矢量(-8.332, 1, -10.371), 矢量(-23.014, -1.243, -14.536), 矢量(
			-22.956, -1, -47.039), 矢量(-29.779, 1, -53.810), 矢量(-19.537, 3, -49.068), 矢量(-13.374, 1, -34.237), 矢量(-11.655, 0.642, -18.095),
			矢量(-13.320, 1, -34.261), 矢量(-36.209, 1, -64.290), 矢量(-18.766, -0.925, -75.163), 矢量(-3.726, 4, -64.767), 矢量(0.946, 7.010,
			-91.455), 矢量(-25.943, 1, -85.285), 矢量(9.497, 7.010, -82.154), 矢量(-8.531, 9, -64.271), 矢量(5.126, -1.607, -52.860), 矢量(0.351,
			4.088, -58.982), 矢量(13.241, 7.071, -49.116), 矢量(29.992, 2, -31.590), 矢量(12.438, 6.757, -20.841), 矢量(-3.948, 7, -20.986), 矢量(
			-13.961, 1, 26.522), 矢量(-16.520, 3.943, 22.322), 矢量(-14.176, 1, 4.222), 矢量(-15.317, 3.892, 12.866), 矢量(-3.169, 7.982, 12.512),
			矢量(6.516, 9.334, 20.821), 矢量(11.427, 4.202, 11.429), 矢量(25.791, 6.010, 10.251), 矢量(48.748, 6, 6.422), 矢量(60.938, 6, -12.800),
			矢量(28.952, 10.464, -4.147), 矢量(27.492, 2, -28.421), 矢量(-15.738, -0.406, -32.690), 矢量(-17.715, 1, -60.746), 矢量(-20.186, 4,
			-57.163), 矢量(-9.210, 5, -36.549), 矢量(5.020, 7.884, -7.887), 矢量(13.404, 6.744, -21.422), 矢量(40.462, 6, -2.899), 矢量(13.628,
			11.233, 19.394), 矢量(9.034, 6.919, -20.135), 矢量(-13.474, 1, -26.738), 矢量(-4.469, 7.090, -19.937), 矢量(25.397, 6, 10.209), 矢量(
			6.158, 4, 27.519), 矢量(12.716, 11.217, 20.770), 矢量(23.933, 6, 10.061), 矢量(13.552, 0.983, -4.316), 矢量(13.762, 6.750, -20.753),
			矢量(-0.391, 4, -59.629), 矢量(-8.845, 9, -65.598), 矢量(-2.122, 2.416, -82.034), 矢量(7.332, -1.895, -79.102), 矢量(7.717, 4, -76.548),
			矢量(-3.670, -1.903, -68.131), 矢量(-1.876, 4, -66.865), 矢量(-9.314, 9, -64.665), 矢量(-21.257, 4, -57.560), 矢量(-31.961, 1, -69.186),
			矢量(-22.199, 2.996, -66.619), 矢量(-20.988, 4, -57.246), 矢量(-9.924, 7, -27.601), 矢量(13.045, 6.737, -20.514), 矢量(47.025, 6, 8.256),
			矢量(26.100, 6, 10.437), 矢量(28.869, 10.445, -3.015), 矢量(14.358, 4, -73.837), 矢量(29.467, 1.838, -42.993), 矢量(24.394, 0.839,
			-30.361), 矢量(12.704, 6.747, -20.655), 矢量(44.129, 6, -6.246), 矢量(49.006, 6, 5.169), 矢量(33.297, 0.046, -4.333), 矢量(27.619, 2,
			-28.483), 矢量(35.114, 2, -25.698), 矢量(35.610, 3, -21.791), 矢量(26.390, 0, 7.177), 矢量(26.657, 6, 9.987), 矢量(36.443, 0.133,
			-1.137), 矢量(5.383, 7.769, -4.487));
		全局.SecondaryFireState = 数组(假, 假, 假, 真, 假, 真, 假, 真, 假, 假, 真, 假, 真, 真, 假, 真, 假, 真, 真, 真, 假, 真, 真, 真, 假, 真, 假, 假, 假, 假, 假, 假, 假, 真, 假,
			假, 真, 假, 假, 假, 真, 真, 真, 真, 真, 真, 真, 真, 真, 假, 真, 真, 真, 真, 真, 真, 假, 真, 假, 真, 假, 假, 真, 真, 真, 真, 真, 真, 真, 假, 真, 真, 真, 真, 真, 真, 真,
			真, 真, 真, 真, 假, 假, 真, 真, 假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 真, 真, 真, 真, 假, 真, 假, 假, 真, 真, 假, 假, 真, 假, 假, 假, 假, 假, 真);
		全局.UltimateState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 矢量(15.024,
			-0.911, -4.082));
		全局.JumpState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 真, 假, 假, 假);
		全局.SpherePosition = 数组(0, 矢量(-11.048, 5.598, -32.761), 0, 矢量(-19.507, -0.247, -42.163), 0, 0, 矢量(-3.085, 1.617, -33.065), 0, 矢量(
			18.559, 5.917, -69.785), 0, 矢量(-2.064, 2.678, -82.603), 0, 0, 0, 0, 矢量(0.416, 7.013, 19.112), 0, 矢量(-13.780, 2.695, -29.762),
			0, 0, 0, 0, 0, 0, 0, 0, 矢量(-5.793, 7.070, -2.611), 0, 0, 0, 0, 0, 0, 0, 0, 0, 矢量(-17.098, 1.657, -11.920), 矢量(-29.580, -1.630,
			-7.877), 0, 矢量(-22.127, 5.275, -50.465), 0, 0, 0, 矢量(-39.208, 3.390, -60.093), 矢量(-29.840, 1.075, -67.855), 0, 0, 0, 0, 0, 矢量(
			-0.903, 4.113, -60.533), 0, 0, 矢量(26.134, -0.268, -45.243), 0, 0, 矢量(-14.359, 13.862, 13.720), 0, 0, 0, 0, 0, 0, 矢量(-2.184,
			3.334, -1.169), 矢量(42.960, 13.118, 5.203), 矢量(61.950, 9.838, -14.693), 矢量(43.149, 14.333, -8.723), 矢量(19.237, 14.474, -24.546),
			矢量(-7.453, 10.411, -34.170), 矢量(-13.542, 3.231, -52.611), 0, 0, 矢量(1.527, 13.585, -10.271), 矢量(13.876, 5.424, -30.545), 0, 0,
			矢量(18.810, 14.292, -11.433), 矢量(-13.348, 12.362, -23.474), 0, 0, 0, 矢量(23.367, 8.930, 26.959), 0, 矢量(18.741, 4.176, 6.909), 0,
			矢量(4.704, 9.416, -37.319), 矢量(-2.915, 7.011, -61.600), 矢量(0.990, -0.199, -79.566), 0, 0, 矢量(0.737, 0.056, -73.709), 0, 矢量(
			-1.398, 6.799, -68.631), 0, 矢量(-27.110, 1.012, -62.866), 0, 矢量(-21.002, 1.070, -61.693), 矢量(-13.731, 9.033, -43.396), 0, 矢量(
			27.505, 10.161, 1.814), 矢量(60.896, 6.212, 9.726), 0, 0, 矢量(21.044, 6.061, -68.303), 0, 0, 0, 0, 0, 矢量(18.937, 14.313, -25.205),
			矢量(33.993, 9.128, -25.726), 0, 0, 0, 0, 0);
		"小字消息；索引 填写关卡;    \n字符串 填写文本 (一关可以多个文本) "
		全局.Tips[2] = 自定义字符串("关键词: 下压;\n全力向前跳出，快到达点位时按下压(Ctrl)");
		全局.Tips[3] = 自定义字符串("关键词: 下压;\n向外跳出，与墙空出一定距离，视角正对目标点按下压(Ctrl)");
		全局.Tips[4] = 自定义字符串("抓钩直接到达，无需下压");
		全局.Tips[8] = 自定义字符串("跳出后钩上方房檐，到达糖果所在房檐后滚落进点");
		全局.Tips[9] = 自定义字符串("全力向前跳出，快到达点位时略向右转视角正对点位按下压(Ctrl)");
		全局.Tips[10] = 自定义字符串("关键词：偷步;\n向前走出点位(不要按空格)，落地前按住空格(糖果处)");
		全局.Tips[17] = 自定义字符串("关键词：蹭墙;\n面向目标点,按住W,在快撞墙的瞬间按空格,可以跳得很高");
		全局.Tips[21] = 自定义字符串("关键词：蹭墙;\n面向墙面,按住W,在快撞墙的瞬间按空格,转视角面对目标点下压");
		全局.Tips[31] = 自定义字符串("关键词：蹭墙;\n按住W,在快撞墙的瞬间按空格,转视角面对目标点下压");
		全局.Tips[86] = 自定义字符串("关键词：蹭墙;\n按住W,在快撞墙的瞬间按空格,蹭起来后按D移动到目标点附近下压");
		全局.Tips[89] = 自定义字符串("关键词：蹭墙;\n蹭墙之后要按S后退一个球的距离再按下压(CTRL)");
	}
}

规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 直布罗陀 萌新")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(监测站：直布罗陀);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		创建HUD文本(所有玩家(所有队伍), 自定义字符串("通关教学: b站up:Stan_sin\r\n  BV13f4y1z71M(部分关卡有改动)"), 无, 无, 左边, 1, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		全局.CheckpointPosition = 数组(矢量(30.354, 5, -151.022), 矢量(35.194, 5, -145.988), 矢量(42.536, 3.218, -140.939), 矢量(36.938, 4.010,
			-124.670), 矢量(19.895, 6, -130.757), 矢量(46.563, 4.010, -129.999), 矢量(33.077, 6.560, -109.304), 矢量(26.769, 4, -88.758), 矢量(
			16.181, 3.046, -67.936), 矢量(27.615, 3.045, -69.458), 矢量(28.072, 3.998, -105.300), 矢量(60.854, 1, -113.372), 矢量(44.855, 4.010,
			-131.473), 矢量(39.700, 1, -144.094), 矢量(44.122, 0.999, -138.877), 矢量(44.350, 4.010, -130.820), 矢量(33.194, 4, -91.737), 矢量(
			30.991, 3, -72.417), 矢量(39.055, -4.947, -75.702), 矢量(45.022, -5, -69.766), 矢量(47.561, 3, -66.329), 矢量(45.596, 5.501, -54.397),
			矢量(36.368, -2.134, -56.973), 矢量(45.662, 3, -36.151), 矢量(67.234, 9.399, -36.279), 矢量(43.556, 3, -69.757), 矢量(36.668, -2.134,
			-57.072), 矢量(53.683, 8.908, -36.387), 矢量(82.606, 3, -33.352), 矢量(86.119, 3.010, -29.821), 矢量(77.563, 6, 6.752), 矢量(94.505,
			6.058, 42.927), 矢量(91.745, 6, 9.719), 矢量(85.001, 6.183, 51.283), 矢量(81.151, 2.845, 28.890), 矢量(72.629, 1.010, 20.003), 矢量(
			77.622, 6.010, 6.080), 矢量(75.526, 10, 7.506), 矢量(69.811, 9.010, 12.958), 矢量(67.433, 9, 25.709), 矢量(98.874, 2.745, -16.184), 矢量(
			67.245, -2.905, -13.682), 矢量(64.361, -2.993, -16.969), 矢量(69.946, 13.739, -37.547), 矢量(53.419, 8.734, -38.662), 矢量(35.716,
			3.046, -47.739), 矢量(45.993, 3, -36.446), 矢量(57.496, 3, -54.121), 矢量(47.804, 3, -66.313), 矢量(31.689, -5.149, -56.307), 矢量(
			34.071, -1.429, -53.736), 矢量(39.803, -5.012, -50.229), 矢量(43.110, -0.510, -49.171), 矢量(65.056, -3.141, -26.305), 矢量(62.097,
			2.028, -22.853), 矢量(73.527, -3.139, -32.081), 矢量(74.748, 2.107, -34.640), 矢量(59.518, 3, -52.439), 矢量(55.779, 8.139, -48.965),
			矢量(48.108, 3.046, -65.826), 矢量(38.250, -5.021, -77.715), 矢量(14.081, 3.045, -70.069), 矢量(26.826, 0.009, -105.191), 矢量(31.781, 4,
			-103.478), 矢量(42.742, -6.137, -119.077), 矢量(36.246, 0, -112.562), 矢量(33.140, 6.561, -109.766), 矢量(39.015, 0, -100.452), 矢量(
			31.313, 6.225, -92.990), 矢量(39.957, 3.998, -102.764), 矢量(33.417, 4.010, -86.090), 矢量(42.227, 3.990, -130.661), 矢量(35.776, 5,
			-144.535), 矢量(16.589, -2, -133.052), 矢量(37.649, 4.010, -124.211), 矢量(61.452, -7.192, -141.705), 矢量(60.992, 1, -115.213), 矢量(
			27.284, 3.013, -84.642), 矢量(16.503, -5, -70.262), 矢量(29.458, 6.938, -90.962), 矢量(38.373, -5.020, -77.208), 矢量(56.069, 3,
			-52.942), 矢量(47.966, -5, -68.898), 矢量(34.972, 3, -47.797), 矢量(62.694, -3.003, -16.511), 矢量(83.645, 6, 1.309), 矢量(97.334, 1,
			12.426), 矢量(87.994, 6, 12.362), 矢量(75.569, 9, 22.556), 矢量(59.696, 8.354, 20.334), 矢量(51.531, 9, 9.279), 矢量(41.032, 3, 7.798),
			矢量(49.293, 9, 6.813), 矢量(51.295, 3, 1.712), 矢量(48.646, 9, 7.999), 矢量(81.852, 1, 23.622), 矢量(79.799, 9, 21.207), 矢量(86.008,
			-3.141, -1.915), 矢量(83.702, 6.010, 0.450), 矢量(90.713, -3.045, -5.413), 矢量(83.375, 6, 0.473));
		全局.SecondaryFireState = 数组(假, 假, 真, 真, 真, 真, 真, 真, 假, 真, 真, 真, 假, 假, 假, 真, 真, 真, 假, 真, 假, 假, 真, 真, 真, 假, 真, 真, 假, 真, 真, 真, 真, 真, 假,
			真, 假, 假, 假, 真, 真, 假, 真, 假, 假, 假, 真, 假, 假, 假, 假, 假, 真, 假, 假, 假, 真, 假, 假, 真, 真, 真, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 真, 真, 真, 真,
			假, 真, 真, 真, 假, 真, 真, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 真, 假, 假, 假);
		全局.UltimateState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 矢量(21.742,
			-1.910, -129.950), 假, 矢量(63.864, -6.380, -131.746), 矢量(36.918, 0.092, -95.332), 假, 矢量(23.858, -5.068, -82.402), 假, 矢量(44.188,
			-5.058, -60.366), 假, 矢量(41.762, -5.059, -62.347), 假, 矢量(74.739, -3.006, -9.533), 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假);
		全局.Creator = 数组(自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"));
		全局.Tips[1] = 自定义字符串("仓鼠跑酷萌新教学图\nWelcome! ");
		全局.Tips[2] = 自定义字符串("区域分析:气候炎热 干燥 令人不愉快 适合仓鼠！");
		全局.Tips[3] = 自定义字符串("关键词: 抓钩；\nTips1: 尽量往高处钩\n钩左侧墙面高处");
		全局.Tips[4] = 自定义字符串("关键词: 抓钩；\n仓鼠跑酷第一步,练熟你的抓钩\n钩左侧墙面高处");
		全局.Tips[5] = 自定义字符串("关键词: 抓钩；\nTips2: 可以跳出去钩原本钩不到的地方\n钩右侧墙面高处");
		全局.Tips[6] = 自定义字符串("关键词: 抓钩；\nTips3: 不用踩死油门,学会适当减速\n钩墙面高处");
		全局.Tips[7] = 自定义字符串("关键词: 抓钩；\nTips4: 不要盲目下压,刹车落到点里更简单\n跳出去钩天花板");
		全局.Tips[9] = 自定义字符串("关键词: 下压；\nTips1: 下压会往前移动一小段距离\n向前跳出,接近目标点时按下压(Ctrl)");
		全局.Tips[11] = 自定义字符串("关键词: 抓钩；\nTips5: 路线不必直奔点去,可以从两侧绕过去\n钩天花板从右侧绕过去");
		全局.Tips[12] = 自定义字符串("关键词: 抓钩；\nTips6: 除了墙面,还有很多地方可以钩(如旗杆)");
		全局.Tips[14] = 自定义字符串("关键词: 转视角下压；\nTips2:下压总是朝着视角方向移动,因此需要正对目标点\n向右侧跳出,空中视角迅速向左转动,正对目标点按下压(Ctrl)");
		全局.Tips[15] = 自定义字符串("关键词: 下压；\nTips3:下压可以到达略高的地方\n正对目标点向前跳出后下压(别离墙太近,墙会挡住下压路线)");
		全局.Tips[16] = 自定义字符串("关键词: 抓钩；\n跳出后钩右侧高处墙面)");
		全局.Tips[17] = 自定义字符串("关键词: 抓钩；\n向右侧跳出后钩天花板");
		全局.Tips[18] = 自定义字符串("emm. 点在下面");
		全局.Tips[20] = 自定义字符串("技巧组合,抓钩起来后,转视角正对目标点,下压(别离墙太近)");
		全局.Tips[21] = 自定义字符串("关键词: 下压；\n距离较远,油门踩死!");
		全局.Tips[23] = 自定义字符串("关键词: 抓钩；\n钩右侧黄色墙面");
		全局.Tips[24] = 自定义字符串("关键词: 抓钩；\n向前跳出后钩飞机底部");
		全局.Tips[25] = 自定义字符串("关键词: 抓钩；\n钩天花板");
		全局.Tips[27] = 自定义字符串("关键词: 抓钩；\n钩右侧黄色墙面高处");
		全局.Tips[28] = 自定义字符串("关键词: 抓钩；\n向后跳出后钩飞机尾翼");
		全局.Tips[31] = 自定义字符串("关键词: 抓钩；\nTips7:绳子越长,飞得越远\n向后跳出后钩水塔顶部,油门踩死！\n可以在水管上滚过去(别着急下压)");
		全局.Tips[32] = 自定义字符串("关键词: 抓钩；\n钩旗杆");
		全局.Tips[33] = 自定义字符串("关键词: 抓钩；\nTips8:距离太远时,控制好轨迹呈抛物线,起点尽量低,由低到高慢慢到达最高点后松钩甩出去\n钩水塔顶部从右侧绕过去,油门踩死,握好方向盘！(别着急下压)");
		全局.Tips[34] = 自定义字符串("关键词: 抓钩；\nTips9:钩子可以在视角后面\n钩火箭高处,视角转向目标点,按住W向前跳出,到达最高点松钩落下");
		全局.Tips[35] = 自定义字符串("关键词: 偷步；\n向前走出(不要按空格),落地前按住空格");
		全局.Tips[37] = 自定义字符串("关键词: 下压；\nTips4:离墙太近了,下压路线会被墙挡住,需要后退点\n视角对着目标点偏左约30度(让自己后退时凌空),按S+D+空格向后跳出,然后下压");
		全局.Tips[38] = 自定义字符串("关键词: 转视角下压；\n视角转动较大,多加练xi");
		全局.Tips[40] = 自定义字符串("关键词: 抓钩；\nTips10:可以先降低自身高度让绳子更长一些\n从高台落下一点后钩水塔顶部");
		全局.Tips[43] = 自定义字符串("关键词: 抓钩；\nTips10: 先向后荡一点蓄力,再向前可以荡的更远\n面向B点大门处向后跳出同时钩正上方天花板,蓄力后按W向前,油门踩死！\n到达最高点后调整位置和视角落到点内或下压进点,较难,多加练xi");
		全局.Tips[44] = 自定义字符串("关键词: 偷步；\n复xi一下偷步技巧,向前走出(不要按空格),落地前按住空格");
		全局.Tips[45] = 自定义字符串("关键词: 下压；\n距离较远,油门踩死!多加练xi");
		全局.Tips[46] = 自定义字符串("关键词: 下压；\n距离较远,油门踩死!");
		全局.Tips[49] = 自定义字符串("关键词: 偷步；\n复xi一下偷步技巧");
		全局.Tips[50] = 自定义字符串("关键词: 蹭墙；\n按住W,碰到墙的一瞬间按空格(咱也是岛田家一员了)\n按空格的时机需要多加练xi");
		全局.Tips[52] = 自定义字符串("关键词: 蹭墙；\n按住W,碰到墙的一瞬间按空格(按空格的时机需要多加练xi)\nTips1: 蹭起来凌空后按下压(视角正对着目标点),可以上到更高的地方\n可以先后退一点再加速");
		全局.Tips[54] = 自定义字符串("关键词: 蹭墙；\n按住W,碰到墙的一瞬间按空格(按空格的时机需要多加练xi)\nTips2: 不用一直按着W,蹭起来后可以适当松开W(别离墙太近,墙会挡住下压路线)");
		全局.Tips[56] = 自定义字符串("关键词: 蹭墙；\n按住W,碰到墙的一瞬间按空格\nTips3(划重点!后面要考): 墙已经挡住下压路线了,需要蹭起来后按S后退一点,拉开距离后再下压");
		全局.Tips[57] = 自定义字符串("关键词: 抓钩；\n跳起来钩右侧墙面或天花板,避开所有障碍后落到点内,油门别踩死,慢慢来");
		全局.Tips[58] = 自定义字符串("关键词: 蹭墙；\n按住W,碰到墙的一瞬间按空格\nTips4: 蹭墙时视角一定要正对着墙,目标点与墙不在一个方向时,需要蹭起来后再转视角下压\n多加练xi");
		全局.Tips[60] = 自定义字符串("关键词: 偷步；\n复xi一下偷步技巧,抓钩(别按空格)到达门洞附近,偷步过门洞(EMM. 点在下面)");
		全局.Tips[63] = 自定义字符串("关键词: 蹭墙；\nTips5: 蹭角比蹭边更容易\n正对着墙角W+空格,起来后转视角下压");
		全局.Tips[65] = 自定义字符串("关键词: 蹭墙；\nTips6: 墙面凹凸不平,找到最合适的位置蹭\n多加练xi");
		全局.Tips[66] = 自定义字符串("关键词: 蹭墙；\n蹭墙角或蹭右边墙面再转视角都可以");
		全局.Tips[68] = 自定义字符串("关键词: 蹭墙；\n视角正对墙面,W+空格起来后,转视角(W不要松,可以按一下A帮助转视角)正对目标点,到达目标点附近后下压");
		全局.Tips[70] = 自定义字符串("关键词: 偷步蹭墙；\nTips1:直接走出去,按住W不要松开,落地前按住空格,在墙略前一点的地方落地偷步即可触发蹭墙\n距离把控需要多加练xi");
		全局.Tips[72] = 自定义字符串("关键词: 偷步蹭墙；\n偷步踩右侧箱子前面的地面蹭箱子\n多加练xi");
		全局.Tips[73] = 自定义字符串("关键词: 偷步蹭墙；\n偷步踩箱子前面的地面蹭箱子\n多加练xi");
		全局.Tips[74] = 自定义字符串("关键词: 超级跳；\n操作说明按互动(F)看蓝色字体描述\nTips1:钩低处物体表面,让绳子与地面平行\n多加练xi");
		全局.Tips[76] = 自定义字符串("关键词: 超级跳；\n操作说明按互动(F)看蓝色字体描述\nTips2:低矮障碍物的边缘,有一定弧度的墙面等,都可以起飞\n多加练xi");
		全局.Tips[79] = 自定义字符串("关键词: 超级跳；\nTips3:起飞后上升后可以再次蹭墙飞的更高(握好方向盘)");
		全局.Tips[86] = 自定义字符串("关键词: 滚边；\nTips1:很多障碍物表面都不算作地面,如房顶、房檐、墙的边缘、管道等\n向前跳出,在墙边缘滚动一段距离后落入点内");
		全局.Tips[88] = 自定义字符串("关键词: 蹭墙；\nTips7: 可以多次蹭墙跳的更高\n墙面(1)管道(2)箱子顶部(3),油门踩死");
		全局.Tips[92] = 自定义字符串("关键词: 蹭墙；\n蹭墙角起来后迅速转视角(180度),向前移动到目标点附近按下压");
		全局.Tips[96] = 自定义字符串(
			"关键词: 双蹭；\nTips1:只要速度足够,可以在空中多次触发蹭墙\n视角正对着靠目标点的墙,W+空格第一次蹭墙起来后,松开W按住D蹭右边的墙,第二次蹭墙起来后,松开D按S调整位置(很重要),下压进点\n较难,多加练xi");
		全局.Tips[98] = 自定义字符串("关键词: 双蹭；\nTips2:两面墙不一定要垂直,平行但隔一定距离也可以\n视角正对着靠目标点的墙,W按住不要松,第一次蹭箱子表面,第二次蹭墙面,到达最高点时松开W按S略后退些(很重要),下压进点");
		全局.Tips[100] = 自定义字符串("关键词: 双蹭；\n视角正对着左侧的墙,W+空格第一次蹭墙起来后,松开W按住D蹭右边的箱子顶部边缘,第二次蹭墙起来后,视角转向目标点松开D按W调整位置,下压进点\n较难,多加练xi");
	}
}

规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 圣诞节国王大道 萌新+")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(圣诞节国王大道);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		全局.CheckpointPosition = 数组(矢量(4.237, 6.026, -44.016), 矢量(4.502, 6.026, -37.056), 矢量(5.726, 6.353, -28.385), 矢量(-2.527, 4.531,
			-26.504), 矢量(-12.399, 6.110, -16.238), 矢量(-16.805, 6, -1.426), 矢量(-2.556, 5.290, 2.544), 矢量(2.428, 6.026, -34.952), 矢量(-27.596,
			6, -45.219), 矢量(-38.781, 0.051, -23.568), 矢量(-68.053, 4.500, -34.892), 矢量(-66.979, 5.095, -15.071), 矢量(-60.089, 4.956,
			-17.790), 矢量(-40.059, -0.143, -25.548), 矢量(-6.085, 4.531, -26.035), 矢量(-1.980, 5.307, 0.262), 矢量(16.551, 6, 15.531), 矢量(-3.354,
			5.221, 1.763), 矢量(-26.298, 6, 8.348), 矢量(-10.307, 16.917, 5.690), 矢量(-13.796, 6.230, -14.142), 矢量(-5.570, 4.531, -25.011), 矢量(
			1.978, 6.026, -34.557), 矢量(-26.624, 6, -47.598), 矢量(-29.035, 9.163, -17.177), 矢量(-47.735, 9.123, -36.819), 矢量(-92.566, 7.489,
			-29.917), 矢量(-88.307, 6.930, -14.610), 矢量(-60.455, 3, -4.672), 矢量(-57.437, 5.135, -16.808), 矢量(-47.634, 9.123, -36.816), 矢量(
			-34.174, 9, -34.377), 矢量(4.658, 6.784, -12.387), 矢量(9.543, 6, -15.993), 矢量(-4.043, 13.996, 18.111), 矢量(-11.387, 1.818,
			-33.292), 矢量(-22.802, -0.124, -27.976), 矢量(-29.226, 9, -16.241), 矢量(-34.933, 9, -34.173), 矢量(-86.764, 6.933, -18.195), 矢量(
			-126.485, -1.225, -1.035), 矢量(-151.007, 0.071, 4.869), 矢量(-116.043, 6.100, 5.694), 矢量(-147.439, -2.929, 37.338), 矢量(-145.607,
			1.134, 35.482), 矢量(-138.716, -2.929, 40.436), 矢量(-136.718, 0.081, 46.247), 矢量(-142.550, -2.929, 36.612), 矢量(-146.885, 0.071,
			45.244), 矢量(-146.063, 1.082, 35.880), 矢量(-131.189, 1, -3.599), 矢量(-118.856, -1.289, -9.605), 矢量(-119.211, 3.036, -11.229), 矢量(
			-118.829, -1.289, -9.660), 矢量(-119.189, 1.071, -14.974), 矢量(-117.615, -1.206, -5.449), 矢量(-88.468, 6.933, -9.332), 矢量(-82.921,
			0.447, -23.622), 矢量(-92.890, 7.488, -29.678), 矢量(-83.588, 0.532, -42.141), 矢量(-79.979, 4.500, -42.643), 矢量(-61.598, 0.383,
			-16.875), 矢量(-59.029, 4.956, -17.105), 矢量(-65.711, -0.014, -33.875), 矢量(-67.796, 4.500, -35.171), 矢量(-26.195, -0.125, -25.134),
			矢量(-7.614, 6, -42.014), 矢量(-1.443, 0.036, -35.818), 矢量(1.732, 6.026, -37.071), 矢量(-2.397, 0.045, -27.844), 矢量(5.694, 6.265,
			-27.319), 矢量(-11.631, 6.110, -16.787), 矢量(3.303, 6.774, -9.587), 矢量(-6.009, 0.498, 3.735), 矢量(-3.104, 5.245, 1.295), 矢量(-3.608,
			-0.122, -4.687), 矢量(3.345, 6.774, -9.174), 矢量(6.091, 0.067, -21.093), 矢量(-3.396, 5.308, 3.484), 矢量(-5.043, -0.083, -1.364), 矢量(
			2.423, 6.026, -34.853), 矢量(3.409, -0.133, -26.510), 矢量(-26.102, 6, -43.060), 矢量(-24.942, -0.119, -29.676), 矢量(5.796, 6.110,
			-25.659), 矢量(-5.205, 0.070, -10.390), 矢量(-4.468, 5.095, 3.671), 矢量(-7.329, -0.091, 7.861), 矢量(-5.615, 8.944, -22.637));
		全局.SecondaryFireState = 数组(假, 假, 假, 真, 真, 真, 真, 真, 真, 真, 真, 假, 真, 真, 真, 真, 真, 真, 真, 假, 假, 假, 真, 真, 真, 真, 假, 真, 真, 真, 假, 真, 假, 真, 真,
			假, 真, 真, 真, 真, 真, 真, 真, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 真, 假, 真, 假, 假, 真, 假, 真, 假, 真, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			真, 假, 真, 假, 真, 假, 真, 假, 真, 假, 真);
		全局.UltimateState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 矢量(-105.944, 0.587, -8.516), 假, 矢量(-97.821, 1.809, -20.359), 假, 假,
			假, 假, 假, 假, 假, 矢量(-13.752, -0.034, -32.514), 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 矢量(-10.698, -0.032, -2.890), 假, 矢量(-1.719, 0.365,
			-19.399), 假, 矢量(-9.370, 0.203, -33.802), 假, 矢量(-14.304, -0.034, -32.921), 假, 矢量(0.970, -0.019, -11.442), 假, 矢量(-7.223, -0.031,
			-7.390));
		全局.Creator = 数组(自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(
			""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""),
			自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(
			""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""),
			自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(
			""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""),
			自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(
			""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""),
			自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""));
	}
}

规则("[自定义]允许开拓? 否则将使用导入的点位进行常规计时跑酷模式")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		禁用 全局.PioneerModeEnabled = 真;
		全局.PioneerModeEnabled = 地图工坊设置开关(自定义字符串("模式设置开关"), 自定义字符串("是否允许开拓"), 假, 0);
		全局.RGB[0] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("目标点圈红"), 255, 0, 255, 0);
		全局.RGB[1] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("目标点圈绿"), 255, 0, 255, 1);
		全局.RGB[2] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("目标点圈蓝"), 0, 0, 255, 2);
		全局.RGB[3] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("目标点圈不透明度"), 255, 0, 255, 3);
		全局.RGB[4] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("起飞点圈红"), 208, 0, 255, 4);
		全局.RGB[5] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("起飞点圈绿"), 68, 0, 255, 5);
		全局.RGB[6] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("起飞点圈蓝"), 180, 0, 255, 6);
		全局.RGB[7] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("起飞点圈不透明度"), 255, 0, 255, 7);
		全局.RGB[8] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("小球红"), 154, 0, 255, 8);
		全局.RGB[9] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("小球绿"), 110, 0, 255, 9);
		全局.RGB[10] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("小球蓝"), 147, 0, 255, 10);
		全局.RGB[11] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("小球不透明度"), 255, 0, 255, 11);
	}
}

规则("[自定义]禁止连续开拓")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		禁用 全局.DisableContinuousCreation = 假;
		全局.DisableContinuousCreation = 地图工坊设置开关(自定义字符串("模式设置开关"), 自定义字符串("连续开拓"), 假, 1);
		全局.CheatRecord = 地图工坊设置开关(自定义字符串("快捷键"), 自定义字符串("跳关提醒"), 真, 0);
	}
}

规则("[自定义]落地判定是否开启")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.JudgeWhenLanding = 真;
	}
}

规则("[自定义]判定圈的大小")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.RingRadius[0] = 地图工坊设置实数(自定义字符串("参数"), 自定义字符串("目标点圈大小"), 1.500, 0.500, 4, 0);
		全局.RingRadius[1] = 地图工坊设置实数(自定义字符串("参数"), 自定义字符串(" 起始点圈大小"), 2, 0.200, 5, 1);
		全局.RingRadius[2] = 地图工坊设置实数(自定义字符串("参数"), 自定义字符串("起飞点圈大小"), 2, 0.200, 4, 2);
		全局.SphereRadius = 地图工坊设置实数(自定义字符串("参数"), 自定义字符串("小球显示大小"), 2, 0.200, 5, 3);
		全局.SphereJudgeRadius = 地图工坊设置实数(自定义字符串("参数"), 自定义字符串("小球判定大小"), 1.800, 0.200, 5, 4);
	}
}

规则("[自定义] 进点传送")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.TeleportWhenEnterNextPosition = 假;
	}
}

规则("[自定义]一次性技能(如开启本功能,请确保技能CD大于0.5秒)")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.OneTimeAbility = 真;
	}
}

规则("[自定义]哪些技能可以使用(如果要开启大招,请关掉 英雄-设置-大招自动充能 )")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"技能1(S)"
		全局.DefaultAliblty1Enabled = 真;
		"技能2(E)"
		全局.DefaultAliblty2Enabled = 真;
		"辅助攻击模式(右键)"
		全局.DefaultSecondaryEnabled = 真;
		"终极技能"
		全局.DefaultUltimateEnabled = 假;
	}
}

规则("[自定义]终极技能的冷却时间")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.UltimateCD = 15;
	}
}

规则("全局初始化")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		关闭游戏预设通告模式;
		关闭游戏预设计分模式;
		关闭游戏预设完成条件;
		关闭游戏预设音乐模式;
		If(数量(全局.CheckpointPosition) == 0);
			全局.CheckpointPosition = 空数组;
			全局.Ability1State = 空数组;
			全局.Ability2State = 空数组;
			全局.SecondaryFireState = 空数组;
			全局.Creator = 空数组;
			全局.UltimateState = 空数组;
		End;
		全局.RoomAliveHoursLeft = 4;
		全局.PlayersData = 空数组;
		设置比赛时间(1800);
		设置目标点描述(所有玩家(所有队伍), 自定义字符串("本局游戏时间还剩：​{0}小时​{1}分钟​", 全局.RoomAliveHoursLeft, 取整(比赛时间 / 60, 下)), 可见和字符串);
		全局.PioneerLandingPosition = 无;
		全局.PioneerSpherePosition = 无;
		创建HUD文本(所有玩家(所有队伍), 自定义字符串("模式名称：仓鼠跑酷教学\r\n代码: Z4DBC\r\n记得在近期游玩里收藏\r\n更多跑酷地图代码: 9ZDS3 | G7V27 | GYZFZ"), 无, 无, 左边, 0, 颜色(亮紫色), 颜色(
			白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 自定义字符串("模式名称：仓鼠跑酷教学\r\n代码: Z4DBC\r\n记得在近期游玩里收藏\r\n更多跑酷地图代码: 9ZDS3 | G7V27 | GYZFZ"), 无, 无, 左边, 0, 颜色(亮紫色), 颜色(
			白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串(" "), 左边, 1, 颜色(白色), 颜色(白色), 颜色(橙色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串(" "), 右边, 1, 颜色(白色), 颜色(白色), 颜色(橙色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), !按钮被按下(当前数组元素, 按钮(互动))), 自定义字符串("按下互动键({0})查看快捷键说明​以及操作说明", 输入绑定字符串(按钮(互动))), 无, 无, 左边, 2, 颜色(黄色), 颜色(
			白色), 颜色(黄色), 可见和字符串, 默认可见度);
		If(全局.PioneerModeEnabled == 真);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), !实体存在(全局.Pioneer) && 数量(全局.CheckpointPosition) == 0 && 在地面上(当前数组元素)), 自定义字符串("互动{0}+装填{1} 在当前位置开拓​",
				输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(装填))), 无, 无, 左边, 1, 颜色(橙色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.GameComplete && !实体存在(全局.Pioneer) && 数量(全局.CheckpointPosition) != 0), 自定义字符串(
				"互动{0}+装填{1} 成为开拓者,继续开拓​", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(装填))), 无, 无, 左边, 2, 颜色(橙色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.GameComplete && 实体存在(全局.Pioneer)), 自定义字符串("当前开拓者: {0}", 全局.Pioneer), 无, 无, 左边, 0, 颜色(橙色), 颜色(白色),
				颜色(白色), 可见和字符串, 始终不可见);
			创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("已开拓关卡数:{0}", 数量(全局.CheckpointPosition) - 1), 右边, 0, 颜色(白色), 颜色(白色), 颜色(橙色), 可见和字符串, 默认可见度);
			创建HUD文本(添加至数组(添加至数组(空数组, 全局.Pioneer), 无)[1 * !(全局.PioneerLandingPosition != 无)], 自定义字符串("已开拓 长按互动确认,短按互动重新开拓​"), 无, 无, 顶部, 1, 颜色(
				橙色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
			创建效果(已过滤的数组(全局.Pioneer, 全局.PioneerLandingPosition != 假), 环, 颜色(黄色), 全局.PioneerLandingPosition, 全局.RingRadius[0], 可见，位置和半径);
			创建效果(已过滤的数组(全局.Pioneer, 全局.PioneerLandingPosition != 假), 光柱, 颜色(黄色), 全局.PioneerLandingPosition, 全局.RingRadius[0], 可见，位置和半径);
			创建效果(已过滤的数组(全局.Pioneer, 全局.Pioneer.UltimateUsed != (假 || 0)), 环, 颜色(亮紫色), 全局.Pioneer.UltimateUsed, 全局.RingRadius[2], 可见，位置和半径);
			创建效果(已过滤的数组(全局.Pioneer, 全局.Pioneer.UltimateUsed != (假 || 0)), 光柱, 颜色(亮紫色), 全局.Pioneer.UltimateUsed, 全局.RingRadius[2], 可见，位置和半径);
			"小球"
			创建效果(已过滤的数组(全局.Pioneer, 全局.PioneerSpherePosition != 假), 球, 自定义颜色(全局.RGB[8], 全局.RGB[9], 全局.RGB[10], 全局.RGB[11]),
				全局.PioneerSpherePosition + 矢量(0, 0.800, 0), 全局.SphereRadius, 可见，位置和半径);
			"小球图标"
			创建图标(已过滤的数组(全局.Pioneer, 全局.PioneerSpherePosition != 假), 全局.PioneerSpherePosition + 矢量(0, 0.800, 0), 加号, 可见，位置和颜色, 颜色(橙色), 真);
		Else;
			全局.BestScore[0] = 自定义字符串("无");
			全局.BestScore[1] = 0;
			创建HUD文本(所有玩家(所有队伍), 自定义字符串("最好成绩: {0}/{1}S", 全局.BestScore[0], 全局.BestScore[1]), 无, 无, 左边, 0, 颜色(绿色), 颜色(白色), 颜色(白色), 可见和字符串,
				默认可见度);
		End;
	}
}

规则("玩家初始化")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		事件玩家.Level = 0;
		事件玩家.ScoreOfThisRound = 0;
		事件玩家.mistake = 0;
		事件玩家.cheat = 0;
		事件玩家.HintFreq = 0;
		调用子程序(ValidationPlayerData);
		传送(事件玩家, 全局.CheckpointPosition[事件玩家.Level]);
		事件玩家.InteractPressState = 0;
		事件玩家.IsReady = 真;
		事件玩家.FreeMode = 假;
		事件玩家.Invisible = 假;
		事件玩家.IsSpectating = 假;
		对所有玩家启用死亡回放(事件玩家);
		启用死亡回放时目标的HUD(事件玩家);
		创建地图文本(事件玩家.Invisible ? 无 : 所有玩家(所有队伍), 事件玩家, 事件玩家, 1, 不要截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
		创建效果(已过滤的数组(事件玩家, 数量(全局.CheckpointPosition) != 0), 环, 颜色(绿色), 全局.CheckpointPosition[事件玩家.Level], 全局.RingRadius[1], 可见，位置和半径);
		创建图标(已过滤的数组(事件玩家, !事件玩家.GameComplete), 全局.CheckpointPosition[事件玩家.Level + 1], 旗帜, 可见和位置, 颜色(黄色), 真);
		创建HUD文本(已过滤的数组(事件玩家, !事件玩家.GameComplete), 自定义字符串("第​{0}关 作者: {1}", 事件玩家.Level + 1, 全局.Creator[事件玩家.Level]), 无, 无, 左边, 0, 颜色(橙色),
			颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		If(全局.PioneerModeEnabled == 真);
			创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("{0}:{1}", 事件玩家, 事件玩家.Level), 右边, 1000 - 事件玩家.Level, 颜色(白色), 颜色(白色), 颜色(橙色), 可见性，排序规则和字符串, 默认可见度);
		Else;
			创建HUD文本(已过滤的数组(事件玩家, !事件玩家.GameComplete), 无, 无, 自定义字符串("检查点: {0} / {1}", 事件玩家.Level + 1, 数量(全局.CheckpointPosition) - 1), 顶部, -1,
				颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), 事件玩家.BestScore != 0), 无, 无, 自定义字符串("{0}：{2}S/第{1}关", 事件玩家, 事件玩家.Level, 事件玩家.ScoreOfThisRound), 右边,
				事件玩家.BestScore, 颜色(白色), 颜色(白色), 颜色(橙色), 可见性，排序规则和字符串, 默认可见度);
			创建HUD文本(已过滤的数组(事件玩家, 事件玩家.ScoreOfThisRound != 0), 无, 无, 事件玩家.ScoreOfThisRound, 顶部, 1, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		End;
		创建效果(已过滤的数组(事件玩家, !事件玩家.GameComplete), 环, 自定义颜色(全局.RGB[0], 全局.RGB[1], 全局.RGB[2], 全局.RGB[3]), 全局.CheckpointPosition[事件玩家.Level + 1],
			全局.RingRadius[0], 可见，位置和半径);
		事件玩家.BestScore[0] = 最后创建的实体;
		创建效果(已过滤的数组(事件玩家, !事件玩家.GameComplete), 光柱, 自定义颜色(全局.RGB[0], 全局.RGB[1], 全局.RGB[2], 全局.RGB[3]),
			全局.CheckpointPosition[事件玩家.Level + 1], 全局.RingRadius[0], 可见，位置和半径);
		事件玩家.BestScore[1] = 最后创建的实体;
		创建地图文本(已过滤的数组(事件玩家, !事件玩家.GameComplete), 自定义字符串("快到碗里来"), 全局.CheckpointPosition[事件玩家.Level + 1], 2, 不要截取, 可见，位置和字符串, 颜色(白色),
			始终不可见);
		事件玩家.BestScore[2] = 上一个文本ID;
		创建效果(已过滤的数组(事件玩家, 全局.UltimateState[事件玩家.Level + 1] != 假), 环, 自定义颜色(全局.RGB[4], 全局.RGB[5], 全局.RGB[6], 全局.RGB[7]),
			全局.UltimateState[事件玩家.Level + 1], 全局.RingRadius[2], 可见，位置和半径);
		事件玩家.BestScore[3] = 最后创建的实体;
		创建效果(已过滤的数组(事件玩家, 全局.UltimateState[事件玩家.Level + 1] != 假), 光柱, 自定义颜色(全局.RGB[4], 全局.RGB[5], 全局.RGB[6], 全局.RGB[7]),
			全局.UltimateState[事件玩家.Level + 1], 全局.RingRadius[2], 可见，位置和半径);
		事件玩家.BestScore[4] = 最后创建的实体;
		创建地图文本(已过滤的数组(事件玩家, 全局.UltimateState[事件玩家.Level + 1] != 假), 自定义字符串("在这里起飞"), 全局.UltimateState[事件玩家.Level + 1], 2, 不要截取, 可见，位置和字符串,
			颜色(白色), 始终不可见);
		事件玩家.BestScore[5] = 上一个文本ID;
		创建HUD文本(所有玩家(所有队伍), 自定义字符串(""), 无, 无, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		"小球"
		创建效果(已过滤的数组(事件玩家, 事件玩家.sphere_state == 假 && !事件玩家.GameComplete), 球, 自定义颜色(全局.RGB[8], 全局.RGB[9], 全局.RGB[10], 全局.RGB[11]),
			全局.SpherePosition[事件玩家.Level + 1] + 矢量(0, 0.800, 0), 全局.SphereRadius, 可见，位置和半径);
		"小球图标"
		创建地图文本(已过滤的数组(事件玩家, 事件玩家.sphere_state == 假 && !事件玩家.GameComplete), 自定义字符串("先来拿糖果"), 全局.SpherePosition[事件玩家.Level + 1] + 矢量(0,
			1.500, 0), 2, 不要截取, 可见，位置和字符串, 颜色(白色), 始终不可见);
		创建图标(已过滤的数组(事件玩家, 事件玩家.sphere_state == 假 && !事件玩家.GameComplete), 全局.SpherePosition[事件玩家.Level + 1] + 矢量(0, 0.800, 0), 加号, 可见，位置和颜色,
			颜色(橙色), 真);
		调用子程序(ResetBall);
		"玩家指引HUD 在终极技能充能处"
		If(全局.Tips != 无);
			创建HUD文本(已过滤的数组(事件玩家, !事件玩家.GameComplete), 无, 无, 自定义字符串("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"), 顶部, 99, 无,
				无, 无, 可见, 默认可见度);
			创建HUD文本(已过滤的数组(事件玩家, 全局.Tips[事件玩家.Level + 1] && !事件玩家.GameComplete && !事件玩家.FreeMode && !按钮被按下(事件玩家, 按钮(互动))), 自定义字符串(
				"{0}：　　　　　　　　　　　　　　　　　　　　　▼\n{1}\n", 英雄图标字符串(英雄(破坏球)), 全局.Tips[事件玩家.Level + 1]), 无, 无, 顶部, 100, 颜色(青绿色), 无, 无, 可见和字符串, 默认可见度);
		End;
		禁用 小字体信息(事件玩家, 自定义字符串("玩家初始化"));
	}
}

规则("删除关卡后修复玩家关卡数")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.Level >= 数量(全局.CheckpointPosition);
	}

	动作
	{
		事件玩家.Level = 数量(全局.CheckpointPosition) - 1;
		事件玩家.Level = 较大(事件玩家.Level, 0);
	}
}

规则("是否完成所有关卡 假")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.Level < 数量(全局.CheckpointPosition) - 1;
	}

	动作
	{
		传送(事件玩家, 全局.CheckpointPosition[事件玩家.Level]);
		If(事件玩家.GameComplete == 真);
			事件玩家.BestScore[6] = 0;
		End;
		等待(0.100, 当为“假”时中止);
		事件玩家.GameComplete = 假;
		调用子程序(Reset);
	}
}

规则("是否完成所有关卡 真")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(数量(全局.CheckpointPosition) == 0 || 事件玩家.Level >= 数量(全局.CheckpointPosition) - 1) == 真;
	}

	动作
	{
		事件玩家.GameComplete = 真;
		调用子程序(SetAbility);
		If(全局.PioneerModeEnabled == 假 && 事件玩家.ScoreOfThisRound != 0);
			事件玩家.LastScore = 事件玩家.ScoreOfThisRound;
			If(事件玩家.cheat == 0);
				小字体信息(所有玩家(所有队伍), 自定义字符串("{0}耗时​{1}完成比赛!", 事件玩家, 事件玩家.LastScore));
				事件玩家.BestScore = 事件玩家.ScoreOfThisRound;
				If(全局.BestScore[1] == 0 || 事件玩家.BestScore < 全局.BestScore[1]);
					全局.BestScore[0] = 自定义字符串("{0}", 事件玩家);
					全局.BestScore[1] = 事件玩家.LastScore;
				End;
			Else;
				小字体信息(所有玩家(所有队伍), 自定义字符串("{0}耗时​{1}完成比赛!但是他作弊了~{2}", 事件玩家, 事件玩家.LastScore, 英雄图标字符串(英雄(破坏球))));
			End;
		End;
		停止追踪玩家变量(事件玩家, ScoreOfThisRound);
	}
}

规则("当玩家成为开拓者")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
	}

	动作
	{
		If(数量(全局.CheckpointPosition) < 1000);
			播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 100);
			事件玩家.FreeMode = 假;
			调用子程序(Reset);
		Else;
			小字体信息(事件玩家, 自定义字符串("不能再继续开拓了​"));
			全局.PioneerStarted = 假;
			全局.Pioneer = 无;
		End;
		If(全局.UltimateState[事件玩家.Level + 1] != 假);
			施加推力(事件玩家, 速率(事件玩家) * -1, 0.010, 至地图, 取消相反运动);
			大字体信息(事件玩家, 自定义字符串("不要乱跑"));
			传送(事件玩家, 全局.CheckpointPosition[事件玩家.Level]);
		End;
		事件玩家.ultimate_log = 自定义字符串("已关闭");
		根据条件中止(事件玩家 != 全局.Pioneer);
		If(事件玩家.ultimate_log == 自定义字符串("已开启"));
			事件玩家.ultimate_worked = 真;
			小字体信息(事件玩家, 自定义字符串("切换到超级跳开拓模式"));
		Else;
			事件玩家.ultimate_worked = 假;
			小字体信息(事件玩家, 自定义字符串("切换到正常开拓模式"));
		End;
		事件玩家.UltimateUsed = 假;
	}
}

规则("记录玩家辅助攻击使用情况")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.SecondaryFireUsed == 假;
		正在使用辅助武器(事件玩家) == 真;
	}

	动作
	{
		事件玩家.SecondaryFireUsed = 真;
	}
}

规则("终极技能模拟CD(开始CD)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DefaultUltimateEnabled == 真;
		正在使用终极技能(事件玩家) == 假;
		终极技能充能百分比(事件玩家) <= 1;
	}

	动作
	{
		事件玩家.UltimateCharge = 0;
	}
}

规则("一次性辅助攻击模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.OneTimeAbility == 真;
		事件玩家.FreeMode == 假;
		(!事件玩家.GameComplete || 事件玩家 == 全局.Pioneer) == 真;
		事件玩家.SecondaryFireUsed == 真;
		正在使用辅助武器(事件玩家) == 假;
	}

	动作
	{
		等待(0.500, 当为“假”时中止);
		If(相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius || !在地面上(事件玩家));
			If(事件玩家 != 全局.Pioneer || 全局.PioneerLandingPosition == 无);
				设置辅助攻击模式启用(事件玩家, 假);
			End;
		End;
	}
}

规则("一次性技能2")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.OneTimeAbility == 真;
		事件玩家.FreeMode == 假;
		(!事件玩家.GameComplete || 事件玩家 == 全局.Pioneer) == 真;
		事件玩家.Ability2Used == 真;
		正在使用技能 2(事件玩家) == 假;
	}

	动作
	{
		等待(0.500, 当为“假”时中止);
		If(相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius || !在地面上(事件玩家));
			If(事件玩家 != 全局.Pioneer || 全局.PioneerLandingPosition == 无);
				设置启用技能 2(事件玩家, 假);
			End;
		End;
	}
}

规则("终极技能模拟CD")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DefaultUltimateEnabled == 真;
		终极技能充能百分比(事件玩家) != 100;
		正在使用终极技能(事件玩家) == 假;
	}

	动作
	{
		等待(0.160, 当为“假”时中止);
		事件玩家.UltimateCharge += 16 / 全局.UltimateCD;
		设置终极技能充能(事件玩家, 事件玩家.UltimateCharge);
		如条件为”真“则循环;
	}
}

规则("在地面上时 重置一次性技能")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.IsReady == 真;
		在地面上(事件玩家) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) <= 全局.RingRadius;
	}

	动作
	{
		禁用 等待(0.032, 当为“假”时中止);
		调用子程序(SetAbility);
	}
}

规则("在地面上时 重置技能CD")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.IsReady == 真;
		在地面上(事件玩家) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) <= 全局.RingRadius;
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) + 技能冷却时间(事件玩家, 按钮(技能1)) + 技能冷却时间(事件玩家, 按钮(技能2)) != 0;
	}

	动作
	{
		等待(0.032, 当为“假”时中止);
		设置技能冷却(事件玩家, 按钮(辅助攻击模式), 0);
		设置技能冷却(事件玩家, 按钮(技能1), 0);
		设置技能冷却(事件玩家, 按钮(技能2), 0);
	}
}

规则("禁用重生室")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		在重生室中(事件玩家) == 真;
		数量(全局.CheckpointPosition) != 0;
		(事件玩家 == 全局.Pioneer || !事件玩家.GameComplete) == 真;
	}

	动作
	{
		调用子程序(Reset);
	}
}

规则("小球拾取")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.sphere_state == 假;
		事件玩家.IsReady == 真;
		事件玩家.FreeMode == 假;
		全局.Pioneer != 事件玩家;
		事件玩家.GameComplete == 假;
		相距距离(事件玩家, 全局.SpherePosition[事件玩家.Level + 1]) <= 全局.SphereJudgeRadius;
		(!全局.JudgeWhenLanding || 在地面上(事件玩家)) == 假;
		事件玩家.ultimate_worked == 假;
	}

	动作
	{
		事件玩家.sphere_state = !事件玩家.GameComplete && !事件玩家.FreeMode ? 真 : 假;
		小字体信息(事件玩家, 自定义字符串("拿到糖果了!"));
		播放效果(事件玩家, 正面状态施加声音, 无, 事件玩家, 80);
	}
}

规则("闯关者到达下一关")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.IsReady == 真;
		事件玩家.FreeMode == 假;
		全局.Pioneer != 事件玩家;
		事件玩家.GameComplete == 假;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level + 1]) <= 全局.RingRadius;
		(!全局.JudgeWhenLanding || 在地面上(事件玩家)) == 真;
		事件玩家.ultimate_worked == 假;
	}

	动作
	{
		If(!事件玩家.sphere_state);
			调用子程序(Reset);
			小字体信息(事件玩家, 自定义字符串("糖果还没拿到!"));
			播放效果(事件玩家, 爆炸声音, 无, 事件玩家, 100);
			中止;
		End;
		播放效果(事件玩家, 状态爆炸声音, 颜色(白色), 事件玩家, 100);
		事件玩家.Level += 1;
		事件玩家.HintFreq = 0;
		调用子程序(EditPlayerData);
		If(事件玩家.Level < 数量(全局.CheckpointPosition));
			调用子程序(Reset);
		End;
	}
}

规则("闯关者圈外触地")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.Pioneer != 事件玩家;
		事件玩家.FreeMode == 假;
		事件玩家.GameComplete == 假;
		在地面上(事件玩家) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level + 1]) > 全局.RingRadius[0];
	}

	动作
	{
		If(事件玩家.ultimate_worked == 假);
			等待(0.016, 当为“假”时中止);
			事件玩家.mistake += 1;
			调用子程序(Reset);
		End;
	}
}

规则("开拓者圈外触地")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
		事件玩家.FreeMode == 假;
		全局.PioneerLandingPosition == 无;
		全局.PioneerStarted == 真;
		在地面上(事件玩家) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
	}

	动作
	{
		If(事件玩家.ultimate_worked == 假);
			If(相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) < 全局.RingRadius[1] * 2);
				开始规则(MessageCall, 无动作);
				调用子程序(Reset);
				If(事件玩家.UltimateUsed != 假);
					If(相距距离(事件玩家.UltimateUsed, 所选位置(事件玩家)) >= 2 * 全局.RingRadius[2]);
						开始规则(MessageCall, 无动作);
						调用子程序(Reset);
					End;
				End;
			Else If(在重生室中(事件玩家) == 假);
				播放效果(事件玩家, 状态爆炸声音, 颜色(白色), 事件玩家, 100);
				全局.PioneerLandingPosition = 所选位置(事件玩家);
				设置启用技能 2(事件玩家, 事件玩家.Ability2Used);
				设置辅助攻击模式启用(事件玩家, 事件玩家.SecondaryFireUsed);
				设置启用终极技能(事件玩家, 事件玩家.UltimateUsed);
			End;
		End;
	}
}

规则("闯关者圈内触地")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.Pioneer != 事件玩家;
		事件玩家.FreeMode == 假;
		事件玩家.GameComplete == 假;
		在地面上(事件玩家) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) <= 全局.RingRadius[1];
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level + 1]) > 全局.RingRadius[0];
	}

	动作
	{
		事件玩家.sphere_state = 全局.SpherePosition[事件玩家.Level + 1] ? 假 : 真;
	}
}

规则("开拓者圈内触地")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
		事件玩家.FreeMode == 假;
		全局.PioneerLandingPosition == 无;
		全局.PioneerStarted == 真;
		在地面上(事件玩家) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) <= 全局.RingRadius[1];
	}

	动作
	{
		全局.PioneerSpherePosition = 无;
	}
}

规则("开拓者离开比赛")
{
	事件
	{
		玩家离开比赛;
		双方;
		全部;
	}

	条件
	{
		全局.PioneerModeEnabled == 真;
		事件玩家 == 全局.Pioneer;
	}

	动作
	{
		全局.PioneerStarted = 假;
		全局.PioneerLandingPosition = 无;
		全局.Pioneer = 数组随机取值(已过滤的数组(所有玩家(所有队伍), 当前数组元素.GameComplete && 当前数组元素 != 事件玩家 && 当前数组元素 != 最后(全局.Creator)));
	}
}

规则("[子程序] 设置技能")
{
	事件
	{
		子程序;
		SetAbility;
	}

	动作
	{
		事件玩家.Ability1Used = 假;
		事件玩家.Ability2Used = 假;
		事件玩家.SecondaryFireUsed = 假;
		If(事件玩家.GameComplete || 事件玩家.FreeMode || 事件玩家.IsSpectating);
			If(全局.Pioneer != 事件玩家);
				可用按钮(事件玩家, 按钮(技能1));
			End;
			设置启用技能 1(事件玩家, 全局.DefaultAliblty1Enabled && 全局.Pioneer != 事件玩家);
			设置启用技能 2(事件玩家, 全局.DefaultAliblty2Enabled);
			设置辅助攻击模式启用(事件玩家, 全局.DefaultSecondaryEnabled);
			设置启用终极技能(事件玩家, 全局.DefaultUltimateEnabled);
			可用按钮(事件玩家, 按钮(主要攻击模式));
		Else;
			设置启用技能 1(事件玩家, 全局.Ability1State[事件玩家.Level]);
			设置启用技能 2(事件玩家, 全局.Ability2State[事件玩家.Level]);
			设置辅助攻击模式启用(事件玩家, 全局.SecondaryFireState[事件玩家.Level]);
			设置终极技能充能(事件玩家, 100);
			禁用 事件玩家.ultimate_outline_countdown = 假;
			禁用按钮(事件玩家, 按钮(主要攻击模式));
		End;
	}
}

规则("相移")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		具有状态(事件玩家, 相移) == 假;
	}

	动作
	{
		等待(0.250, 无视条件);
		清除状态(事件玩家, 相移);
		设置状态(事件玩家, 无, 相移, 9999);
	}
}

规则("房间存活倒计时")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		比赛时间 == 0;
		全局.RoomAliveHoursLeft != 0;
	}

	动作
	{
		等待(1, 无视条件);
		全局.RoomAliveHoursLeft -= 1;
		设置比赛时间(3600);
	}
}

规则("定时更新目标点描述")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		If(全局.RoomAliveHoursLeft == 0 && 比赛时间 == 0);
			设置目标点描述(所有玩家(所有队伍), 自定义字符串("房间即将重启​"), 可见和字符串);
		Else;
			设置目标点描述(所有玩家(所有队伍), 自定义字符串("本局游戏时间还剩：​{0}小时​{1}分钟​", 全局.RoomAliveHoursLeft, 取整(比赛时间 / 60, 下)), 可见和字符串);
		End;
		等待(1, 无视条件);
		If(全局.CheatRecord != 假);
			If(数量(全局.cheat_log) >= 1);
				大字体信息(所有玩家(所有队伍), 全局.cheat_log[0]);
				等待(1, 无视条件);
				修改全局变量(cheat_log, 根据索引从数组中移除, 0);
			End;
		End;
		循环;
	}
}

规则("[子程序 ] 重置当前关卡")
{
	事件
	{
		子程序;
		Reset;
	}

	动作
	{
		禁用 小字体信息(事件玩家, 自定义字符串("reset"));
		While(全局.JumpState[事件玩家.Level] == 自定义字符串("跳跃点"));
			事件玩家.Level += 1;
		End;
		If(全局.Pioneer != 事件玩家);
			事件玩家.ultimate_log = 空数组;
		End;
		事件玩家.ultimate_info = 空数组;
		调用子程序(ResetBall);
		设置状态(事件玩家, 无, 定身, 0.250);
		事件玩家.UltimateUsed = 假;
		事件玩家.IsReady = 假;
		事件玩家.sphere_state = 全局.SpherePosition[事件玩家.Level + 1] ? 假 : 真;
		If(事件玩家.sphere_state == 假 && 事件玩家.HintFreq % 5 == 1);
			小字体信息(事件玩家, 自定义字符串("要先拿糖果哦！", 输入绑定字符串(按钮(互动))));
		End;
		禁用 If(事件玩家.HintFreq % 30 == 29);
		禁用 小字体信息(事件玩家, 自定义字符串("卡关了吗?按下互动键（{0}）看看右侧的提示试试?", 输入绑定字符串(按钮(互动))));
		禁用 End;
		事件玩家.HintFreq += 1;
		If(水平速度(事件玩家) >= 6.900);
			设置辅助攻击模式启用(事件玩家, 假);
			设置启用技能 1(事件玩家, 假);
			设置启用技能 2(事件玩家, 假);
			设置启用终极技能(事件玩家, 假);
		End;
		If(事件玩家 == 全局.Pioneer);
			全局.PioneerStarted = 假;
			全局.PioneerLandingPosition = 无;
		End;
		If(!全局.PioneerModeEnabled && 事件玩家.Level == 0);
			停止追踪玩家变量(事件玩家, ScoreOfThisRound);
			事件玩家.ScoreOfThisRound = 0;
		End;
		施加推力(事件玩家, 方向(眼睛位置(事件玩家) + 眼睛位置(事件玩家) * 面朝方向(事件玩家), 所选位置(事件玩家)), 1, 至地图, 取消相反运动);
		等待(0.032, 无视条件);
		If((全局.TeleportWhenEnterNextPosition || 相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius) && 数量(
			全局.CheckpointPosition) != 0);
			传送(事件玩家, 全局.CheckpointPosition[事件玩家.Level]);
		End;
		事件玩家.IsReady = 真;
		If(事件玩家 == 全局.Pioneer);
			全局.PioneerStarted = 真;
		End;
		设置技能冷却(事件玩家, 按钮(辅助攻击模式), 0);
		设置技能冷却(事件玩家, 按钮(技能1), 0);
		设置技能冷却(事件玩家, 按钮(技能2), 0);
		施加推力(事件玩家, 速率(事件玩家) * -1, 0.010, 至地图, 取消相反运动);
		If(全局.UltimateState[事件玩家.Level + 1] != (假 || 0));
			事件玩家.ultimate_info[0] = 全局.CheckpointPosition[事件玩家.Level];
			事件玩家.ultimate_info[1] = 全局.UltimateState[事件玩家.Level + 1];
			事件玩家.ultimate_info[2] = 事件玩家.ultimate_info[0] + 方向(事件玩家.ultimate_info[0], 事件玩家.ultimate_info[1]) * 1000;
			事件玩家.ultimate_info[3] = 与此方向的水平角度(方向(事件玩家.ultimate_info[2], 事件玩家.ultimate_info[0]));
			事件玩家.ultimate_worked = 真;
		Else;
			事件玩家.ultimate_worked = 假;
			事件玩家.ultimate_info = 空数组;
		End;
		If(事件玩家.ultimate_log == 自定义字符串("已开启"));
			事件玩家.ultimate_worked = 真;
		End;
		If(事件玩家.Level < 事件玩家.cheat);
			事件玩家.cheat = 0;
		End;
	}
}

规则("阵亡复位")
{
	事件
	{
		玩家阵亡;
		双方;
		全部;
	}

	条件
	{
		被攻击方.IsSpectating == 假;
	}

	动作
	{
		被攻击方.IsReady = 假;
		If(全局.Pioneer == 事件玩家 && 全局.PioneerLandingPosition == 无);
			全局.PioneerStarted = 假;
		End;
		If(!全局.PioneerModeEnabled && 事件玩家.Level == 0);
			停止追踪玩家变量(被攻击方, ScoreOfThisRound);
			被攻击方.ScoreOfThisRound = 0;
		End;
		被攻击方.FacingDirection = 面朝方向(被攻击方);
		清除状态(被攻击方, 相移);
		设置状态(被攻击方, 无, 相移, 16200);
		等待(0.032, 无视条件);
		If(全局.Pioneer == 事件玩家);
			If(全局.PioneerLandingPosition != 无);
				传送(被攻击方, 全局.PioneerLandingPosition);
			Else;
				传送(被攻击方, 全局.CheckpointPosition[被攻击方.Level]);
			End;
			等待(0.016, 无视条件);
			复生(被攻击方);
		Else;
			If(事件玩家.FreeMode || 事件玩家.GameComplete);
				禁用 小字体信息(事件玩家, 自定义字符串("传送到可行走位置"));
				传送(被攻击方, 最近的可行走位置(所选位置(被攻击方)));
				复活(被攻击方);
			Else If(数量(全局.CheckpointPosition) != 0);
				禁用 小字体信息(事件玩家, 自定义字符串("传送到闯关点"));
				传送(被攻击方, 全局.CheckpointPosition[被攻击方.Level]);
				等待(0.016, 无视条件);
				复生(被攻击方);
			End;
		End;
		等待(0.500, 无视条件);
		设置朝向(被攻击方, 被攻击方.FacingDirection, 至地图);
		禁用 调用子程序(ResetBall);
		被攻击方.IsReady = 真;
		If(全局.Pioneer == 事件玩家 && 全局.PioneerLandingPosition == 无);
			全局.PioneerStarted = 真;
		End;
		调用子程序(ResetBall);
		禁用 If(!(事件玩家.FreeMode || 事件玩家.GameComplete));
		禁用 End;
		禁用 小字体信息(事件玩家, 自定义字符串("重生结束"));
	}
}

规则("[子程序] 对开拓者的提醒")
{
	事件
	{
		子程序;
		MessageCall;
	}

	动作
	{
		大字体信息(事件玩家, 自定义字符串("点位间距必须大于​{0}米​", 2 * 全局.RingRadius));
		等待(3, 无视条件);
	}
}

规则("设置互动键按下状态")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		按钮被按下(全局.Pioneer, 按钮(互动)) == 真;
		全局.PioneerLandingPosition != 无;
	}

	动作
	{
		全局.Pioneer.InteractPressState = 1;
		等待(1, 当为“假”时中止);
		全局.Pioneer.InteractPressState = 2;
	}
}

规则("松开1帧后清除按下状态")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		按钮被按下(全局.Pioneer, 按钮(互动)) == 假;
	}

	动作
	{
		等待(0.016, 无视条件);
		全局.Pioneer.InteractPressState = 0;
	}
}

规则("[热键] 开拓者放置小球")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
		全局.PioneerLandingPosition == 无;
		全局.PioneerSpherePosition == 无;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		事件玩家.pioneer_mode != 自定义字符串("传送点");
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
	}

	动作
	{
		全局.PioneerSpherePosition = 所选位置(事件玩家);
	}
}

规则("[热键] 开拓者确认开拓")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
		全局.PioneerLandingPosition != 无;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		事件玩家.InteractPressState == 2;
	}

	动作
	{
		If(事件玩家.UltimateUsed != (0 || 假) || 事件玩家.ultimate_log == 自定义字符串("已关闭"));
			全局.JumpState[事件玩家.Level] = 事件玩家.pioneer_mode == 自定义字符串("传送点");
			事件玩家.InteractPressState = 0;
			全局.CheckpointPosition[事件玩家.Level + 1] = 全局.PioneerLandingPosition;
			全局.SecondaryFireState[事件玩家.Level] = 事件玩家.SecondaryFireUsed;
			全局.UltimateState[事件玩家.Level + 1] = 事件玩家.UltimateUsed;
			全局.SpherePosition[事件玩家.Level + 1] = 全局.PioneerSpherePosition;
			全局.Creator[事件玩家.Level] = 自定义字符串("{0}", 事件玩家);
			全局.PioneerStarted = 假;
			全局.PioneerLandingPosition = 无;
			全局.PioneerSpherePosition = 无;
			全局.Pioneer = 无;
			小字体信息(所有玩家(所有队伍), 自定义字符串("开拓者已开拓​"));
			事件玩家.Level += 1;
			调用子程序(SetAbility);
		Else;
			事件玩家.InteractPressState = 0;
			全局.PioneerLandingPosition = 无;
			全局.PioneerSpherePosition = 无;
			调用子程序(Reset);
			If(事件玩家.ultimate_log == 自定义字符串("已开启"));
				事件玩家.ultimate_worked = 真;
			Else;
				事件玩家.ultimate_worked = 假;
			End;
			事件玩家.UltimateUsed = 假;
			小字体信息(事件玩家, 自定义字符串("坐标错误"));
		End;
	}
}

规则("[热键] 开拓者取消开拓")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
		全局.PioneerLandingPosition != 无;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		事件玩家.InteractPressState == 1;
	}

	动作
	{
		设置辅助攻击模式启用(事件玩家, 真);
		可用按钮(事件玩家, 按钮(辅助攻击模式));
		事件玩家.InteractPressState = 0;
		全局.PioneerLandingPosition = 无;
		全局.PioneerSpherePosition = 无;
		调用子程序(Reset);
		If(事件玩家.pioneer_mode == 自定义字符串("超级跳"));
			事件玩家.ultimate_worked = 真;
			事件玩家.UltimateUsed = 假;
			小字体信息(事件玩家, 自定义字符串("切换到超级跳开拓模式"));
		Else If(事件玩家.pioneer_mode == 自定义字符串("正常模式"));
			事件玩家.ultimate_worked = 假;
			事件玩家.UltimateUsed = 假;
			小字体信息(事件玩家, 自定义字符串("切换到正常开拓模式"));
		Else If(事件玩家.pioneer_mode == 自定义字符串("传送点"));
			事件玩家.ultimate_worked = 假;
			事件玩家.UltimateUsed = 假;
			小字体信息(事件玩家, 自定义字符串("切换到传送点模式"));
		End;
	}
}

规则("[热键] 删除最后一关")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.PioneerModeEnabled == 真;
		按钮被按下(主机玩家, 按钮(跳跃)) == 真;
		按钮被按下(主机玩家, 按钮(蹲下)) == 真;
	}

	动作
	{
		If(数量(全局.CheckpointPosition) != 0);
			等待(0.500, 当为“假”时中止);
			小字体信息(主机玩家, 自定义字符串("继续长按将清除最后一关​"));
			等待(1.500, 当为“假”时中止);
			修改全局变量(CheckpointPosition, 根据索引从数组中移除, 数量(全局.CheckpointPosition) - 1);
			修改全局变量(Ability1State, 根据索引从数组中移除, 数量(全局.Ability1State) - 1);
			修改全局变量(Ability2State, 根据索引从数组中移除, 数量(全局.Ability2State) - 1);
			修改全局变量(SecondaryFireState, 根据索引从数组中移除, 数量(全局.SecondaryFireState) - 1);
			修改全局变量(UltimateState, 根据索引从数组中移除, 数量(全局.UltimateState) - 1);
			修改全局变量(SpherePosition, 根据索引从数组中移除, 数量(全局.SpherePosition) - 1);
			全局.Pioneer = 最后(全局.Creator);
			修改全局变量(Creator, 根据索引从数组中移除, 数量(全局.Creator) - 1);
			全局.PioneerStarted = 假;
			全局.PioneerLandingPosition = 无;
			If(数量(全局.CheckpointPosition) == 0);
				小字体信息(所有玩家(所有队伍), 自定义字符串("起点已清除​"));
			Else;
				小字体信息(所有玩家(所有队伍), 自定义字符串("最后一关已删除​"));
			End;
		Else;
			小字体信息(所有玩家(所有队伍), 自定义字符串("最后一关已删除​"));
		End;
	}
}

规则("[热键] 重新开始游戏")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		存活(事件玩家) == 真;
	}

	动作
	{
		事件玩家.FreeMode = 假;
		If(事件玩家 == 全局.Pioneer);
			全局.Pioneer = 无;
			全局.PioneerLandingPosition = 无;
			全局.PioneerStarted = 假;
		End;
		事件玩家.Level = 0;
		调用子程序(Reset);
	}
}

规则("[热键] 到上一关")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
	}

	动作
	{
		If(事件玩家.Level > 0);
			事件玩家.Level -= 1;
		End;
		While(全局.JumpState[事件玩家.Level] == 自定义字符串("跳跃点"));
			事件玩家.Level -= 1;
		End;
		If(事件玩家 == 全局.Pioneer);
			全局.Pioneer = 无;
			全局.PioneerLandingPosition = 无;
			全局.PioneerStarted = 假;
		End;
		调用子程序(Reset);
	}
}

规则("[热键] 成为开拓者")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.PioneerModeEnabled == 真;
		事件玩家.GameComplete == 真;
		实体存在(全局.Pioneer) == 假;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		在地面上(事件玩家) == 真;
	}

	动作
	{
		If(全局.DisableContinuousCreation && 事件玩家 == 最后(全局.Creator));
			小字体信息(事件玩家, 自定义字符串("请不要连续开拓​"));
		Else If(数量(全局.CheckpointPosition) == 0);
			If(在重生室中(事件玩家));
				小字体信息(事件玩家, 自定义字符串("请离开重生室​"));
			Else If(在地面上(事件玩家) == 假);
				小字体信息(事件玩家, 自定义字符串("请站在地上设置开拓起点​"));
			Else;
				修改全局变量(CheckpointPosition, 添加至数组, 所选位置(事件玩家));
				修改全局变量(UltimateState, 添加至数组, 假);
				全局.Pioneer = 事件玩家;
			End;
		Else;
			全局.Pioneer = 事件玩家;
		End;
		事件玩家.ultimate_worked = 假;
		事件玩家.ultimate_log = 自定义字符串("已关闭");
		事件玩家.UltimateUsed = 假;
		事件玩家.pioneer_mode = 自定义字符串("正常模式");
		调用子程序(ResetBall);
	}
}

规则("[热键] 死亡观战")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
	}

	动作
	{
		事件玩家.IsSpectating = !事件玩家.IsSpectating;
		If(事件玩家.IsSpectating);
			关闭游戏预设复生模式(事件玩家);
			击杀(事件玩家, 无);
			可用按钮(事件玩家, 按钮(主要攻击模式));
		Else;
			开启游戏预设复生模式(事件玩家);
			复活(事件玩家);
			调用子程序(ResetBall);
		End;
	}
}

禁用 规则("按下互动时 禁用所有按钮")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
	}

	动作
	{
		禁用 禁用按钮(事件玩家, 按钮(技能1));
		禁用 禁用按钮(事件玩家, 按钮(技能2));
		禁用 禁用按钮(事件玩家, 按钮(蹲下));
		禁用 禁用按钮(事件玩家, 按钮(跳跃));
		禁用 禁用按钮(事件玩家, 按钮(近身攻击));
		禁用 禁用按钮(事件玩家, 按钮(主要攻击模式));
		禁用 禁用按钮(事件玩家, 按钮(辅助攻击模式));
		禁用 禁用按钮(事件玩家, 按钮(终极技能));
		设置状态(事件玩家, 无, 定身, 9999);
	}
}

禁用 规则("没按下互动时 可用所有按钮")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 假;
	}

	动作
	{
		禁用 等待(0.500, 当为“假”时中止);
		禁用 可用按钮(事件玩家, 按钮(技能1));
		禁用 可用按钮(事件玩家, 按钮(技能2));
		禁用 可用按钮(事件玩家, 按钮(蹲下));
		禁用 可用按钮(事件玩家, 按钮(跳跃));
		禁用 可用按钮(事件玩家, 按钮(近身攻击));
		禁用 可用按钮(事件玩家, 按钮(主要攻击模式));
		禁用 可用按钮(事件玩家, 按钮(辅助攻击模式));
		禁用 可用按钮(事件玩家, 按钮(终极技能));
		清除状态(事件玩家, 定身);
	}
}

规则("[多行字符串] 快捷键说明")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		If(全局.PioneerModeEnabled);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(互动))), 无, 无, 自定义字符串(
				"重新开始       =  互动 + Q\r\n阵亡观战       =  互动 + E\r\n开关隐身       =  任意表情\r\n到上一关       =  互动 + 蹲\r\n自由移动       =  互动 + 近战\r\n{0}",
				自定义字符串("到下一关       =  蹲 + Q + R\r\n阵亡复位       =  长按Q\r\n切换模式       =  R + 空格")), 左边, 2, 颜色(白色), 颜色(白色), 颜色(黄色), 可见和字符串, 默认可见度);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(全局.Pioneer, 按钮(互动)) == 真), 自定义字符串("开拓时非触地状态下按左键放置小球", 全局.Pioneer.pioneer_mode), 无, 无, 左边, 3, 颜色(
				红色), 颜色(白色), 颜色(红色), 可见和字符串, 默认可见度);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(全局.Pioneer, 按钮(互动)) == 真), 自定义字符串(
				"超级跳开拓模式下抓钩只能在起点启用\r\n否则出圈以后会被禁用,禁止起跳前腾空\r\n出圈后在起跳前需须保持高速移动（火球）\r\n请保持起点和紫色圈形成两点一线,遇到\r\n坐标错误就是没有紫圈,重新开拓就行\r\nR+跳=切换开拓模式。当前模式：{0}",
				全局.Pioneer.pioneer_mode), 无, 无, 左边, 4, 颜色(亮紫色), 颜色(白色), 颜色(红色), 可见和字符串, 默认可见度);
		Else;
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(互动))), 无, 无, 自定义字符串(
				"重新开始       =  互动 + Q\r\n阵亡观战       =  互动 + E\r\n开关隐身       =  任意表情\r\n到上一关       =  互动 + 蹲\r\n自由移动       =  互动 + 近战\r\n{0}",
				自定义字符串("到下一关       =  蹲 + Q + R\r\n阵亡复位       =  长按Q")), 左边, 2, 颜色(白色), 颜色(白色), 颜色(黄色), 可见和字符串, 默认可见度);
		End;
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(互动))), 自定义字符串("自由模式或开拓者传送点模式下按左键可以向前移动"), 无, 无, 左边, 10, 颜色(红色), 颜色(白色), 颜色(黄色), 可见和字符串,
			默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 按钮被按下(当前数组元素, 按钮(互动))), 自定义字符串(
			"超级跳:钩住一个可以让自身加速的位置,在到达紫圈前松钩并保证速度已达最大(火焰效果),在紫色圈内瞬间起跳。\r\n原理:起跳正确的情况下高速撞击大角度斜面会获得上升动力。\r\nTIPS:紫圈圆心即为最佳起跳位\nNotice:到达紫圈前不可离地!起飞时必须松钩!"),
			无, 无, 顶部, 10, 颜色(天蓝色), 颜色(白色), 颜色(黄色), 可见和字符串, 默认可见度);
	}
}

规则("通关或自由模式下无CD")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 != 全局.Pioneer;
		(事件玩家.GameComplete || 事件玩家.FreeMode) == 真;
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) + 技能冷却时间(事件玩家, 按钮(技能1)) + 技能冷却时间(事件玩家, 按钮(技能2)) != 0;
	}

	动作
	{
		设置技能冷却(事件玩家, 按钮(辅助攻击模式), 0);
		设置技能冷却(事件玩家, 按钮(技能1), 0);
		设置技能冷却(事件玩家, 按钮(技能2), 0);
	}
}

规则("祝大家玩得愉快~")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		地图工坊设置开关(自定义字符串("快捷键"), 自定义字符串("跳关"), 真, 0) == 真;
	}

	动作
	{
		事件玩家.Level += 1;
		If(事件玩家.cheat == 0);
			事件玩家.cheat = 事件玩家.Level;
		End;
		事件玩家.HintFreq = 0;
		If(全局.CheatRecord);
			If(数量(全局.cheat_log) == 0);
				全局.cheat_log[0] = 自定义字符串("{0}玩家{1}采用取巧的方式过了第{2}关", 英雄图标字符串(英雄(破坏球)), 事件玩家, 事件玩家.Level);
			Else;
				修改全局变量(cheat_log, 添加至数组, 自定义字符串("{2}玩家{0}采用取巧的方式过了第{1}关", 事件玩家, 事件玩家.Level, 英雄图标字符串(英雄(破坏球))));
			End;
		End;
		等待(1, 当为“假”时中止);
		While(按钮被按下(事件玩家, 按钮(蹲下)) == 真 && 按钮被按下(事件玩家, 按钮(终极技能)) == 真 && 按钮被按下(事件玩家, 按钮(装填)) == 真);
			事件玩家.Level += 1;
			If(全局.CheatRecord);
				修改全局变量(cheat_log, 添加至数组, 自定义字符串("{2}玩家{0}采用取巧的方式过了第{1}关", 事件玩家, 事件玩家.Level, 英雄图标字符串(英雄(破坏球))));
			End;
			等待(0.100, 无视条件);
		End;
	}
}

规则("[热键]开拓者切换模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		地图工坊设置开关(自定义字符串("快捷键"), 自定义字符串("超级跳模式开拓"), 真, 1) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) < 全局.RingRadius[1];
	}

	动作
	{
		If(事件玩家.pioneer_mode == 自定义字符串("正常模式"));
			事件玩家.pioneer_mode = 自定义字符串("超级跳");
			事件玩家.ultimate_log = 自定义字符串("已开启");
			事件玩家.ultimate_worked = 真;
			小字体信息(事件玩家, 自定义字符串("切换到超级跳开拓模式"));
		Else If(事件玩家.pioneer_mode == 自定义字符串("超级跳"));
			事件玩家.pioneer_mode = 自定义字符串("传送点");
			事件玩家.ultimate_log = 自定义字符串("已关闭");
			事件玩家.ultimate_worked = 假;
			小字体信息(事件玩家, 自定义字符串("切换到传送点模式"));
			事件玩家.ultimate_info = 空数组;
		Else If(事件玩家.pioneer_mode == 自定义字符串("传送点"));
			事件玩家.pioneer_mode = 自定义字符串("正常模式");
			小字体信息(事件玩家, 自定义字符串("切换到正常模式"));
		End;
	}
}

规则("开拓者超级跳")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.ultimate_worked == 真;
		禁用 正在使用辅助武器(事件玩家) == 假;
		禁用 相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 6;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		垂直速度(事件玩家) != 0;
		事件玩家 == 全局.Pioneer;
		水平速度(事件玩家) > 12;
	}

	动作
	{
		If(相距距离(全局.CheckpointPosition[事件玩家.Level], 所选位置(事件玩家)) > 6);
			事件玩家.ultimate_info = 空数组;
			设置辅助攻击模式启用(事件玩家, 假);
			事件玩家.pioneer_outline_countdown = 50;
			事件玩家.UltimateUsed = 所选位置(事件玩家);
			事件玩家.ultimate_worked = 假;
			While(Y方向分量(所选位置(事件玩家)) - Y方向分量(事件玩家.UltimateUsed) <= 3 && 事件玩家.pioneer_outline_countdown >= 1);
				等待(0.020, 无视条件);
				事件玩家.pioneer_outline_countdown -= 1;
			End;
			If(事件玩家.pioneer_outline_countdown < 1);
				施加推力(事件玩家, 速率(事件玩家) * -1, 0.010, 至地图, 取消相反运动);
				设置状态(事件玩家, 无, 冰冻, 0.500);
				传送(事件玩家, 全局.CheckpointPosition[事件玩家.Level]);
				等待(0.250, 无视条件);
				事件玩家.ultimate_worked = 真;
				事件玩家.UltimateUsed = 假;
				事件玩家.InteractPressState = 0;
				全局.PioneerLandingPosition = 无;
			End;
		Else;
			大字体信息(事件玩家, 自定义字符串("点位间距必须大于​{0}米​", 6));
		End;
	}
}

规则("防止乱跑")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		禁用 全局.Pioneer != 事件玩家;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		事件玩家.ultimate_worked == 真;
		垂直速度(事件玩家) > 0;
		相距距离(所选位置(事件玩家), 全局.UltimateState[事件玩家.Level + 1]) > 全局.RingRadius;
		事件玩家.GameComplete == 假;
		事件玩家.FreeMode == 假;
	}

	动作
	{
		等待(0.200, 当为“假”时中止);
		设置状态(事件玩家, 无, 定身, 0.500);
		调用子程序(Reset);
		禁用 大字体信息(事件玩家, 自定义字符串("不要乱跑"));
	}
}

规则("超级跳")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.ultimate_worked == 真;
		正在使用辅助武器(事件玩家) == 假;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		垂直速度(事件玩家) > 5;
		禁用 事件玩家.ultimate_info[4] == 真;
		事件玩家 != 全局.Pioneer;
		相距距离(所选位置(事件玩家), 全局.UltimateState[事件玩家.Level + 1]) <= 全局.RingRadius[2];
	}

	动作
	{
		事件玩家.ultimate_worked = 假;
		禁用 设置辅助攻击模式启用(事件玩家, 假);
	}
}

规则("两点一线检测")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"宽度是最下面那个值"
		与此方向的水平角度(方向(事件玩家.ultimate_info[2], 所选位置(事件玩家))) < 事件玩家.ultimate_info[3] + 0.350;
		"宽度是最下面那个值"
		与此方向的水平角度(方向(事件玩家.ultimate_info[2], 所选位置(事件玩家))) > 事件玩家.ultimate_info[3] - 0.350;
		"这是长度"
		相距距离(事件玩家.ultimate_info[2], 所选位置(事件玩家)) <= 相距距离(事件玩家.ultimate_info[2], 事件玩家.ultimate_info[0]) + 2;
		"这是长度"
		相距距离(事件玩家.ultimate_info[2], 所选位置(事件玩家)) >= 相距距离(事件玩家.ultimate_info[2], 事件玩家.ultimate_info[1]) - 2;
		全局.UltimateState[事件玩家.Level + 1] != (假 || 0);
		事件玩家.FreeMode == 假;
	}

	动作
	{
		事件玩家.ultimate_outline_countdown = 2;
		等待(0.050, 当为“假”时中止);
		如条件为”真“则循环;
	}
}

规则("超出两点一线范围")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.ultimate_outline_countdown > 0;
		事件玩家.FreeMode == 假;
		事件玩家 != 全局.Pioneer;
	}

	动作
	{
		事件玩家.ultimate_outline_countdown -= 1;
		等待(0.100, 无视条件);
		如条件为”真“则循环;
		If((全局.UltimateState[事件玩家.Level + 1] && 事件玩家.ultimate_worked) != 假);
			设置状态(事件玩家, 无, 定身, 0.500);
			大字体信息(事件玩家, 自定义字符串("不要乱跑"));
			调用子程序(Reset);
		End;
	}
}

规则("超级跳模式圈外低速复位")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		水平速度(事件玩家) <= 12;
		正在使用辅助武器(事件玩家) == 假;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		事件玩家.FreeMode == 假;
		(全局.Pioneer != 事件玩家 ? 事件玩家.GameComplete == 假 : 真) == 真;
		在地面上(事件玩家) == 真;
		(事件玩家.ultimate_worked == 假 ? 全局.UltimateState[事件玩家.Level + 1] != (假 || 0) : 真) == 真;
	}

	动作
	{
		等待(0.016, 当为“假”时中止);
		调用子程序(Reset);
	}
}

规则("超级跳模式出圈禁用抓钩")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		事件玩家.ultimate_worked == 真;
		正在使用辅助武器(事件玩家) == 假;
		事件玩家.FreeMode == 假;
		禁用 事件玩家.GameComplete == 假;
		(全局.Pioneer != 事件玩家 ? 事件玩家.GameComplete == 假 : 真) == 真;
	}

	动作
	{
		设置辅助攻击模式启用(事件玩家, 假);
	}
}

规则("防止起步在空中")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.ultimate_log == 自定义字符串("已开启");
		正在空中(事件玩家) == 真;
		事件玩家 == 全局.Pioneer;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		事件玩家.FreeMode == 假;
		事件玩家.UltimateUsed == 假;
	}

	动作
	{
		等待(0.200, 无视条件);
		根据条件中止(事件玩家.ultimate_worked == 假);
		小字体信息(事件玩家, 自定义字符串("{0}你想原地起飞？", 英雄图标字符串(英雄(破坏球))));
		调用子程序(Reset);
	}
}

规则("开拓者两点一线写入")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.Pioneer == 事件玩家;
		禁用 事件玩家.ultimate_log == 自定义字符串("已开启");
		禁用 事件玩家.FreeMode == 假;
		事件玩家.ultimate_worked == 真;
		事件玩家.ultimate_info == 空数组;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 5;
	}

	动作
	{
		禁用 If(相距距离(全局.CheckpointPosition[事件玩家.Level], 所选位置(事件玩家)) > 3);
		事件玩家.ultimate_info[0] = 全局.CheckpointPosition[事件玩家.Level];
		事件玩家.ultimate_info[1] = 所选位置(事件玩家);
		事件玩家.ultimate_info[2] = 事件玩家.ultimate_info[0] + 方向(事件玩家.ultimate_info[0], 事件玩家.ultimate_info[1]) * 1000;
		事件玩家.ultimate_info[3] = 与此方向的水平角度(方向(事件玩家.ultimate_info[2], 事件玩家.ultimate_info[0]));
		禁用 Else;
		禁用 事件玩家.ultimate_info = 空数组;
		禁用 End;
	}
}

规则("开拓者两点一线清除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.Pioneer == 事件玩家;
		禁用 事件玩家.ultimate_log == 自定义字符串("已开启");
		事件玩家.FreeMode == 假;
		禁用 事件玩家.ultimate_worked == 假;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) <= 5;
	}

	动作
	{
		事件玩家.ultimate_info = 空数组;
	}
}

规则("开拓者两点一线检测")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"宽度是最下面那个值"
		与此方向的水平角度(方向(事件玩家.ultimate_info[2], 所选位置(事件玩家))) < 事件玩家.ultimate_info[3] + 0.300;
		"宽度是最下面那个值"
		与此方向的水平角度(方向(事件玩家.ultimate_info[2], 所选位置(事件玩家))) > 事件玩家.ultimate_info[3] - 0.300;
		"这是长度"
		禁用 相距距离(事件玩家.ultimate_info[2], 所选位置(事件玩家)) <= 相距距离(事件玩家.ultimate_info[2], 事件玩家.ultimate_info[0]) + 2;
		"这是长度"
		禁用 相距距离(事件玩家.ultimate_info[2], 所选位置(事件玩家)) >= 相距距离(事件玩家.ultimate_info[2], 事件玩家.ultimate_info[1]) - 2;
		事件玩家.FreeMode == 假;
		事件玩家.ultimate_log == 自定义字符串("已开启");
		事件玩家 == 全局.Pioneer;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 5;
	}

	动作
	{
		禁用 事件玩家.ultimate_outline_countdown = 2;
		禁用 等待(0.050, 当为“假”时中止);
		禁用 如条件为”真“则循环;
		等待(0.500, 无视条件);
		如条件为”真“则循环;
		根据条件中止(事件玩家.ultimate_info == 空数组);
		根据条件中止(事件玩家.ultimate_worked == 假);
		播放效果(事件玩家, 负面状态施加声音, 颜色(白色), 事件玩家, 30);
		大字体信息(事件玩家, 自定义字符串("{0}球球你做个人吧", 英雄图标字符串(英雄(破坏球))));
		事件玩家.ultimate_info = 空数组;
		调用子程序(Reset);
	}
}

规则("当玩家离开比赛")
{
	事件
	{
		玩家离开比赛;
		双方;
		全部;
	}

	动作
	{
		消除效果(事件玩家.BestScore[0]);
		消除效果(事件玩家.BestScore[1]);
		消除地图文本(事件玩家.BestScore[2]);
		消除效果(事件玩家.BestScore[3]);
		消除效果(事件玩家.BestScore[4]);
		消除地图文本(事件玩家.BestScore[5]);
	}
}

规则("【热键】位移")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		(事件玩家.FreeMode || (事件玩家.GameComplete && 全局.Pioneer != 事件玩家) || (全局.Pioneer == 事件玩家 && 事件玩家.pioneer_mode == 自定义字符串("传送点"))) == 真;
		事件玩家.IsSpectating == 假;
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		传送(事件玩家, 所选位置(事件玩家) + 面朝方向(事件玩家) * 5);
		设置引力(事件玩家, 0);
		While(按钮被按下(事件玩家, 按钮(主要攻击模式)));
			传送(事件玩家, 所选位置(事件玩家) + 面朝方向(事件玩家) * 0.500);
			施加推力(事件玩家, 速率(事件玩家) * -1, 0.010, 至地图, 取消相反运动);
			等待(0.010, 当为“真”时重新开始);
		End;
		设置引力(事件玩家, 100);
	}
}

规则("【热键】杀死玩家")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
	}

	动作
	{
		等待(0.500, 当为“假”时中止);
		击杀(事件玩家, 无);
	}
}

规则("变成球")
{
	事件
	{
		子程序;
		ResetBall;
	}

	动作
	{
		While(!正在使用技能 1(事件玩家));
			事件玩家.IsReady = 假;
			设置启用技能 1(事件玩家, 真);
			可用按钮(事件玩家, 按钮(技能1));
			等待(0.250, 无视条件);
			按下按键(事件玩家, 按钮(技能1));
			禁用 小字体信息(事件玩家, 自定义字符串("激活动力铁球"));
			等待直到 (正在使用技能 1(事件玩家), 0.500);
			事件玩家.IsReady = 真;
		End;
		If(!(事件玩家.FreeMode || 事件玩家.GameComplete) || 事件玩家 == 全局.Pioneer);
			禁用按钮(事件玩家, 按钮(技能1));
		End;
		禁用 小字体信息(事件玩家, 自定义字符串("ResetBallEnd"));
	}
}

规则("开关隐身")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在使用表情交流(事件玩家) == 真;
	}

	动作
	{
		事件玩家.Invisible = !事件玩家.Invisible;
		If(事件玩家.Invisible);
			设置不可见(事件玩家, 全部);
			大字体信息(事件玩家, 自定义字符串("开启隐身​"));
		Else;
			大字体信息(事件玩家, 自定义字符串("关闭隐身​"));
			设置不可见(事件玩家, 全部禁用);
		End;
	}
}

规则("跑酷模式计时开始")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.PioneerModeEnabled == 假;
		事件玩家.FreeMode == 假;
		事件玩家.IsReady == 真;
		事件玩家.GameComplete == 假;
		相距距离(所选位置(事件玩家), 首个(全局.CheckpointPosition)) > 全局.RingRadius;
		已重生(事件玩家) == 真;
	}

	动作
	{
		If(事件玩家.Level == 0);
			停止追踪玩家变量(事件玩家, ScoreOfThisRound);
			事件玩家.ScoreOfThisRound = 0;
		End;
		追踪玩家变量频率(事件玩家, ScoreOfThisRound, 16200, 1, 全部禁用);
	}
}

规则("[热键] 开关自由模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		在地面上(事件玩家) == 真;
	}

	动作
	{
		等待(0.500, 当为“真”时重新开始);
		事件玩家.FreeMode = !事件玩家.FreeMode;
		事件玩家.HintFreq = 0;
		If(事件玩家.FreeMode);
			修改全局变量(Pioneer, 根据值从数组中移除, 事件玩家);
			小字体信息(事件玩家, 自定义字符串("自由移动​"));
			调用子程序(SetAbility);
			If(事件玩家.ScoreOfThisRound != 0);
				停止追踪玩家变量(事件玩家, ScoreOfThisRound);
			End;
		Else;
			小字体信息(事件玩家, 自定义字符串("关闭自由移动​"));
			调用子程序(Reset);
			If(事件玩家.ScoreOfThisRound != 0 && !事件玩家.GameComplete);
				追踪玩家变量频率(事件玩家, ScoreOfThisRound, 16200, 1, 全部禁用);
			End;
		End;
	}
}

规则("设置主要攻击模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		设置主要攻击模式启用(事件玩家, 假);
	}
}

规则("设置主要攻击模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 假;
		(事件玩家.FreeMode || 事件玩家.GameComplete) == 真;
	}

	动作
	{
		设置主要攻击模式启用(事件玩家, 真);
	}
}

规则("验证玩家数据 ValidationPlayerData")
{
	事件
	{
		子程序;
		ValidationPlayerData;
	}

	动作
	{
		"如果数组中有玩家数据, 则将值赋给事件玩家 checkpoint, time, mistake, cheat"
		If(对任意为”真“(全局.PlayersData, 当前数组元素[0] == 自定义字符串("{0}", 事件玩家)));
			事件玩家.Level = 已过滤的数组(全局.PlayersData, 当前数组元素[0] == 自定义字符串("{0}", 事件玩家))[0][1];
			事件玩家.ScoreOfThisRound = 已过滤的数组(全局.PlayersData, 当前数组元素[0] == 自定义字符串("{0}", 事件玩家))[0][2];
			事件玩家.mistake = 已过滤的数组(全局.PlayersData, 当前数组元素[0] == 自定义字符串("{0}", 事件玩家))[0][3];
			事件玩家.cheat = 已过滤的数组(全局.PlayersData, 当前数组元素[0] == 自定义字符串("{0}", 事件玩家))[0][4];
			事件玩家.dataIndex = 数组值的索引(全局.PlayersData, 已过滤的数组(全局.PlayersData, 当前数组元素[0] == 自定义字符串("{0}", 事件玩家))[0]) / 5;
		"反之, 将 玩家昵称, checkpoint, time, mistake, cheat 组成数组 添加到末尾索引"
		Else;
			事件玩家.dataIndex = 数量(全局.PlayersData);
			全局.PlayersData[数量(全局.PlayersData)] = 数组(自定义字符串("{0}", 事件玩家), 事件玩家.Level, 事件玩家.ScoreOfThisRound, 事件玩家.mistake, 事件玩家.cheat);
		End;
	}
}

规则("编辑玩家数据 EditPlayerData")
{
	事件
	{
		子程序;
		EditPlayerData;
	}

	动作
	{
		全局.PlayersData[事件玩家.dataIndex] = 事件玩家.Level < 数量(全局.CheckpointPosition) - 1 ? 数组(自定义字符串("{0}", 事件玩家), 事件玩家.Level,
			事件玩家.ScoreOfThisRound, 事件玩家.mistake, 事件玩家.cheat) : 数组(自定义字符串("{0}", 事件玩家), 0, 0, 0, 0);
	}
}