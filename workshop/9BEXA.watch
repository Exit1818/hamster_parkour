设置
{
	主程序
	{
		描述: "热火街区生存战（修改版） - 原版(4ACNY) - 为了生存来面对一群残酷的敌人。通过解救英雄来获得支援。你们的敌人在数量上明显占据优势，并在逐步缩小对你们的搜捕圈。你能存活过所有回合的敌人吗？游戏模式的AI可以扮演19种不同的英雄，而且有些英雄拥有新的技能。本PvE模式适合1到5个玩家进行游戏。v2.5.0A 由Shingen制作。更多详情请访问 https://workshop.codes/TRRJN。原始模式：workshop.co"
		模式名称: "PVE热火街区"
	}

	大厅
	{
		玩家上限 队伍1: 0
		玩家上限 队伍2: 5
		观战者人数上限: 12
		返回大厅: 从不
	}

	模式
	{
		团队死斗
		{
			启用地图
			{
				万圣节吉拉德堡
				万圣节好莱坞
				吉拉德堡
				国王大道
				圣诞节国王大道
				圣诞节生态监测站：南极洲
				好莱坞
				生态监测站：南极洲
				铁坂
			}
		}

		综合
		{
			急救包刷新: 禁用
			消灭提示: 关闭
			消灭镜头: 关闭
			游戏模式开始: 即时
			英雄限制: 关闭
			获胜得分: 22
		}
	}

	英雄
	{
		队伍1
		{
			伤害量: 200%
			生命值: 200%

			半藏
			{
				“岚”数量: 12
				“跃”冷却时间: 0%
				伤害量: 30%
				岚 冷却时间: 0%
				弹道速度: 150%
				生命值: 500%
			}

			卡西迪
			{
				伤害量: 12%
				战术翻滚 冷却时间: 0%
				生命值: 75%
				闪光弹 冷却时间: 0%
			}

			回声
			{
				伤害量: 22%
				聚焦光线 冷却时间: 0%
				飞行 冷却时间: 0%
				黏性炸弹 冷却时间: 0%
			}

			堡垒
			{
				伤害量: 20%
				生命值: 500%
				终极技能持续时间无限: 开启
			}

			士兵：76
			{
				伤害量: 20%
				生命值: 75%
				螺旋飞弹 冷却时间: 0%
			}

			奥丽莎
			{
				伤害量: 16%
				受到伤害量: 50%
				受到治疗量: 50%
				强固防御 冷却时间: 0%
				生命值: 90%
				站住别动 冷却时间: 0%
			}

			巴蒂斯特
			{
				伤害量: 14%
				弹道速度: 0%
				愈合冲击 冷却时间: 0%
				投射物重力: 500%
				生命值: 125%
				维生力场 冷却时间: 0%
			}

			布丽吉塔
			{
				伤害量: 22%
				屏障护盾 冷却时间: 0%
				屏障护盾充能速度: 500%
				流星飞锤 冷却时间: 0%
				生命值: 80%
				能量盾击: 关闭
			}

			托比昂
			{
				伤害量: 20%
				受到伤害量: 18%
				弹道速度: 150%
				投射物重力: 250%
				生命值: 500%
			}

			末日铁拳
			{
				伤害量: 40%
				毁天灭地击退倍率: 125%
				移动速度: 300%
				终极技能持续时间: 500%
				重生时终极技能充能完毕: 开启
			}

			死神
			{
				伤害量: 17%
				幽灵形态 冷却时间: 0%
				生命值: 140%
			}

			法老之鹰
			{
				伤害量: 35%
				悬浮背包充能速度: 250%
				悬浮背包垂直速度: 60%
				悬浮背包最长时间: 250%
				推进背包加速: 60%
				生命值: 80%
			}

			源氏
			{
				伤害量: 30%
				影 冷却时间: 0%
				生命值: 500%
				终极技能持续时间无限: 开启
				闪 冷却时间: 0%
			}

			猎空
			{
				伤害量: 16%
				弹道速度: 0%
				投射物重力: 500%
				生命值: 110%
				闪现 冷却时间: 150%
			}

			破坏球
			{
				伤害量: 35%
				动力铁球始终激活: 开启
				工程抓钩击退距离: 150%
				弹道速度: 149%
				生命值: 120%
				移动速度: 60%
				终极技能持续时间无限: 开启
			}

			秩序之光
			{
				伤害量: 15%
				哨戒炮 冷却时间: 0%
				生命值: 65%
				移动速度: 120%
			}

			美
			{
				伤害量: 40%
				冰霜枪冰冻敌人的时长: 50%
				冰霜枪冰冻敌人的速度: 50%
				受到伤害量: 80%
				弹夹容量倍率: 200%
				暴雪冰冻最小值: 40%
				生命值: 125%
			}

			莱因哈特
			{
				伤害量: 27%
				冲锋 冷却时间: 0%
				受到伤害量: 40%
				受到治疗量: 40%
				屏障力场充能速度: 0%
				弹道速度: 150%
				烈焰打击 冷却时间: 0%
				生命值: 150%
			}

			西格玛
			{
				伤害量: 32%
				动能俘获 冷却时间: 0%
				受到伤害量: 65%
				受到治疗量: 65%
				生命值: 85%
				质量吸附 冷却时间: 0%
			}

			路霸
			{
				伤害量: 26%
				生命值: 75%
				链钩 冷却时间: 0%
			}

			黑影
			{
				伤害量: 20%
				位移传动 冷却时间: 0%
				投射物重力: 0%
				隐秘潜行 冷却时间: 0%
			}

			黑百合
			{
				伤害量: 30%
				剧毒诡雷 冷却时间: 0%
				生命值: 115%
			}
		}

		队伍2
		{
			伤害量: 75%
			终极技能充能速度: 75%

			半藏
			{
				“岚”数量: 6
			}

			安娜
			{
				麻醉镖 冷却时间: 60%
			}

			布丽吉塔
			{
				恢复包 冷却时间: 40%
			}

			狂鼠
			{
				震荡地雷 冷却时间: 40%
			}

			猎空
			{
				闪现 冷却时间: 40%
			}

			破坏球
			{
				工程抓钩 冷却时间: 40%
				工程抓钩击退距离: 150%
				生命值: 120%
			}

			秩序之光
			{
				哨戒炮 冷却时间: 40%
			}
		}

		综合
		{
			技能冷却时间: 80%
			终极技能持续时间: 250%
		}
	}
}

变量
{
	全局:
		1: Wave
		2: Spawns_remaining
		3: Boss_Spawns_remaining
		4: Gamemode
		5: Upgrade_Counter
		6: HR_Wave_Start
		7: HR_Hostage_Hero_Array
		8: IV_Objective_Position
		9: IV_Portal_Status
		10: IV_HVT_Objective_Timer
		11: IV_HVT_Spawn_Slot_Six
		12: IV_HVT_Boss_Spawns_blocked_until
		13: IV_HVT_Damage_Mods
		14: HVT_Times_Subdued
		15: HVT_Call_Reinforcements1
		16: Is_Infrasight_on_Players1
		17: Is_Infrasight_on_Bots1
		18: Combatants
		19: Combatants_Count
		20: Progress_Bar
		21: Game_Start_HUD
		22: Mutator_Start_HUD
		23: Temp
		24: Player_Spawn
		25: Player_Spawn_Facing
		26: Ability_Buy_Location
		27: Buy_Menu_Left_Up_Forward
		28: Buy_Menu_Cam_Pos
		29: Buy_Menu_Pos
		30: Spawns
		31: Spawns_Nearest_Nodes_by_Index
		32: Nodes
		33: Nodes_Count
		34: Edges
		35: Distance_Matrix
		36: Elevator_Nodes
		37: Char_Array
		38: Max_Speed_Bonus
		39: Objective_Spawns
		40: Aim_Offset
		41: Called_Incoming
		42: Mutator_Activation_locked
		43: Mutators_activated
		44: Money
		45: Current_Perks
		46: Current_Perks_HUDs
		47: Bad_Mutators
		48: GMut_Storm_Raging
		49: GMut_Close_Quarters
		50: GMut_Keep_your_Distance
		51: GMut_Fortified
		52: Mut_Amped
		53: Mut_Extended_Arsenal
		54: Mut_The_Cavalry
		55: Mut_Regeneration
		56: Mut_Combat_Medic
		57: Mut_EMP_Rounds
		58: Mut_Death_Guard
		59: Mut_Deep_Wounds
		60: Mut_Hurt_Me_More
		61: Mut_Last_Stand
		62: Mut_Last_Stand_active
		63: Mut_Advanced_Medkit
		64: Mut_Reinforcements
		65: Mut_Mutation
		66: Mut_Promotion
		81: Mut_Meteor_Shower
		82: Mut_Adrenaline
		83: Mut_Deathbed
		84: Mut_Partners_In_Crime
		85: Mut_Glass_Cannon
		87: GMut_Blood_Moon_Rising

	玩家:
		0: Ab_Player
		1: Ab_Var_1
		2: Ab_Var_2
		3: Ab_Var_3
		4: Last_Damage_taken
		5: Is_Combatant
		6: Downed_since
		7: Revive_Timer
		8: Tased_until
		9: Is_flying
		10: Is_invisible
		11: Spectated_Player
		12: Death_Cam_Target
		13: Is_changing_Heroes
		14: In_Buy_Menu_Since
		15: Money_spent
		16: Is_using_Combat_Pathfinding
		17: Nav
		18: Nav_Index
		19: Nav_is_reachable_Node
		20: Last_Nav_Update
		21: Last_Time_at_Node
		22: Pos_1
		23: Pos_2
		24: Last_Jump
		25: Primary_Speed
		26: Is_Wraith
		27: Is_Ranged_Hero
		28: Allow_Flinch
		29: Can_Quick_Melee
		30: Is_Target_in_LOS
		31: Target
		32: Target_Last_Pos_seen
		33: Level
		34: Is_Living_Boss
		35: Has_Spawn_Speed_Bonus
		36: Is_assaulting
		37: Can_respawn_after
		38: Feared_until
		39: Is_mutated
		40: GMut_Var
		41: Last_Knockback_received
		42: Last_Time_hit_by_Shatter
		43: Ab_String
		44: Ab_Headhunter
		45: Ab_Quick_Fix
		46: Ab_Charged
		47: Ab_Heavy_Impact
		48: Ab_Second_Wind
		49: Ab_Binding_Heal
		50: Ab_Resilience
		51: Ab_Ambush
		52: Ab_Haste
		53: Ab_Priority
		54: Ab_Health_Bonus
		55: Ab_Damage_Bonus
		56: Ab_Healing_Bonus
		57: Perk_Shockproof
		58: Perk_Bulletstorm
		59: Perk_Die_Hard
		60: Perk_Pumping_Iron
		61: Perk_Terrify
		62: Perk_Running_Riot
		63: Perk_Up_You_Go
		64: Perk_Stabilizer
		65: Perk_Nemesis
		66: Nemesis_Killer
		67: Perk_Mystery_Swap
		68: Perk_Heavy_Weight
		69: Perk_Sharpshooter
		80: Hero_Of
		81: Talent_Active_1
		82: Talent_Active_2
		83: CPerk_Nimble
		84: Talent_Text123_456
		85: Damage_Dealt
		86: Damage_Received
		87: Move_Speed
		88: Modification_Damage
		90: Gen_Projectile1
		91: Gen_Projectile2
		92: Gen_Position
		93: Gen_End
		94: Gen_Active
		95: Gen_Player
		96: Gen_Resource
		97: Gen_Countdown
		98: Effects
		100: Gen_Available
		101: RealSpawn
		102: HP_Pool
		103: Max_HP
		104: Gen_Direction
		105: Chain_Reaction_On
		106: Chain_Reaction_Immune
		107: Healing_Dealt
		108: Storm_EndPoint
		109: Storm_Projectile
		110: Storm_Effects
		111: HealOvertime_ID
}

子程序
{
	0: Update_Combatants
	1: Scale_Damage
	2: Declare_Victory
	3: Teleport_to_free_Spawn
	4: NWP_Teleport
	5: Find_Chase_Target
	6: Roam
	7: Find_NWP_near_Nav
	8: IV_Defend_Portal
	9: Set_Random_Perks
	10: MUT_Add_Mutator
	11: Leave_Buy_Menu
	12: After_Buying_Ability
	13: Set_Map_KR
	15: Set_Map_EA
	16: Set_Map_CG
	18: Set_Map_HW
	19: Set_Map_KZ
}

规则("Made by Shingen#21859, modified by LemonAid#11644. You are allowed to use my code")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		禁用查看器录制;
	}
}

规则("Global (Init): Set Workshop Vars, Game Vars, Disable Game Components, Create Game Entities")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.Gamemode = 空数组;
		If(地图工坊设置开关(自定义字符串("启用的游戏模式"), 自定义字符串("英雄解救"), 真, 0));
			修改全局变量(Gamemode, 添加至数组, 0);
		End;
		If(地图工坊设置开关(自定义字符串("启用的游戏模式"), 自定义字符串("入侵"), 真, 1));
			修改全局变量(Gamemode, 添加至数组, 1);
		End;
		If(地图工坊设置开关(自定义字符串("启用的游戏模式"), 自定义字符串("高价值目标"), 真, 2));
			修改全局变量(Gamemode, 添加至数组, 2);
		End;
		If(全局.Gamemode == 空数组);
			全局.Gamemode = 随机整数(0, 2);
		Else;
			全局.Gamemode = 数组随机取值(全局.Gamemode);
		End;
		关闭游戏预设完成条件;
		关闭游戏预设计分模式;
		关闭游戏预设音乐模式;
		关闭游戏预设通告模式;
		全局.Progress_Bar = 数组(自定义字符串("□□□□□"), 自定义字符串("▣□□□□"), 自定义字符串("■□□□□"), 自定义字符串("■▣□□□"), 自定义字符串("■■□□□"), 自定义字符串("■■▣□□"), 自定义字符串(
			"■■■□□"), 自定义字符串("■■■▣□"), 自定义字符串("■■■■□"), 自定义字符串("■■■■▣"), 自定义字符串("■■■■■"));
		全局.Char_Array = 数组(自定义字符串("0"), 自定义字符串("1"), 自定义字符串("2"), 自定义字符串("3"), 自定义字符串("4"), 自定义字符串("5"), 自定义字符串("6"), 自定义字符串("7"), 自定义字符串(
			"8"), 自定义字符串("9"), 自定义字符串("!"), 自定义字符串("?"), 自定义字符串("#"), 自定义字符串("$"), 自定义字符串("%"));
		设置队伍分数(队伍1, 22);
		全局.Aim_Offset = 0.500 * 下;
		全局.Bad_Mutators[20] = 0;
		全局.Bad_Mutators = 映射的数组(全局.Bad_Mutators, 当前数组索引);
		"Initialize Map Specific Variables"
		If(当前地图 == 地图(国王大道) || 当前地图 == 地图(圣诞节国王大道));
			调用子程序(Set_Map_KR);
		Else If(当前地图 == 地图(生态监测站：南极洲) || 当前地图 == 地图(圣诞节生态监测站：南极洲));
			调用子程序(Set_Map_EA);
		Else If(当前地图 == 地图(吉拉德堡) || 当前地图 == 地图(万圣节吉拉德堡));
			调用子程序(Set_Map_CG);
		Else If(当前地图 == 地图(好莱坞) || 当前地图 == 地图(万圣节好莱坞));
			调用子程序(Set_Map_HW);
		Else If(当前地图 == 地图(铁坂));
			调用子程序(Set_Map_KZ);
		Else;
			创建HUD文本(所有玩家(所有队伍), 自定义字符串(" \n\n\n\n\n\n\n\n\n\n\n\n\n\n     本模式不支持本地图！请选择一张可用的地图。     \n\n\n\n\n\n\n\n\n\n\n\n\n\n"), 无, 无, 顶部,
				-1000, 颜色(黄色), 颜色(白色), 颜色(白色), 可见, 默认可见度);
		End;
		"Create HUDs and Effects"
		创建HUD文本(已过滤的数组(全局.Combatants, 相距距离(当前数组元素, 全局.Ability_Buy_Location) > 2), 自定义字符串(" \n{0}\n\n  按下{1}来开始 \n", 数组(自定义字符串("   英雄解救 "),
			自定义字符串("    入侵  "), 自定义字符串("  高价值目标"))[全局.Gamemode], 输入绑定字符串(按钮(互动))), 无, 无, 顶部, 全局.Gamemode ? -90 : 10, 颜色(白色), 颜色(白色), 颜色(
			白色), 可见和字符串, 默认可见度);
		全局.Game_Start_HUD = 上一个文本ID;
		创建HUD文本(全局.Wave ? 主机玩家 : 已过滤的数组(全局.Combatants, 相距距离(当前数组元素, 全局.Ability_Buy_Location) > 2), 无, 无, 全局.Wave ? 自定义字符串(
			"按住{0}键并持续2秒即可激活突变（适合有经验的玩家）", 输入绑定字符串(按钮(互动))) : 自定义字符串("在地图工坊设置里可以更改目标类型"), 顶部, 全局.Gamemode ? -89 : 11, 颜色(白色), 颜色(白色), 颜色(
			绿色), 可见和字符串, 默认可见度);
		全局.Mutator_Start_HUD = 上一个文本ID;
		If(全局.Gamemode == 0);
			创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("敌人重生剩余：{0}", 全局.Spawns_remaining), 右边, -10, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
			全局.HR_Hostage_Hero_Array = 数组(英雄(安娜), 英雄(艾什), 英雄(源氏), 英雄(卡西迪), 英雄(猎空), 英雄(黑百合), 英雄(禅雅塔), 英雄(士兵：76), 英雄(卢西奥), 英雄(法老之鹰), 英雄(莫伊拉), 英雄(
				查莉娅), 英雄(狂鼠), 英雄(半藏), 英雄(末日铁拳), 英雄(天使), 英雄(黑影), 英雄(温斯顿), 英雄(回声), 英雄(托比昂), 英雄(布丽吉塔), 英雄(美), 英雄(西格玛), 英雄(死神), 英雄(路霸), 英雄(奥丽莎),
				英雄(D.Va), 英雄(破坏球), 英雄(巴蒂斯特), 英雄(秩序之光), 英雄(莱因哈特), 英雄(堡垒));
		Else;
			创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("热火街区生存战 2.5.0 (4ACNY| 原版：RM64A)- {0}{1}", 全局.Gamemode == 1 ? 自定义字符串("关闭传送门") : 自定义字符串("捕捉高价值目标"),
				比赛时间 ? 自定义字符串("      {0}{1}{2}", 比赛时间 > 10 ? 自定义字符串("0:") : 字符串(""), 取整(取整(10 * 比赛时间, 上) / 10, 下), 比赛时间 > 10 ? 字符串("")
				: 自定义字符串(".{0}", 取整(10 * 比赛时间, 上) % 10)) : 字符串("")), 顶部, -100, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
			创建HUD文本(所有玩家(所有队伍), 自定义字符串("第 {0}/15 波", 全局.Wave), 无, 无, 顶部, -99, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
			创建HUD文本(所有玩家(所有队伍), 无, 全局.IV_Portal_Status == 1 || 全局.IV_Portal_Status == 2 ? 自定义字符串(" ") : 自定义字符串(" \n\n\n"), 无, 顶部, -98, 颜色(白色),
				颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
			创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串(
				" \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"),
				顶部, -1, 颜色(白色), 颜色(白色), 颜色(白色), 可见, 默认可见度);
		End;
		创建HUD文本(所有玩家(队伍2), 无, 无, 自定义字符串("在{0}秒内避免伤害即可回血", 全局.Mut_Deep_Wounds ? 5 : 自定义字符串("2.5")), 左边, -10, 颜色(白色), 颜色(白色), 颜色(天蓝色),
			可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(全局.Combatants, !当前数组元素.Downed_since && (当前数组元素.Is_changing_Heroes || (比赛时间 > 0 && 相距距离(当前数组元素,
			全局.Ability_Buy_Location) > 2))), 自定义字符串(" \n\n\n  　现在可以更换英雄 \n　　　　　 长按 [{0}]，\n 然后按下[H]键打开英雄菜单 \n", 输入绑定字符串(按钮(互动))), 无, 无, 顶部,
			全局.Gamemode ? -90 : 10, 颜色(黄色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(全局.Combatants, 当前数组元素.Downed_since), 无, 无, 自定义字符串("等待复活中。按下{0}键来旁观下一名玩家。", 输入绑定字符串(按钮(跳跃))), 顶部,
			全局.Gamemode ? -70 : 30, 颜色(白色), 颜色(白色), 颜色(黄色), 可见和字符串, 默认可见度);
		创建HUD文本(全局.Is_Infrasight_on_Bots1 ? 所有玩家(所有队伍) : 空数组, 自定义字符串("敌人提升了瞄准水平！"), 无, 无, 顶部, 全局.Gamemode ? -50 : 50, 颜色(紫色), 颜色(白色), 颜色(
			白色), 可见, 默认可见度);
		创建HUD文本(所有玩家(队伍1), 自定义字符串("服务器负载：{0}%，平均：{1}%，峰值：{2}%", 服务器负载, 服务器负载平均值, 服务器负载峰值), 无, 无, 左边, -110, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串,
			默认可见度);
		创建HUD文本(空数组, 无, 自定义字符串("由Shingen制作，由LemonAid修改"), 自定义字符串("workshop.codes/heat-street\nworkshop.codes/modified-heat-street\n \n"),
			左边, -1000, 颜色(白色), 颜色(绿色), 颜色(绿色), 可见, 始终可见);
		"Tase Effects"
		创建效果(首个(选择英雄的玩家(英雄(黑影), 队伍1)).Ab_Player != 0 ? 所有玩家(所有队伍) : 空数组, 能量声音, 颜色(白色), 首个(选择英雄的玩家(英雄(黑影), 队伍1)).Ab_Player, 200, 可见，位置和半径);
		创建光束效果(首个(选择英雄的玩家(英雄(黑影), 队伍1)).Ab_Player != 0 ? 所有玩家(所有队伍) : 空数组, 有害光束, 首个(选择英雄的玩家(英雄(黑影), 队伍1)), 首个(选择英雄的玩家(英雄(黑影), 队伍1))
			.Ab_Player, 颜色(红色), 可见，位置和半径);
		创建效果(首个(选择英雄的玩家(英雄(黑影), 队伍1)).Ab_Player != 0 ? 所有玩家(所有队伍) : 空数组, 环, 颜色(天蓝色), 首个(选择英雄的玩家(英雄(黑影), 队伍1)), 3 * 总计消耗时间 % 0.750,
			可见，位置和半径);
		"Create Ability Modifications and Buy Menu"
		全局.Money = 2000;
		调用子程序(Set_Random_Perks);
		"No Abilities: Bots to Players Damage Decrease"
		开始伤害调整(已过滤的数组(全局.Combatants, !当前数组元素.Money_spent), 所有玩家(队伍1), 较大(70, 100 / (1 + 全局.Money / 7000 * 0.400)), 受伤害者，伤害者及伤害百分比);
		"Priority A: Players to Bots Damage Increase"
		开始伤害调整(已过滤的数组(所有玩家(队伍1), 当前数组元素.Is_Target_in_LOS && 当前数组元素.Target.Ab_Priority == 1), 全局.Combatants, 115, 受伤害者和伤害者);
		"Priority A: Bots to Players Damage Decrease"
		开始伤害调整(全局.Combatants, 已过滤的数组(所有玩家(队伍1), 当前数组元素.Is_Target_in_LOS && 当前数组元素.Target.Ab_Priority == 1), 85, 受伤害者和伤害者);
		"Stabilizer: Players to Players Healing Increase"
		开始治疗调整(已过滤的数组(全局.Combatants, 标准化生命值(当前数组元素) <= 0.500), 已过滤的数组(全局.Combatants, 当前数组元素.Perk_Stabilizer), 130, 受治疗者和治疗者);
		创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 全局.Ability_Buy_Location, 2, 可见);
		创建地图文本(所有玩家(所有队伍), !全局.Wave || 比赛时间 ? 自定义字符串("[{0}] 传送至此\n  购买技能  ", 输入绑定字符串(按钮(装填))) : 自定义字符串(" \n  购买技能  "),
			全局.Ability_Buy_Location, 1.500, 不要截取, 可见和字符串, 颜色(绿色), 默认可见度);
		创建HUD文本(已过滤的数组(范围内玩家(全局.Ability_Buy_Location, 2, 队伍2, 关闭), !当前数组元素.Downed_since && !当前数组元素.In_Buy_Menu_Since), 自定义字符串(
			" \n 按下{0}键来打开购买菜单 \n", 输入绑定字符串(按钮(互动))), 无, 无, 顶部, 全局.Gamemode ? -80 : 20, 颜色(绿色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		"Create Buy Menu IWTs, on scale 2.5 1 space is 8.5 pixels"
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since), 自定义字符串("┃\n┃\n┃\n┃\n┃\n┃\n┃\n┃\n┃"),
			全局.Buy_Menu_Pos - 21 * 全局.Buy_Menu_Left_Up_Forward[1] + 90 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(白色), 默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since), 自定义字符串("┃\n┃\n┃\n┃\n┃\n┃\n┃\n┃\n┃"),
			全局.Buy_Menu_Pos - 21 * 全局.Buy_Menu_Left_Up_Forward[1] - 90 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(白色), 默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since), 自定义字符串("退回金币"),
			全局.Buy_Menu_Pos + 45 * 全局.Buy_Menu_Left_Up_Forward[1] + 90 * 全局.Buy_Menu_Left_Up_Forward[0], 3, 不要截取, 可见, 颜色(绿色), 默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since), 自定义字符串("[{0}] 离开", 输入绑定字符串(按钮(互动))),
			全局.Buy_Menu_Pos + 45 * 全局.Buy_Menu_Left_Up_Forward[1] - 90 * 全局.Buy_Menu_Left_Up_Forward[0], 3, 不要截取, 可见和字符串, 颜色(绿色), 默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Ab_Priority), 自定义字符串("快来打我\n 1200$"),
			全局.Buy_Menu_Pos + 20 * 全局.Buy_Menu_Left_Up_Forward[1] + 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Ab_Priority), 自定义字符串("劝你三思\n 1200$"),
			全局.Buy_Menu_Pos - 2.500 * 全局.Buy_Menu_Left_Up_Forward[1] + 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Ab_Priority), 自定义字符串("别打我啦\n 1200$"),
			全局.Buy_Menu_Pos - 25 * 全局.Buy_Menu_Left_Up_Forward[1] + 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Priority), 自定义字符串("快来打我\n   免费"),
			全局.Buy_Menu_Pos + 20 * 全局.Buy_Menu_Left_Up_Forward[1] + 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(黄色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Priority), 自定义字符串("劝你三思\n   免费"),
			全局.Buy_Menu_Pos - 2.500 * 全局.Buy_Menu_Left_Up_Forward[1] + 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(黄色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Priority), 自定义字符串("别打我啦\n   免费"),
			全局.Buy_Menu_Pos - 25 * 全局.Buy_Menu_Left_Up_Forward[1] + 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(黄色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Headhunter < 2), 自定义字符串("猎头者\n800$"),
			全局.Buy_Menu_Pos + 20 * 全局.Buy_Menu_Left_Up_Forward[1] + 67.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Headhunter >= 2), 自定义字符串("猎头者\n800$"),
			全局.Buy_Menu_Pos + 20 * 全局.Buy_Menu_Left_Up_Forward[1] + 67.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Ambush < 2), 自定义字符串("伏击\n800$"),
			全局.Buy_Menu_Pos - 2.500 * 全局.Buy_Menu_Left_Up_Forward[1] + 67.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Ambush >= 2), 自定义字符串("伏击\n800$"),
			全局.Buy_Menu_Pos - 2.500 * 全局.Buy_Menu_Left_Up_Forward[1] + 67.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Quick_Fix < 2), 自定义字符串("快速调整\n700$"),
			全局.Buy_Menu_Pos - 25 * 全局.Buy_Menu_Left_Up_Forward[1] + 67.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Quick_Fix >= 2), 自定义字符串("快速调整\n700$"),
			全局.Buy_Menu_Pos - 25 * 全局.Buy_Menu_Left_Up_Forward[1] + 67.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Charged < 2), 自定义字符串("充能\n700$"),
			全局.Buy_Menu_Pos + 20 * 全局.Buy_Menu_Left_Up_Forward[1] + 22.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Charged >= 2), 自定义字符串("充能\n700$"),
			全局.Buy_Menu_Pos + 20 * 全局.Buy_Menu_Left_Up_Forward[1] + 22.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Haste < 2), 自定义字符串("精通\n700$"),
			全局.Buy_Menu_Pos - 2.500 * 全局.Buy_Menu_Left_Up_Forward[1] + 22.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Haste >= 2), 自定义字符串("精通\n700$"),
			全局.Buy_Menu_Pos - 2.500 * 全局.Buy_Menu_Left_Up_Forward[1] + 22.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Heavy_Impact < 2), 自定义字符串("沉重一击\n1000$"),
			全局.Buy_Menu_Pos - 25 * 全局.Buy_Menu_Left_Up_Forward[1] + 22.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Heavy_Impact >= 2), 自定义字符串("沉重一击\n1000$"),
			全局.Buy_Menu_Pos - 25 * 全局.Buy_Menu_Left_Up_Forward[1] + 22.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Resilience < 2), 自定义字符串("强韧\n800$"),
			全局.Buy_Menu_Pos + 20 * 全局.Buy_Menu_Left_Up_Forward[1] - 22.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Resilience >= 2), 自定义字符串("强韧\n800$"),
			全局.Buy_Menu_Pos + 20 * 全局.Buy_Menu_Left_Up_Forward[1] - 22.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Binding_Heal < 2), 自定义字符串("绑定治愈\n700$"),
			全局.Buy_Menu_Pos - 2.500 * 全局.Buy_Menu_Left_Up_Forward[1] - 22.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Binding_Heal >= 2), 自定义字符串("绑定治愈\n700$"),
			全局.Buy_Menu_Pos - 2.500 * 全局.Buy_Menu_Left_Up_Forward[1] - 22.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Second_Wind < 2), 自定义字符串("第二次机会\n900$"),
			全局.Buy_Menu_Pos - 25 * 全局.Buy_Menu_Left_Up_Forward[1] - 22.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Ab_Second_Wind >= 2), 自定义字符串("第二次机会\n900$"),
			全局.Buy_Menu_Pos - 25 * 全局.Buy_Menu_Left_Up_Forward[1] - 22.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since), 自定义字符串("+5% 生命\n400$"),
			全局.Buy_Menu_Pos + 20 * 全局.Buy_Menu_Left_Up_Forward[1] - 67.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since), 自定义字符串("+5% 伤害\n400$"),
			全局.Buy_Menu_Pos - 2.500 * 全局.Buy_Menu_Left_Up_Forward[1] - 67.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since), 自定义字符串("+5% 治疗\n400$"),
			全局.Buy_Menu_Pos - 25 * 全局.Buy_Menu_Left_Up_Forward[1] - 67.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since), 自定义字符串("限时特惠！"),
			全局.Buy_Menu_Pos + 22.500 * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(白色),
			默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Last_Damage_taken + 2 >= 总计消耗时间), 自定义字符串("你正在遭受攻击！\n按下{0}键来离开商店",
			输入绑定字符串(按钮(互动))), 全局.Buy_Menu_Pos - 74 * 全局.Buy_Menu_Left_Up_Forward[1] + 55 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取,
			可见，字符串和颜色, 自定义颜色(245 + 10 * 弧度的正弦值(4 * 总计消耗时间), 205 + 50 * 弧度的正弦值(4 * 总计消耗时间), 200 * 弧度的正弦值(4 * 总计消耗时间), 255), 默认可见度);
		创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since), 自定义字符串("按下{0}键来购买\n", 输入绑定字符串(按钮(主要攻击模式))),
			全局.Buy_Menu_Pos - 74 * 全局.Buy_Menu_Left_Up_Forward[1] - 55 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见和字符串, 颜色(白色),
			默认可见度);
		"Skip Assembling Heroes"
		设置比赛时间(3);
		等待直到 (游戏正在进行中, 3.500);
		设置比赛时间(0);
		生成机器人(英雄(卡西迪), 队伍1, 0, 1000 * 下, 前);
		生成机器人(英雄(士兵：76), 队伍1, 1, 1000 * 下, 前);
		生成机器人(英雄(卡西迪), 队伍1, 2, 1000 * 下, 前);
		生成机器人(英雄(士兵：76), 队伍1, 3, 1000 * 下, 前);
		生成机器人(英雄(黑百合), 队伍1, 4, 1000 * 下, 前);
		生成机器人(英雄(布丽吉塔), 队伍1, 5, 1000 * 下, 前);
		If(全局.Gamemode);
			生成机器人(英雄(路霸), 队伍1, 6, 1000 * 下, 前);
		End;
		等待(1, 无视条件);
		开始伤害调整(所有玩家(队伍1), 所有玩家(队伍1), 0, 无);
		开始伤害调整(全局.Combatants, 选择英雄的玩家(英雄(法老之鹰), 队伍1), 40, 受伤害者，伤害者及伤害百分比);
	}
}

规则("Subroutine (Set Map KR): Set Spawns, Nodes, Edges, Distance Matrix, Drop-off Location, Ability Buy Location")
{
	事件
	{
		子程序;
		Set_Map_KR;
	}

	动作
	{
		全局.Spawns = 数组(矢量(-49.543, -0.058, -20.941), 矢量(-90.943, 0.853, -34.708), 矢量(-72.781, 4.500, -30.639), 矢量(-90.504, 1.100, 10.813),
			矢量(-67.414, 0.021, -12.835), 矢量(-54.556, 0, -1.868), 矢量(-77.834, 6, -11.039), 矢量(-36.648, 9, -22.089), 矢量(-48.643, 1.146,
			-46.893), 矢量(-92.004, -2.496, -45.057));
		全局.Spawns_Nearest_Nodes_by_Index = 数组(2, 19, 12, 20, 39, 24, 28, 34, 5, 16);
		全局.Nodes = 数组(矢量(-53.296, -0.228, -34.771), 矢量(-55.657, -0.058, -24.394), 矢量(-46.143, -0.058, -19.172), 矢量(-41.876, 0.061,
			-30.682), 矢量(-35.734, 2, -49.956), 矢量(-48.182, 2, -50.936), 矢量(-49.730, 0.091, -41.934), 矢量(-59.611, 0.174, -47.736), 矢量(
			-70.491, 0.188, -43.305), 矢量(-72.298, 0.500, -38.246), 矢量(-72.437, 0.500, -31.723), 矢量(-81.497, 2.500, -32.307), 矢量(-76.018,
			4.500, -28.007), 矢量(-70.148, 4.500, -35.916), 矢量(-81.733, 4.500, -39.787), 矢量(-89.063, -1.494, -60.157), 矢量(-95.244, -2.496,
			-46.420), 矢量(-101.455, -0.494, -32.626), 矢量(-87.875, 0.745, -27.025), 矢量(-83.526, 0.315, -47.053), 矢量(-91.063, 0.859, -13.988),
			矢量(-89.170, 0.927, 3.562), 矢量(-75.235, -0.200, 3.214), 矢量(-60.777, 0, 3.023), 矢量(-49.238, 0, 1.737), 矢量(-46.567, 1, -9.495),
			矢量(-59.767, 5.021, -12.074), 矢量(-67.247, 5.021, -13.311), 矢量(-77.198, 6, -14.764), 矢量(-78.405, 6, -6.706), 矢量(-86.876, 6.934,
			-16.974), 矢量(-90.379, 6.930, -4.276), 矢量(-97.033, 6.938, -6.009), 矢量(-58.693, 4.956, -16.723), 矢量(-37.774, 9, -12.686), 矢量(
			-33.899, 9, -34.276), 矢量(-31.407, 6, -49.920), 矢量(-60.046, 3, -3.754), 矢量(-72.854, -0.192, -7.428), 矢量(-71.952, -0.190,
			-14.205), 矢量(-70.347, -0.259, -20.339), 矢量(-64.360, -0.327, -28.814));
		全局.Nodes_Count = 数量(全局.Nodes);
		全局.Edges = 数组(数组(1, 3, 7, 40, 41), 数组(0, 2), 数组(1, 3), 数组(0, 2, 4), 数组(3, 5), 数组(4, 6), 数组(5, 7), 数组(0, 6, 8, 15), 数组(7, 9, 19),
			数组(8, 10), 数组(9, 11, 41), 数组(10, 12), 数组(11, 13), 数组(0, 8, 12, 14), 数组(13, 18), 数组(7, 16), 数组(15, 17), 数组(16, 18), 数组(14, 17,
			19, 20, 40), 数组(8, 18), 数组(18, 21), 数组(20, 22), 数组(21, 23, 38), 数组(22, 24), 数组(23, 25), 数组(24, 26), 数组(25, 27, 28, 30, 33, 37),
			数组(26, 28, 30, 41), 数组(26, 27, 29, 30), 数组(28), 数组(18, 26, 27, 28, 31), 数组(21, 30, 32), 数组(31), 数组(26, 34, 40), 数组(33, 35, 36),
			数组(0, 34, 36), 数组(34, 35), 数组(26, 38), 数组(22, 37, 39, 40), 数组(38, 40), 数组(0, 18, 38, 39, 41), 数组(0, 10, 40));
		全局.Distance_Matrix = 数组(自定义字符串(
			"01212321232344323323343455455656756773221110123432343455434434454566566767867884332221012343454566545545565677677878978995443312"),
			自定义字符串(
			"101232343455434434454566566767867884332223210123454566545545565677677878978995443334321012345677634554676788788989!89!!655442343"),
			自定义字符串(
			"21012345665234435656776778789789954433123232101234554123324545665667678678843322234343210123443233213456776778789789954433345454"),
			自定义字符串(
			"32101234434432455677677878978995443223434543210123445433454566566767867884332134545654321012356544565677677878978995443223434543"),
			自定义字符串(
			"23210124543345567767787897899544331232343212321013432234456656676786788433222343454323432104321223456656676786788433232343432123"),
			自定义字符串(
			"45654012334556776778789789954433345454323456543101233456776778789789954434345455433445432210122345665667678678843323234345432334"),
			自定义字符串(
			"32132101123455455656756773221234545432123443233210234566566767867884332334545654344543243212012345566767867884332345656765455654"),
			自定义字符串(
			"35432310123445565675677323343454565455456545543421012334454564566212234565676566567656654532101234454564566323345676787666567657"),
			自定义字符串(
			"65454321012334345345533444456567655545654654344432101223234234423433345456544434543543233333210112123123312322234345434323443443"),
			自定义字符串(
			"23334432101212323442332134545654443454354323334432110112323442343245656765554565465434445543221023434553454334545654343443243212"),
			自定义字符串(
			"22343211120122344233224565676545455435432321234322231013455334335676787656566546543432345433342104566445442343454344345434432334"),
			自定义字符串(
			"34321223234012222212234345434545654454344545432334345101133323123234323434554344344545543445456210143322234345434545665455455656"),
			自定义字符串(
			"54344545621104443334545654554565455434432332122323423440122323434543443454344323321233233434534551011223434543443454344323332344"),
			自定义字符串("3445456456621012123234323323432332122323443445456456621101123234323212343343233434554556567567732210"));
		全局.Elevator_Nodes = 空数组;
		If(全局.Gamemode == 0);
			全局.Objective_Spawns = 数组(矢量(-34.813, 2, -50.819), 矢量(-42.979, 0.002, 5.753), 矢量(-92.514, 1.134, 11.276), 矢量(-93.894, -2.497,
				-42.813), 矢量(-79.489, 6.001, -6.569), 矢量(-29.979, 9, -15.274), 矢量(-31.294, 6.002, -50.113), 矢量(-98.587, 6.938, -6.174));
		Else If(全局.Gamemode == 1);
			全局.Objective_Spawns = 数组(矢量(-34.899, 1.858, -24.734), 矢量(-36.419, 4, -49.416), 矢量(-56.357, 1.923, -45.164), 矢量(-83.382, 2.307,
				-46.595), 矢量(-75.709, 6.500, -38.586), 矢量(-80.440, 8, -15.302), 矢量(-93.122, 8.939, -5.425), 矢量(-93.710, 2.947, -11.055), 矢量(
				-78.228, 2.142, -23.057), 矢量(-71.703, 1.780, -0.654), 矢量(-44.629, 2, 2.089), 矢量(-48.280, 8.956, -15.029), 矢量(-95.352, -0.496,
				-46.422));
		End;
		全局.Player_Spawn = 矢量(-71.834, 0.501, -31.490);
		全局.Player_Spawn_Facing = 矢量(2, 0, 1);
		全局.Ability_Buy_Location = 矢量(-53.668, -0.060, -26.387);
		全局.Buy_Menu_Left_Up_Forward[2] = 前;
		全局.Buy_Menu_Left_Up_Forward[1] = 与此角度的相对方向(与此方向的水平角度(全局.Buy_Menu_Left_Up_Forward[2]), 与此方向的垂直角度(全局.Buy_Menu_Left_Up_Forward[2])
			- 90);
		全局.Buy_Menu_Left_Up_Forward[0] = 矢量积(全局.Buy_Menu_Left_Up_Forward[1], 全局.Buy_Menu_Left_Up_Forward[2]);
		全局.Buy_Menu_Cam_Pos = 900 * 上;
		全局.Buy_Menu_Pos = 全局.Buy_Menu_Cam_Pos - 9 * 全局.Buy_Menu_Left_Up_Forward[1] + 142 * 全局.Buy_Menu_Left_Up_Forward[2];
		全局.Max_Speed_Bonus = 160;
	}
}

规则("Subroutine (Set Map EA): Set Spawns, Nodes, Edges, Distance Matrix, Drop-off Location, Ability Buy Location")
{
	事件
	{
		子程序;
		Set_Map_EA;
	}

	动作
	{
		全局.Spawns = 数组(矢量(-30.849, 9, 0), 矢量(1.271, 7.977, 53.538), 矢量(1.271, 7.977, -53.538), 矢量(-7.229, 7.339, 34.043), 矢量(-6.473, 7.341,
			-34.813), 矢量(18.120, 4.711, 9.135), 矢量(18.120, 4.711, -9.135), 矢量(3.600, 8.065, -19.773), 矢量(3.136, 7.401, 20.209));
		全局.Spawns_Nearest_Nodes_by_Index = 数组(14, 31, 7, 29, 9, 27, 2, 3, 26);
		全局.Nodes = 数组(矢量(20.504, 8.999, 0), 矢量(23.920, 6.018, -15.877), 矢量(18.427, 6.015, -14.462), 矢量(0.435, 7.386, -23.993), 矢量(3.241,
			7.011, -35.315), 矢量(19.350, 9.547, -30.387), 矢量(13.245, 8.012, -49.542), 矢量(-2.281, 6.999, -54.762), 矢量(-12.266, 7.002,
			-45.117), 矢量(-7.511, 7.047, -39.796), 矢量(-9.388, 7.051, -24.399), 矢量(-15.043, 10.002, -19.131), 矢量(-13.852, 11.998, -11.331),
			矢量(-20.998, 12.040, 0), 矢量(-32.107, 9, 0), 矢量(-29.220, 9, -7.120), 矢量(-17.171, 7.269, -5.117), 矢量(6.646, 4.741, -3.611), 矢量(
			17.143, 3.998, 0), 矢量(27.160, 3.156, -6.262), 矢量(6.646, 4.741, 3.611), 矢量(-17.171, 7.269, 5.117), 矢量(-29.220, 9, 7.120), 矢量(
			-9.388, 7.051, 24.399), 矢量(-15.043, 10.002, 19.131), 矢量(-13.852, 11.998, 11.331), 矢量(0.435, 7.386, 23.993), 矢量(18.427, 6.015,
			14.462), 矢量(23.920, 6.018, 15.877), 矢量(-7.511, 7.047, 39.796), 矢量(-12.266, 7.002, 45.117), 矢量(-2.281, 6.999, 54.762), 矢量(
			13.245, 8.012, 49.542), 矢量(3.241, 7.011, 35.315), 矢量(19.350, 9.547, 30.387), 矢量(14.009, 11.808, 20.354), 矢量(10.556, 12.001,
			13.089), 矢量(-5.634, 11.998, 11.889), 矢量(-5.634, 11.998, -11.889), 矢量(10.556, 12.001, -13.089), 矢量(6.614, 11.624, -25.520), 矢量(
			14.009, 11.808, -20.354), 矢量(6.614, 11.624, 25.520), 矢量(29.660, 3, 0), 矢量(27.160, 3.156, 6.262), 矢量(-12.323, 6.374, 15.534),
			矢量(-12.323, 6.374, -15.534), 矢量(12.321, 6.851, 23.155), 矢量(12.321, 6.851, -23.155), 矢量(27.935, 8.961, 2.295), 矢量(27.935, 8.961,
			-2.295));
		全局.Nodes_Count = 数量(全局.Nodes);
		全局.Edges = 数组(数组(1, 17, 19, 20, 28, 35, 41, 44, 49, 50), 数组(0, 2), 数组(1, 3, 18, 48), 数组(2, 4, 10), 数组(3, 5, 6, 9, 48), 数组(4, 41),
			数组(4, 7), 数组(6, 8), 数组(7, 9), 数组(4, 8, 10), 数组(3, 9, 11, 17, 46), 数组(10, 12), 数组(11, 13, 38), 数组(12, 14, 25), 数组(13, 15, 22),
			数组(14, 16), 数组(15, 17, 21, 46), 数组(10, 16, 18, 20), 数组(2, 17, 19, 20, 27, 44), 数组(18, 43), 数组(17, 18, 21, 23), 数组(16, 20, 22,
			45), 数组(14, 21), 数组(20, 24, 26, 29, 45), 数组(23, 25), 数组(13, 24, 37), 数组(23, 27, 33), 数组(18, 26, 28, 47), 数组(0, 27), 数组(23, 30,
			33), 数组(29, 31), 数组(30, 32), 数组(31, 33), 数组(26, 29, 32, 34, 47), 数组(33, 35), 数组(0, 34, 36), 数组(35, 37, 42), 数组(25, 36, 38), 数组(
			12, 37, 39), 数组(38, 40, 41), 数组(4, 39), 数组(0, 5, 39), 数组(33, 36), 数组(19, 44), 数组(18, 43), 数组(21, 23), 数组(10, 16), 数组(27, 33),
			数组(2, 4), 数组(0, 50), 数组(0, 49));
		全局.Distance_Matrix = 数组(自定义字符串(
			"01233245432345432121123234321345432123323132133331110123345543456543222234345432456543234434243244422221012334432345543212234345"),
			自定义字符串(
			"32345654434554535324331333210122332123454322334545543456765545544536435242443321011221234565433445656654467876545543426546351442"),
			自定义字符串(
			"33210233234456543433454555435676543443231543545233443212012234567654455676776557898765665453765746255554323101234567654565676777"),
			自定义字符串(
			"66789987677656487674736655432321012345654345456566656678877676556486563636644321222101234543234345455545567766565445375452525543"),
			自定义字符串(
			"21233321012343212323434443445665655434546434143555432344432101234323434444354556776654323445545254664543445543210123434544343255"),
			自定义字符串(
			"55676554321233465536555565455665432101234564323214564566554322344476446666665566776543210123453214325565677665433455565336677654"),
			自定义字符串(
			"45666543432101234322443545567767654456665432557754334555432343210123212344434456656665567674321446643223444321234321012123234323"),
			自定义字符串(
			"34554556545657323233553212344543234543210112323421234543445555646213322444323455654345654321023434532345654556666757124433554323"),
			自定义字符串(
			"45554323443321120121232232344345545675632233355543456665434432212231012343343455456655676743124466654567776544321223342103434454"),
			自定义字符串(
			"56656654456665423557744345666543443443223123012123123323443456554314345555456677654432344334234101234234434432345545425456645555"),
			自定义字符串(
			"56765432123444534321034534554432123443653556553434556765455455432323412301223321234455645432524442323445654345554321223423410134"),
			自定义字符串(
			"43233455453532341333123443565434565432222343452104554332344342432442422454566776545545543342341232340122123445675554252555565677"),
			自定义字符串(
			"88765665665445345234345101223455678666536366656678799876776776556456345345210123456778667647376645567689876776776545456345234221"),
			自定义字符串(
			"01234566755654726553445657876566566543434523412312210123455644543615442345546765455565434334534423323321012344533434525331234435"),
			自定义字符串(
			"65434445432322343433323443210123342232443422234554676544334543433454323433443221012343143553533345544566543223454544543214544554"),
			自定义字符串(
			"33210123325445454434543345543212345454454432554566544321012235454544423432234434323454343345443543567654332101144355533334321223"),
			自定义字符串(
			"32343456544445655465467876544321025546462441233213443343454323223434443245654323321204324443223456657876554456544445634323423321"),
			自定义字符串(
			"22123454054462644543456676545676543213454564345676566777786801554466432345565434565432122343453234565455666675710443355554567776"),
			自定义字符串(
			"54554332334212123234234434554567665403456654323444321234321234323455545567767665456575430546634345567654566654323345345212233212"),
			自定义字符串(
			"34565645434504443212122332345665432334545643456765545654536435440441234435654345654323223434543245654323443424324444011234435654"),
			自定义字符串("34565432322343454324565432344342432444410"));
		全局.Elevator_Nodes = 空数组;
		If(全局.Gamemode == 0);
			全局.Objective_Spawns = 数组(矢量(-5.497, 10.920, 33.124), 矢量(-5.497, 10.920, -33.124), 矢量(13.621, 8.034, 58.971), 矢量(13.621, 8.034,
				-58.971), 矢量(-0.331, 7.384, 27.518), 矢量(-0.331, 7.384, -27.518), 矢量(-34.933, 8.999, 0));
		Else If(全局.Gamemode == 1);
			全局.Objective_Spawns = 数组(矢量(7.473, 6.603, 0), 矢量(22.354, 5, 0), 矢量(-5.559, 14, 0), 矢量(15.248, 11, 0), 矢量(-0.850, 13.634, 27.957),
				矢量(-0.850, 13.634, -27.957), 矢量(10.923, 10.035, 50.571), 矢量(10.923, 10.035, -50.571), 矢量(6.951, 8.877, 34.288), 矢量(6.951,
				8.877, -34.288), 矢量(2.626, 14, 12.296), 矢量(2.626, 14, -12.296), 矢量(-7.918, 9.341, 34.578), 矢量(-7.918, 9.341, -34.578));
		End;
		全局.Player_Spawn = 矢量(20.362, 9.002, 0);
		全局.Player_Spawn_Facing = 右;
		全局.Ability_Buy_Location = 矢量(-31.007, 8.999, 0);
		全局.Buy_Menu_Left_Up_Forward[2] = 与此角度的相对方向(148.184, 0);
		全局.Buy_Menu_Left_Up_Forward[1] = 与此角度的相对方向(与此方向的水平角度(全局.Buy_Menu_Left_Up_Forward[2]), 与此方向的垂直角度(全局.Buy_Menu_Left_Up_Forward[2])
			- 90);
		全局.Buy_Menu_Left_Up_Forward[0] = 矢量积(全局.Buy_Menu_Left_Up_Forward[1], 全局.Buy_Menu_Left_Up_Forward[2]);
		全局.Buy_Menu_Cam_Pos = 矢量(33.777, -3.064, -42.403);
		全局.Buy_Menu_Pos = 全局.Buy_Menu_Cam_Pos - 9 * 全局.Buy_Menu_Left_Up_Forward[1] + 142 * 全局.Buy_Menu_Left_Up_Forward[2];
		全局.Max_Speed_Bonus = 180;
	}
}

规则("Subroutine (Set Map CG): Set Spawns, Nodes, Edges, Distance Matrix, Drop-off Location, Ability Buy Location")
{
	事件
	{
		子程序;
		Set_Map_CG;
	}

	动作
	{
		全局.Spawns = 数组(矢量(206.454, 0.001, 70.220), 矢量(221.427, 8.692, 66.933), 矢量(193.658, 0.998, 67.449), 矢量(229.543, 1.999, 85.875), 矢量(
			224.599, 5.001, 110.683), 矢量(199.902, 8.843, 109.823), 矢量(183.728, 9.002, 107.834), 矢量(176.589, 6.999, 66.024), 矢量(212.836, 9,
			81.390), 矢量(228.988, 12.998, 65.820), 矢量(186.820, 0.999, 87.814));
		全局.Spawns_Nearest_Nodes_by_Index = 数组(0, 24, 2, 40, 42, 35, 33, 10, 25, 21, 7);
		全局.Nodes = 数组(矢量(206.137, 0.041, 81.572), 矢量(197.753, 1.002, 81.213), 矢量(189.242, 0.998, 66.794), 矢量(188.608, 2.998, 52.813), 矢量(
			196.458, 16.498, 48.068), 矢量(196.476, 16.501, 68.781), 矢量(186.703, 0.999, 80.980), 矢量(187.579, 0.999, 92.388), 矢量(174.916,
			5.001, 92.330), 矢量(174.294, 5, 80.881), 矢量(173.301, 6.999, 66.065), 矢量(173.262, 6.998, 57.010), 矢量(183.040, 7.999, 56.064), 矢量(
			183.491, 7.999, 63.766), 矢量(191.037, 7.999, 64.119), 矢量(199.061, 7.998, 49.104), 矢量(201.742, 7.998, 60.913), 矢量(209.518, 7.998,
			60.774), 矢量(208.958, 8.999, 43.479), 矢量(218.545, 11.998, 45.456), 矢量(216.613, 14.001, 61.938), 矢量(229.231, 13.001, 61.763), 矢量(
			229.677, 9.187, 73.895), 矢量(220.985, 7.998, 81.140), 矢量(221.330, 9.002, 61.664), 矢量(206.100, 9, 81.084), 矢量(206.313, 7.999,
			70.046), 矢量(183.802, 5.998, 74.325), 矢量(186.933, 6, 80.940), 矢量(185.025, 6.001, 87.180), 矢量(194.265, 8.001, 96.067), 矢量(
			205.974, 9.025, 95.640), 矢量(216.192, 7.999, 95.441), 矢量(180.423, 8.998, 104.206), 矢量(205.974, 8.027, 103.778), 矢量(206.172,
			7.998, 110.406), 矢量(193.533, 9, 110.488), 矢量(219.054, 5.998, 103.970), 矢量(219.070, 1.998, 90.657), 矢量(235.431, 1.998, 90.539),
			矢量(229.409, 1.999, 90.044), 矢量(237.966, 3.998, 104.629), 矢量(226.962, 4.284, 112.037), 矢量(219.008, 0.998, 81.327), 矢量(177.920,
			0.002, 51.147));
		全局.Nodes_Count = 数量(全局.Nodes);
		全局.Edges = 数组(数组(1, 43), 数组(0, 2, 6, 43), 数组(1, 3), 数组(2, 4, 44), 数组(3, 5, 15, 19), 数组(4, 14), 数组(1, 7), 数组(6, 8), 数组(7, 9), 数组(8,
			10, 27, 29), 数组(9, 11), 数组(10, 12), 数组(3, 11, 13), 数组(12, 14, 16, 27, 29), 数组(1, 3, 13, 15, 16), 数组(14, 16), 数组(13, 14, 15, 17,
			18, 24, 26), 数组(16, 18, 24, 26), 数组(16, 17, 19), 数组(18, 20), 数组(17, 19, 21), 数组(20, 22), 数组(21, 23, 40), 数组(22, 24, 25, 38),
			数组(16, 17, 23), 数组(6, 23, 26), 数组(16, 17, 25), 数组(9, 13, 28, 29), 数组(1, 27, 29), 数组(9, 13, 27, 28, 30), 数组(29, 31, 33, 34, 36),
			数组(30, 32, 34), 数组(31, 38), 数组(9, 30, 34), 数组(30, 31, 33, 35, 37), 数组(34, 36), 数组(30, 35), 数组(34, 38, 41), 数组(37, 39, 40, 43),
			数组(38, 40, 41), 数组(38, 39), 数组(37, 39, 42), 数组(35, 41), 数组(0, 1, 38), 数组(3));
		全局.Distance_Matrix = 数组(自定义字符串(
			"01234523456787656765678878767655654563233451410123412345676545654567767656555654563233451321012323456765434543456656567666765674"),
			自定义字符串(
			"34456223210123456765432343234554545656787677545567314321014565654321232123443434545676676656578423232103454543212233234543433434"),
			自定义字符串(
			"56556554556733212345012345656567656788787454567656643445624323456101234545656667887676343456556554556735434567210123434545567876"),
			自定义字符串(
			"56523234544545566674643445632101232343445676545412123433434566564554434543210123454555677656523234544545677675454323454321012343"),
			自定义字符串(
			"44456654543434565565667778534321234543210123233345543432323454454556667423232343432321012122345432321212343343445556332121232343"),
			自定义字符串(
			"43210112234543232232345445443445622323234345454321012234543232343456556554556733323234344343211101123432121232345445443445633434"),
			自定义字符串(
			"34534545432221012343212134345655654344564443434545545432221101234323234345655655455674454545656656543332210123434345456766766554"),
			自定义字符串(
			"67555454564565654333212101232324545676676544356555565674566765444323210123335656676567433245464455673456765444334321012235655565"),
			自定义字符串(
			"45632213436334456234565433322343210112454445434521223425434345345454322211234321022343456545532334534323456123455433322344321201"),
			自定义字符串(
			"45455654563233453543434523445432221123443221034345655654344564432334533212321232334565434301123433434455563421234523323432343445"),
			自定义字符串(
			"67654541012343343434456243233453321232123233456543431101232232345545344344564432343234344567654542210121121234434454455675543454"),
			自定义字符串(
			"34545567876565332101212222333436334567455456545656678987676443210323321223426545567432123434545567876565232123012223443446445567"),
			自定义字符串(
			"54323443454556787656533211210121233233655667865434554565667898767644322321012344344754556755434543454556787656533212322103455455"),
			自定义字符串(
			"63345674543455456566789876764432232123012212262234563454566566677678987875543343234101123153345674565677677788789!98986654454334"),
			自定义字符串(
			"210112263345674565677677788789!9898665445434521102326445678565456656767789!98787554334322312120137556789665456656767789!98787554"),
			自定义字符串("334321223231048112345234567766567656788787665445434521223404432123456787654345434566565676789878865667840"));
		全局.Elevator_Nodes = 空数组;
		If(全局.Gamemode == 0);
			全局.Objective_Spawns = 数组(矢量(206.490, 0.038, 83.602), 矢量(186.912, 0.998, 71.243), 矢量(178.286, -0.002, 51.719), 矢量(206.259, 9.001,
				83.563), 矢量(229.227, 9.002, 78.204), 矢量(196.950, 16.499, 69.406), 矢量(216.754, 14, 66.507));
		Else If(全局.Gamemode == 1);
			全局.Objective_Spawns = 数组(矢量(206.094, 2, 77.597), 矢量(232.886, 4, 93.877), 矢量(230.416, 6, 107.918), 矢量(193.307, 11, 113.551), 矢量(
				180.089, 11, 101.823), 矢量(205.915, 11.043, 93.960), 矢量(168.798, 7, 81.112), 矢量(173.483, 9, 57.292), 矢量(189.454, 5, 56.301), 矢量(
				196.295, 18.500, 68.985), 矢量(206.485, 10, 51.593), 矢量(206.259, 10.999, 81.079), 矢量(218.594, 10, 85.339), 矢量(224.043, 3,
				78.247), 矢量(182.628, 3, 83.080));
		End;
		全局.Player_Spawn = 矢量(193.401, 7.998, 101.316);
		全局.Player_Spawn_Facing = 后;
		全局.Ability_Buy_Location = 矢量(182.587, 8.998, 105.229);
		全局.Buy_Menu_Left_Up_Forward[2] = 前;
		全局.Buy_Menu_Left_Up_Forward[1] = 与此角度的相对方向(与此方向的水平角度(全局.Buy_Menu_Left_Up_Forward[2]), 与此方向的垂直角度(全局.Buy_Menu_Left_Up_Forward[2])
			- 90);
		全局.Buy_Menu_Left_Up_Forward[0] = 矢量积(全局.Buy_Menu_Left_Up_Forward[1], 全局.Buy_Menu_Left_Up_Forward[2]);
		全局.Buy_Menu_Cam_Pos = 900 * 上;
		全局.Buy_Menu_Pos = 全局.Buy_Menu_Cam_Pos - 9 * 全局.Buy_Menu_Left_Up_Forward[1] + 142 * 全局.Buy_Menu_Left_Up_Forward[2];
		全局.Max_Speed_Bonus = 200;
	}
}

规则("Subroutine (Set Map HW): Set Spawns, Nodes, Edges, Distance Matrix, Drop-off Location, Ability Buy Location")
{
	事件
	{
		子程序;
		Set_Map_HW;
	}

	动作
	{
		全局.Spawns = 数组(矢量(32.162, 1.858, -76.223), 矢量(7.311, 1.750, -9.776), 矢量(3.434, 1.749, -33.193), 矢量(9.683, 10.750, -34.200), 矢量(
			9.031, 11.010, -63.895), 矢量(-19.619, 5.750, -53.960), 矢量(40.862, 2.751, -52.804), 矢量(5.551, 2, -58.146), 矢量(19.447, 1.748,
			-92.450), 矢量(30.742, 1.750, -29.112));
		全局.Spawns_Nearest_Nodes_by_Index = 数组(38, 12, 5, 3, 57, 29, 50, 19, 41, 53);
		全局.Nodes = 数组(矢量(7.216, 1.604, -47.096), 矢量(21.866, 1.604, -51.590), 矢量(24.704, 1.625, -36.591), 矢量(13.630, 10.811, -31.838), 矢量(
			11.498, 1.746, -25.278), 矢量(7.252, 1.750, -31.696), 矢量(4.005, 3.731, -22.661), 矢量(2.741, 5.731, -27.821), 矢量(5.881, 5.825,
			-26.546), 矢量(1.567, 5.750, -35.879), 矢量(12.925, 1.608, -19.301), 矢量(14.985, 1.749, -11.132), 矢量(5.310, 1.749, -4.232), 矢量(
			-7.468, 1.604, -11.193), 矢量(-3.018, 1.604, -17.408), 矢量(-6.370, 1.604, -33.467), 矢量(-0.522, 1.604, -41.410), 矢量(-1.512, 1.604,
			-48.815), 矢量(-2.671, 2, -56.240), 矢量(11.121, 2.005, -58.854), 矢量(-4.941, 3.999, -64.379), 矢量(10.918, 6.001, -68.476), 矢量(
			13.423, 6.001, -60.447), 矢量(10.260, 6.001, -55.292), 矢量(1.697, 6.001, -53.146), 矢量(-8.920, 1.728, -52.186), 矢量(-6.518, 10.268,
			-58.863), 矢量(-9.309, 1.729, -67.564), 矢量(-16.190, 3.750, -44.163), 矢量(-25.793, 5.751, -46.135), 矢量(-20.183, 5.750, -62.151),
			矢量(-16.025, 5.750, -63.472), 矢量(-18.989, 1.729, -75.993), 矢量(4.236, 1.604, -80.231), 矢量(6.617, 2, -69.064), 矢量(0.908, 2.001,
			-60.908), 矢量(16.038, 1.604, -72.207), 矢量(23.400, 1.896, -75.571), 矢量(30.262, 1.858, -77.540), 矢量(26.017, 1.913, -80.019), 矢量(
			17.961, 1.607, -83.513), 矢量(26.877, 1.617, -88.939), 矢量(35.012, 1.604, -84.689), 矢量(40.474, 1.604, -70.979), 矢量(34.416, 1.604,
			-68.641), 矢量(20.808, 1.604, -62.815), 矢量(36.259, 2.750, -61.829), 矢量(31.349, 2.750, -60.858), 矢量(32.748, 2.750, -54.877), 矢量(
			45.664, 2.750, -64.193), 矢量(49.963, 2.750, -53.355), 矢量(37.506, 2.750, -43.215), 矢量(39.516, 2.750, -32.389), 矢量(33.531, 1.750,
			-30.442), 矢量(4.905, 10.750, -32.573), 矢量(8.510, 12.837, -38.647), 矢量(7.083, 12.835, -57.660), 矢量(5.472, 11.010, -64.002), 矢量(
			28.022, 6.797, -77.052), 矢量(5.539, 10.750, -37.649));
		全局.Nodes_Count = 数量(全局.Nodes);
		全局.Edges = 数组(数组(1, 16, 17, 19), 数组(0, 2, 19, 45, 48), 数组(1, 3, 4, 53), 数组(2, 4, 54), 数组(2, 3, 5, 6, 10), 数组(4, 16), 数组(4, 7), 数组(
			6, 8, 9), 数组(4, 7), 数组(7, 15, 16), 数组(4, 11, 14), 数组(10, 12), 数组(11, 13), 数组(12, 14), 数组(10, 13, 15), 数组(14, 16), 数组(0, 5, 15,
			17), 数组(0, 16, 18, 25), 数组(17, 19, 20, 35), 数组(0, 1, 18, 35, 45), 数组(18, 21), 数组(20, 22, 36), 数组(1, 21, 23), 数组(0, 22, 24), 数组(
			17, 23), 数组(17, 26, 27, 28), 数组(25, 27, 57), 数组(25, 26, 32, 33), 数组(25, 29), 数组(28, 30), 数组(29, 31), 数组(27, 30, 32), 数组(27, 31,
			33, 34), 数组(27, 32, 34, 36, 40), 数组(32, 33, 35), 数组(18, 19, 34), 数组(33, 37, 40, 45, 58), 数组(21, 36, 38, 39), 数组(37), 数组(37,
			42), 数组(33, 36, 41), 数组(40, 42), 数组(39, 41, 43), 数组(42, 44), 数组(43, 45, 46), 数组(1, 19, 36, 44), 数组(44, 47, 49), 数组(46, 48), 数组(
			1, 47, 51), 数组(46, 50), 数组(49, 51), 数组(48, 50, 52), 数组(51, 53), 数组(2, 52), 数组(3, 15, 55, 59), 数组(16, 54, 56), 数组(55, 57), 数组(
			21, 26, 56), 数组(41, 42, 44), 数组(54));
		全局.Distance_Matrix = 数组(自定义字符串(
			"01233245664554321121345672333455443234554554324325434345544510122334553455432221345673444565433223443443213214323234553421011223"),
			自定义字符串(
			"44234433333245678455567654433455455432432543212345433210122344234432344355678556678765544566566543543654321234523211011233123323"),
			自定义字符串(
			"23435678945556776554456656654354365432234553232210234423443212334567834445665554567767765465476543345564432212012223443334546789"),
			自定义字符串(
			"!56667887665567767765465476543345664343323101134543223445678945556776665678878876576587654456675432212210223443334546789!5666788"),
			自定义字符串(
			"7665567767765465476543345664234432212034432112334567834445665554567767765465476565566566432212234401221234546789!566678876655677"),
			自定义字符串(
			"6776546547654334566454332334551012234565789!?6777899877667887887657658765445677555443445662101234566789!?67778998887789989987687"),
			自定义字符串(
			"698765567886454434456622101234556789!5666788777678998998768769876556778634332334551221012344567894555677666567887887657658765445"),
			自定义字符串(
			"66752344324566233210123345678344456655545677677654654765655665661233213455344321012234567233345544434566566543543654544554551234"),
			自定义字符串(
			"32456645543210122345612223443332456645654354365454554356223443567756654321011234523334543321345545543244355454565446112333456645"),
			自定义字符串(
			"65432210234563444554332123443443213324434345653533455467886776543212012343444565433223443445435546656567653732344556775677654323"),
			自定义字符串(
			"10123443565432331233233432443554545665262123344566456654333221012454566543432344344432432543434566351234435677566543223232101344"),
			自定义字符串(
			"45665443345545554354365454566546234543567756654321233321023334554443456656665465476565665457234543567756654321233345601112332233"),
			自定义字符串(
			"34553456546547656554324634555467886776543234323451012343223434553456546657767643214534565467886776543234434561102332112323442345"),
			自定义字符串(
			"43565676765432363456546788677654323444567122012333444566456765765876766543574567657899788765434555678233101234455677567876876987"),
			自定义字符串(
			"8776546856787689!!89987654556567833221012334456645676578789898765458456765789978876543445456722132101223345534565467678787654347"),
			自定义字符串(
			"44566578997887654333445672213321011223442345435656767665433743455567886787654333434562213432101212331234324545656565432733455567"),
			自定义字符串(
			"88678765432234567332443211012344234543554665656654372234445677567654321123456343454322103455345432443554545665463234455677567765"),
			自定义字符串(
			"44323234533245432123012212232134345454565416434556678867887654332123444356543234101123233245456565676527545667789978998765443234"),
			自定义字符串(
			"55546765434521023434435656767678763854566778997899876544323455546765434521203212334555667678763843455667886788765443434563324543"),
			自定义字符串(
			"21231233012332454565656654275456677899789987655454567443565432342342101233455566767765385456677899789987665443456554676543453231"),
			自定义字符串(
			"21012334545676787648434556678867887655435456766578765454334232101223434565678747323445567756776544324456755467654343234333210112"),
			自定义字符串(
			"32345456763621233445664566543321334564435654323212332332102323434345652543455667886788765543556786657876545434544432120121234567"),
			自定义字符串(
			"87473234455677567765444356789566678765544565554323101232345677562123344566456654333245678455567654433455455432210321234566455456"),
			自定义字符串(
			"67789978998766546678977689876565456555432312301234789858434556678867887655546789!67778987665567666543423210123678867323445567756"),
			自定义字符串(
			"776544435678956667876554456656654332121012567756432334456645665555546789!6777898766556776776544323210145676532122334553455444443"),
			自定义字符串(
			"56789566678765544566566543543432103456543321233455344321234454567445567766655677677654654765430123612332324566455432123343456334"),
			自定义字符串(
			"45665554456656665465476554101252344343567756654323443234532345654455345545565466577665210143434454678867765433342123421234543344"),
			自定义字符串(
			"23443445435546656532103443455667886788765543545675546765434433422112122343456567760744323445664554323455656785566788777667887887"),
			自定义字符串("6576587654123470"));
		全局.Elevator_Nodes = 映射的数组(数组(3, 26), 全局.Nodes[当前数组元素]);
		If(全局.Gamemode == 0);
			全局.Objective_Spawns = 数组(矢量(40.614, 2.753, -54.203), 矢量(9.852, 10.750, -34.956), 矢量(7.353, 1.750, -9.932), 矢量(14.392, 1.748,
				-39.434), 矢量(-17.052, 5.750, -39.328), 矢量(-6.179, 1.604, -8.254), 矢量(8.136, 12.903, -44.515), 矢量(5.750, 1.748, -29.563));
		Else If(全局.Gamemode == 1);
			全局.Objective_Spawns = 数组(矢量(-5.524, 3.604, -9.938), 矢量(14.790, 3.622, -23.429), 矢量(12.079, 12.750, -36.755), 矢量(8.001, 14.903,
				-48.563), 矢量(0.909, 13.010, -61.261), 矢量(-10.019, 3.729, -64.738), 矢量(5.634, 3.604, -77.228), 矢量(23.379, 8.797, -80.548), 矢量(
				45.175, 4.753, -53.387), 矢量(21.188, 3.604, -53.165), 矢量(11.568, 8.003, -57.471));
		End;
		全局.Player_Spawn = 矢量(-0.135, 1.604, -79.182);
		全局.Player_Spawn_Facing = 前;
		全局.Ability_Buy_Location = 矢量(-24.938, 5.750, -39.536);
		全局.Buy_Menu_Left_Up_Forward[2] = 与此角度的相对方向(104.293, 0);
		全局.Buy_Menu_Left_Up_Forward[1] = 与此角度的相对方向(与此方向的水平角度(全局.Buy_Menu_Left_Up_Forward[2]), 与此方向的垂直角度(全局.Buy_Menu_Left_Up_Forward[2])
			- 90);
		全局.Buy_Menu_Left_Up_Forward[0] = 矢量积(全局.Buy_Menu_Left_Up_Forward[1], 全局.Buy_Menu_Left_Up_Forward[2]);
		全局.Buy_Menu_Cam_Pos = 矢量(-17.744, 10.325, -132.479);
		全局.Buy_Menu_Pos = 全局.Buy_Menu_Cam_Pos - 9 * 全局.Buy_Menu_Left_Up_Forward[1] + 142 * 全局.Buy_Menu_Left_Up_Forward[2];
		全局.Max_Speed_Bonus = 160;
		创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(18.819, 1.604, -73.185), 1.500, 可见);
		创建效果(所有玩家(所有队伍), 火花, 颜色(绿色), 矢量(18.819, 2.604, -73.185), 1.500, 可见);
	}
}

规则("Subroutine (Set Map KZ): Set Spawns, Nodes, Edges, Distance Matrix, Drop-off Location, Ability Buy Location")
{
	事件
	{
		子程序;
		Set_Map_KZ;
	}

	动作
	{
		全局.Spawns = 数组(矢量(-44.374, 13, -24.060), 矢量(-18.848, 7.010, -51.298), 矢量(9.570, 7, -30.631), 矢量(13.187, 9, 1.367), 矢量(-16.009,
			6.003, 17.628), 矢量(-10.628, 10, 35.953), 矢量(-48.612, 9, -1.421), 矢量(-28.339, 10, -28.557), 矢量(-17.588, 6, -32.870), 矢量(-16.627,
			10.500, 19.926));
		全局.Spawns_Nearest_Nodes_by_Index = 数组(40, 8, 13, 16, 48, 24, 35, 58, 62, 84);
		全局.Nodes = 数组(矢量(-57.745, 11, -23.567), 矢量(-64.493, 12, -23.469), 矢量(-64.793, 12, -28.813), 矢量(-56.606, 11, -35.530), 矢量(-50.409,
			11, -37.201), 矢量(-48.527, 11, -42.566), 矢量(-41.002, 9, -52.924), 矢量(-31.274, 7, -48.636), 矢量(-15.430, 7.010, -52.978), 矢量(
			-9.183, 7, -48.948), 矢量(-0.679, 9, -46.717), 矢量(6.245, 8, -42.850), 矢量(14.043, 8, -35.507), 矢量(9.824, 7, -27.191), 矢量(10.297,
			6, -14.229), 矢量(3.864, 6, -9.125), 矢量(10.943, 9, 1.543), 矢量(4.381, 6, 11.938), 矢量(-2.392, 6, 7.376), 矢量(-5.553, 5.840, 12.159),
			矢量(-1.449, 5.840, 16.740), 矢量(1.975, 7, 21.756), 矢量(-9.348, 9.976, 26.746), 矢量(-11.187, 10, 32.880), 矢量(-11.105, 10, 38.915),
			矢量(-6.826, 10, 33.262), 矢量(-5.953, 8, 43.956), 矢量(-15.581, 6, 43.905), 矢量(-15.745, 6, 39.415), 矢量(-31.815, 4, 40.056), 矢量(
			-32.350, 5.840, 32.238), 矢量(-44.337, 6, 32.421), 矢量(-52.857, 8, 32.452), 矢量(-51.537, 8, 21.301), 矢量(-54.296, 8, 9.628), 矢量(
			-49.831, 9.094, 1.211), 矢量(-49.397, 9, -5.901), 矢量(-52.609, 11, -13.299), 矢量(-57.902, 11, -13.920), 矢量(-50.515, 13, -23.434),
			矢量(-44.526, 13, -22.963), 矢量(-44.331, 11, -12.532), 矢量(-29.495, 10.908, -9.049), 矢量(-17.983, 10, -9.776), 矢量(-20.945, 10,
			-0.908), 矢量(-28.498, 10, 2.547), 矢量(-25.321, 8, 8.752), 矢量(-18.776, 5.846, 5.933), 矢量(-16.009, 6.003, 17.952), 矢量(-10.031,
			5.841, 5.090), 矢量(-3.238, 6, -8.550), 矢量(-2.163, 4.931, -31.039), 矢量(2.845, 7, -36.798), 矢量(4.657, 7, -24.850), 矢量(-15.378,
			4.937, -43.494), 矢量(-31.746, 7, -44.202), 矢量(-37.194, 7, -38.181), 矢量(-29.988, 8, -36.736), 矢量(-35.582, 9.997, -28.202), 矢量(
			-42.034, 10, -31.379), 矢量(-42.982, 11, -35.521), 矢量(-24.017, 6.999, -34.551), 矢量(-21.081, 6, -30.270), 矢量(-12.755, 6, -34.710),
			矢量(-6.027, 6, -28.599), 矢量(-7.447, 6, -20.156), 矢量(-13.566, 8, -25.324), 矢量(-8.646, 10.046, -30.591), 矢量(-12.240, 10.011,
			-34.166), 矢量(-20.360, 10, -27.022), 矢量(-21.702, 10, -18.888), 矢量(-37.613, 7.005, -21.887), 矢量(-24.508, 5.840, -11.737), 矢量(
			-12.319, 6, -12.988), 矢量(-33.022, 5.840, -3.182), 矢量(-40.508, 7, -6.694), 矢量(-40.675, 5.842, 10.985), 矢量(-48.897, 8, 9.746),
			矢量(-25.787, 5.842, 12.430), 矢量(-26.369, 5.840, 26.954), 矢量(-16.398, 5.840, 26.966), 矢量(-45.919, 5.998, 26.509), 矢量(-45.327, 6,
			21.514), 矢量(-26.414, 10.002, 21.726), 矢量(-16.097, 11.152, 16.806), 矢量(-21.545, 10.819, 13.520), 矢量(-9.966, 10.484, 21.888));
		全局.Nodes_Count = 数量(全局.Nodes);
		全局.Edges = 数组(数组(1, 3, 38, 39), 数组(0, 2), 数组(1, 3), 数组(0, 2, 4, 5), 数组(3, 5, 39, 60), 数组(3, 4, 6, 56), 数组(5, 7), 数组(6, 8, 55, 56,
			57), 数组(7, 9), 数组(8, 10, 54), 数组(9, 11, 52, 68), 数组(10, 12, 52), 数组(11, 13), 数组(12, 14, 53), 数组(13, 15, 50), 数组(14, 16, 50, 51,
			53), 数组(15, 17), 数组(16, 18), 数组(17, 19), 数组(18, 20, 48, 49), 数组(19, 21), 数组(20, 22), 数组(21, 23, 86), 数组(22, 24, 25), 数组(23,
			28), 数组(23, 26), 数组(25, 27), 数组(26, 28), 数组(27, 29, 80), 数组(28, 30), 数组(29, 31, 79, 80), 数组(30, 32, 81), 数组(31, 33), 数组(32, 34,
			77, 81, 82), 数组(33, 35), 数组(34, 36, 77), 数组(35, 37, 75), 数组(36, 38, 41), 数组(0, 37), 数组(0, 4, 40), 数组(39, 41), 数组(36, 37, 40,
			42, 71, 75), 数组(41, 43, 71, 72, 74), 数组(42, 44, 72), 数组(43, 45, 72), 数组(44, 46), 数组(45, 47, 78), 数组(46, 48, 49, 78), 数组(19,
			47), 数组(19, 47, 50, 78), 数组(14, 15, 49, 51, 65), 数组(15, 50, 52, 54, 64), 数组(10, 11, 51, 53), 数组(13, 15, 51, 52, 64, 65), 数组(7,
			9, 51, 55, 61), 数组(7, 54, 56, 57), 数组(7, 55, 57, 71), 数组(7, 55, 56, 58, 61), 数组(57, 59, 69, 71), 数组(58, 60), 数组(4, 59), 数组(54,
			57, 62), 数组(61, 63), 数组(62, 64), 数组(51, 63, 65), 数组(50, 64, 66, 73), 数组(65, 67), 数组(51, 64, 66, 68), 数组(10, 54, 61, 67, 69),
			数组(58, 68, 70), 数组(69, 71, 72, 73), 数组(56, 70, 72, 75), 数组(71, 73, 74), 数组(65, 72), 数组(72, 75, 76), 数组(36, 71, 74, 76), 数组(74,
			75, 77, 78), 数组(33, 35, 76), 数组(47, 49, 76, 79), 数组(30, 78, 80, 81), 数组(28, 30, 79), 数组(31, 79, 82), 数组(33, 81, 83), 数组(78, 79,
			82, 84), 数组(83, 85, 86), 数组(47, 78, 84), 数组(22, 84));
		全局.Distance_Matrix = 数组(自定义字符串(
			"012122345678998789989!?#$#?!998876543211234567878776785434543567778876545654556787789!!101233456789!!989!!9!?#$%$#?!!99876543223"),
			自定义字符串(
			"4567898988789654565467888998765676566789889!??210122345678998789!9!?#$%$#?!!9!98765433456789989876785434543567778876545665677899"),
			自定义字符串(
			"9!?##121011234567887678989!?#$#?!99898765432234567887876567432343245666776543455456678889!??232101234567887678989!?#$#?!99898765"),
			自定义字符串(
			"443123456787876567432332145666765443455456678889!??2321101234567765678789!?#?!98878766544323456787676545632123323455566543234434"),
			自定义字符串(
			"55677789!!3432210123456765678789!?##?!99898776554345678987865456322234334556765443455456678889!??45433210123456545676789!??!9887"),
			自定义字符串(
			"876654554567898767543452111234234456543323443455677789!!56544321012345545676789!???!99898776566567899876754334222234534545543443"),
			自定义字符串(
			"455456678889!?!676554321012344345656789!!!988789887677678998765643223123345623434432344556567567789!?9787665432101234345656789!!"),
			自定义字符串(
			"!988789887678788998765643212234334523433321234445567567789!?9898776543210123345656789!!!988789898789899!987656432123454456344334"),
			自定义字符串(
			"32345546667567789!?99!9887654321012345656789!!!98878989889!9!!!98765643322456556745433443456546767567789!?9898776545432101234545"),
			自定义字符串(
			"6789998776787877898999876545322213455678443223445654356564566789!889877654544321012343456788876656767667889887654342123234556784"),
			自定义字符串(
			"54323456654355453455678977876654343333210123345678887665676766787888765434211212344567343223445654355453455678978987765454444321"),
			自定义字符串(
			"012345678898776787877898999876544322323455678454334556765466564566788979!98876565555432101234567788776787877899!9987654333343456"),
			自定义字符串(
			"6789565445667876566564566787869!!998767666654321012345667766567676678!98876543223454567789!6765456787665554534556767589988765655"),
			自定义字符串(
			"55433321012345566554565655679877654321123444566789565434567655444342344565649!!998767666654443210123445656567676678!988765432234"),
			自定义字符串(
			"55567789!67654567876655545345565453!??!!9878777765554321012334545677677789?!998765433456667889!?78765678987766656455654342!?#??!"),
			自定义字符串(
			"989888876665432101223434566567789?!99876544456777889!?#89876789987776656444543231?#$##?!9!99998777654321011232345667889!#?!!9876"),
			自定义字符串(
			"5556788899!?#$9!98789!!98887767543554342!?#?#?!9!999987787654321023212345677789?!9!987656567888989!?#9!98789!987786656432455453#"),
			自定义字符串(
			"$%$$#?!?!!!!988876543212012345677899!?$#??!98766678999!!?#$%!?!989!??!9998878654665453?#$#$#?!?!!!!9889876543231012345678889!#?!"),
			自定义字符串(
			"?!98767678999!9!?#$!?!989!?!98897767543566564!?#?#?!9!999987788766543421012345677789?!9!987656567888989!?#9!98789!98778665643245"),
			自定义字符串(
			"66759!?!?!989888876677656654532101234566678!9898765454567778789!?898767898766755453213456769!?!?!9898888766776567656432101234566"),
			自定义字符串(
			"78!9898765454567778789!?8987678987667554532234567789!9!9878777765566545676754321012345567987876543434566676789!78765678765564434"),
			自定义字符串(
			"21123456689!9!!98988887667765676786543210123456798788765454567778789!?8987678987667554332212345578989987899998778876776787654321"),
			自定义字符串(
			"0123456876788765656788876789!899878987655644324332234556787887678888766776566567765443210123457656776545456777656789788767876544"),
			自定义字符串(
			"53321323112344567677767889987788767767887655432101234654567765656788765678878987887654564332434223455456566656778876677656778998"),
			自定义字符串(
			"766543210123543456654545677654567767876776543453221345334566345455545667876677656789!9876655432101243234565454567754345665676566"),
			自定义字符串(
			"543234212234544567723434454566788778876789!?!98776654321013212345656566785434565567656654323432334565567881232334567789988998789"),
			自定义字符串(
			"!?#?!9887765432102323456767677896545654678767765434543445676678991232123456789987898789!?#?!988787654332012345676767678543443256"),
			自定义字符串(
			"7767765434543455677789!!23432344566788778876789!?!987767654322310123456565667854345435676566543234323445666789934543443455677667"),
			自定义字符串(
			"7656789!98766565432112210123454545567432345445654554321232123345556788456545434556765567656789!987665654432233210123445445664323"),
			自定义字符串(
			"4554554345432112122334555678856765654566776556776789!?!9877676554334432101234554566543456656543455432122334456667899678766545667"),
			自定义字符串(
			"765567656789!9876656656544554321012344456654345675654345543212233434556789978987765677776556654567898765545656555665432101233456"),
			自定义字符串(
			"66545678676545665432334342344567887898887676666544554345678765443454544567654321012234555656789676545676543433231233456777898876"),
			自定义字符串(
			"5655554334432345677654434545445687654321011234445567895654345665444332312334567689!998767666654443212345667655456565567987654321"),
			自定义字符串(
			"023455566789!6765456776555443423445667578877654544443223321234566654434545445687665432120123334556784543234565443332312334567578"),
			自定义字符串(
			"76654343333211233234567776554565655677877654323101222344567343212345543244342344567866765543232223321234345678887665676766776788"),
			自定义字符串(
			"76543421012123345623212343454435545345567897787665433211223234545678999877678787788789987654532101234445634322332345435656456678"),
			自定义字符串(
			"9!87876654343222121234456789998776787876787889876545321102344567332112334543245564566789!856544321212344323454567899987767877656"),
			自定义字符串(
			"65678876545321230122345123234434434454564566789!8565443212234554345656789!!!9887876654565667887656432341011234234345543323443455"),
			自定义字符串(
			"677789!956544321234566545676789!?!987767655434556567876565434521012342344455432123323445666789956544321234566545676789!??!988787"),
			自定义字符串(
			"6654565667898767543452110123123455432323443455677789!!56543432343456656776789!?!987767655434545567876565544532210122344443212123"),
			自定义字符串(
			"32344566678994543234345456776788789!?#?!9887876654553456788767665564332101345555432323443455677789!!343212345656788789989!?#$#?!"),
			自定义字符串(
			"99898776554234567887877667543321045666654343455456678889!??676554323234554345656789!!!988788776567677898765643234122123401234554"),
			自定义字符串(
			"343455456567789!?978766543434566545676789!???!998998876787889!987675434523323451012345545454656767889!?#!89877654544455434565678"),
			自定义字符串(
			"9!!!988789898789899!98765643234344345621012345565435667567789!?97876654343334432345456789998776787876787889876545321232344567321"),
			自定义字符串(
			"012345543245564566789!8898776545444432234434567888766567676567887876543421233344556743210123443213445345567897898776545434543345"),
			自定义字符串(
			"5456789998776787876788989876545322343454456343210123443245564566789!878766543432344323454567899987767878767878898765453212323433"),
			自定义字符串(
			"45232121012344355564566789!8676554323212344345656789!!!988788776567677898765643223123223412323210123334456567789!?96765454343234"),
			自定义字符串(
			"5545676789!??!9887876654565667898767543342332123234333210122233455677789!!677655434434554456656789!!9877676554345665678765643445"),
			自定义字符串(
			"332323434432332101112234456667899566554323445665567656789!9876656544323465456765454445632123453454344321012212334555678867766543"),
			自定义字符串(
			"4556654456656789!987665654543457656776545434554323456454323443210112233455567887887765455555433455456789998776765654568767876545"),
			自定义字符串(
			"32344443456754321234432102334456667898567676545667765566545678987655454343234654566543434566543456756543455432120112234445677456"),
			自定义字符串(
			"56543455676556654567898765545433212354345654343456643234564565455432123101223444567756767654566665445543456787654434323223465456"),
			自定义字符串(
			"54323234555434567566545654322311011233345665676776567777655665456678876554321212346545665434345666545678677656765433422102342234"),
			自定义字符串(
			"55678787656555543344323456765433234343345765654321212344454567856543456543342212012234566789898767666654455434566754322123344456"),
			自定义字符串(
			"87676543232345556567896765456765445332310112345589!9!9878777765566545665643212123455567987876543434566676789!7876567876556443421"),
			自定义字符串(
			"023456689!9!9878777765566545656765433212234567987876543434566676789!787656787655644332120123447898998787777655665455456665443221"),
			自定义字符串(
			"23456876776543434566676789!78765678765564432223101233789898767666654455434434555433233234456876765432323455565678967654567654453"),
			自定义字符串(
			"32311221012289!9!9878777765566544323445544344345567987765432334566676789!7876567876556443422332101178989876766665445543443455654"),
			自定义字符串(
			"43454544568766543212234555656789676545676544533231233321029!?!?!989888876676543212334545455456678!9887654344567778789!?898767898"),
			自定义字符串("76675545334432120"));
		全局.Elevator_Nodes = 空数组;
		If(全局.Gamemode == 0);
			全局.Objective_Spawns = 数组(矢量(-15.532, 10.500, 14.441), 矢量(-28.901, 4, 43.960), 矢量(3.255, 9, 3.597), 矢量(-19.108, 6, -26.369), 矢量(
				-17.138, 7.010, -55.135), 矢量(-6.185, 10, -40.945), 矢量(-10.539, 10, 38.697), 矢量(9.680, 6, -18.428));
		Else If(全局.Gamemode == 1);
			全局.Objective_Spawns = 数组(矢量(-38.507, 13.076, -10.920), 矢量(-28.974, 6, 43.453), 矢量(-31.503, 7.840, 26.739), 矢量(-26.719, 12.002,
				20.539), 矢量(-6.265, 7.840, 11.249), 矢量(-26.818, 7.842, 13.505), 矢量(4.102, 9, -27.173), 矢量(-8.438, 12.338, -36.965), 矢量(-19.188,
				6.928, -44.688), 矢量(-50.823, 15, -27.853), 矢量(-10.496, 12.485, 22.844), 矢量(-35.699, 7.842, 1.479), 矢量(-21.574, 12, 0.821));
		End;
		全局.Player_Spawn = 矢量(-35.165, 5.840, -1.346);
		全局.Player_Spawn_Facing = 前;
		全局.Ability_Buy_Location = 矢量(7.110, 9, 1.632);
		全局.Buy_Menu_Left_Up_Forward[2] = 前;
		全局.Buy_Menu_Left_Up_Forward[1] = 与此角度的相对方向(与此方向的水平角度(全局.Buy_Menu_Left_Up_Forward[2]), 与此方向的垂直角度(全局.Buy_Menu_Left_Up_Forward[2])
			- 90);
		全局.Buy_Menu_Left_Up_Forward[0] = 矢量积(全局.Buy_Menu_Left_Up_Forward[1], 全局.Buy_Menu_Left_Up_Forward[2]);
		全局.Buy_Menu_Cam_Pos = 900 * 上;
		全局.Buy_Menu_Pos = 全局.Buy_Menu_Cam_Pos - 9 * 全局.Buy_Menu_Left_Up_Forward[1] + 142 * 全局.Buy_Menu_Left_Up_Forward[2];
		全局.Max_Speed_Bonus = 200;
	}
}

规则("All Teams HW: Jump Pad")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(当前地图 == 地图(好莱坞) || 当前地图 == 地图(万圣节好莱坞)) == 真;
		相距距离(事件玩家, 矢量(18.819, 1.604, -73.185)) <= 1.500;
		(所在队伍(事件玩家) == 队伍2 ? 按钮被按下(事件玩家, 按钮(跳跃)) && !(具有状态(事件玩家, 击晕) || 事件玩家.Downed_since) : !事件玩家.Is_using_Combat_Pathfinding && (
			事件玩家.Nav_Index == 21 || 事件玩家.Nav_Index == 58) && 存活(事件玩家)) == 真;
	}

	动作
	{
		施加推力(事件玩家, 上, 22, 至地图, 取消相反运动XYZ);
		播放效果(所有玩家(所有队伍), 爆炸声音, 颜色(白色), 矢量(18.819, 1.604, -73.185), 200);
		等待(0.250, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Subroutine: Update Combatants")
{
	事件
	{
		子程序;
		Update_Combatants;
	}

	动作
	{
		全局.Combatants = 已过滤的数组(所有玩家(队伍2), 当前数组元素.Is_Combatant);
		全局.Combatants_Count = 数量(全局.Combatants);
	}
}

规则("Subroutine: Scale Damage")
{
	事件
	{
		子程序;
		Scale_Damage;
	}

	动作
	{
		If(全局.Gamemode == 0);
			设置造成伤害(所有玩家(队伍1), (全局.Mutators_activated ? 1.100 : 1) * (全局.Mut_EMP_Rounds ? 2 : 1) * (109 + 10.500 * (全局.Wave + 2 * 较大(0,
				全局.Wave - 12))) * (0.150 + 0.150 * 全局.Combatants_Count));
		Else;
			设置造成伤害(所有玩家(队伍1), (全局.Mutators_activated ? 1.100 : 1) * (全局.Mut_EMP_Rounds ? 2 : 1) * (104.500 + 16.500 * (全局.Wave + 2 * 较大(0,
				全局.Wave - 9))) * (0.150 + 0.150 * 全局.Combatants_Count));
		End;
	}
}

规则("Subroutine: Declare Victory")
{
	事件
	{
		子程序;
		Declare_Victory;
	}

	动作
	{
		等待(2, 无视条件);
		宣告队伍胜利(队伍2);
	}
}

规则("Global (First Wave): Create Mutator Start HUD, Scale Values, Set Level")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.Wave == 0;
		对任意为”真“(全局.Combatants, 按钮被按下(当前数组元素, 按钮(互动)) && 相距距离(当前数组元素, 全局.Ability_Buy_Location) > 2) == 真;
	}

	动作
	{
		消除HUD文本(全局.Game_Start_HUD);
		开启游戏预设音乐模式;
		设置队伍分数(队伍2, 1);
		全局.Wave = 1;
		设置终极技能充能(全局.Combatants, 0);
		调用子程序(Scale_Damage);
		此栏位的玩家(0, 队伍1).Level = 1;
		此栏位的玩家(1, 队伍1).Level = 1;
		此栏位的玩家(2, 队伍1).Level = 1;
		此栏位的玩家(3, 队伍1).Level = 1;
		此栏位的玩家(4, 队伍1).Level = 1;
		此栏位的玩家(5, 队伍1).Level = 1;
		If(全局.Gamemode == 0);
			全局.HR_Wave_Start = 总计消耗时间;
			全局.Spawns_remaining = 12;
			等待(10, 无视条件);
			生成机器人(英雄(安娜), 队伍2, 5, 100 * 上, 前);
		Else;
			全局.Spawns_remaining = 真;
			全局.IV_HVT_Spawn_Slot_Six = 真;
			此栏位的玩家(6, 队伍1).Level = 5;
		End;
	}
}

规则("IV HVT Global: Allow Spawns")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.Gamemode == 真;
		(全局.IV_Portal_Status == 1 || 全局.IV_Portal_Status == 2) == 真;
		全局.Spawns_remaining == 假;
		存活玩家数量(队伍1) <= 5 + 全局.Mut_Reinforcements;
	}

	动作
	{
		等待(20 - 2 * 全局.Combatants_Count, 当为“假”时中止);
		如条件为“假”则中止;
		全局.Spawns_remaining = 真;
	}
}

规则("IV HVT Global: Allow Spawns (All Enemies Dead)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.Gamemode == 真;
		(全局.IV_Portal_Status == 1 || 全局.IV_Portal_Status == 2) == 真;
		全局.Spawns_remaining == 假;
		存活玩家数量(队伍1) <= 1 + 全局.Mut_Reinforcements;
	}

	动作
	{
		全局.Spawns_remaining = 真;
	}
}

规则("IV HVT Global: Disallow Spawns")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.Gamemode == 真;
		(全局.IV_Portal_Status == 1 || 全局.IV_Portal_Status == 2) == 真;
		全局.Spawns_remaining == 真;
		存活玩家数量(队伍1) == 7;
	}

	动作
	{
		全局.Spawns_remaining = 假;
	}
}

规则("Global: Communicate Press the Attack, Set Last Stand active")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.Gamemode ? 全局.IV_Portal_Status == 3 : 全局.Spawns_remaining <= 0 && 全局.Boss_Spawns_remaining <= 0) == 真;
	}

	动作
	{
		If(全局.Mut_Last_Stand);
			全局.Mut_Last_Stand_active = 真;
		End;
		根据条件中止(全局.Gamemode == 0 && 全局.Wave == 5);
		交流(数组随机取值(全局.Combatants), 继续攻击);
	}
}

规则("Global: Defeat")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.Wave > 0;
		对全部为”真“(全局.Combatants, 当前数组元素.Downed_since) == 真;
	}

	动作
	{
		等待(2, 当为“假”时中止);
		宣告队伍胜利(队伍1);
	}
}

规则("MUT Global: Activate Mutators")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.Mutator_Activation_locked == 假;
	}

	动作
	{
		消除HUD文本(全局.Mutator_Start_HUD);
		全局.Mutator_Activation_locked = 真;
		全局.Mutators_activated = 真;
		全局.Money *= 2;
		调用子程序(Scale_Damage);
	}
}

规则("MUT Subroutine: Add Mutator")
{
	事件
	{
		子程序;
		MUT_Add_Mutator;
	}

	动作
	{
		If(全局.Wave == (全局.Gamemode ? 9 : 13));
			大字体信息(所有玩家(所有队伍), 自定义字符串("敌人获得了新的激烈突变！"));
			全局.Temp = 随机整数(0, 4);
			If(全局.Temp == 0);
				全局.GMut_Storm_Raging = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("怒火风暴：有些敌人处于狂怒状态，击杀他们将散布狂怒状态"), 右边, -49.500 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(橙色), 可见,
					默认可见度);
				开始伤害调整(全局.Combatants, 已过滤的数组(所有玩家(队伍1), 当前数组元素.GMut_Var), 150, 受伤害者和伤害者);
			Else If(全局.Temp == 1);
				全局.GMut_Close_Quarters = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("近距交战：敌人只能在玩家处于附近时才可被击杀"), 右边, -49.500 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(橙色), 可见, 默认可见度);
				For 全局变量(Temp, 0, 全局.Gamemode ? 7 : 6, 1);
					创建效果(单次赋值(此栏位的玩家(全局.Temp, 队伍1)).GMut_Var ? 所有玩家(所有队伍) : 空数组, 火花, 颜色(黄色), 此栏位的玩家(全局.Temp, 队伍1), 1, 可见);
				End;
			Else If(全局.Temp == 2);
				全局.GMut_Keep_your_Distance = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("保持距离：敌人会在玩家处于附近时仅承受40%的伤害"), 右边, -49.500 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(橙色), 可见,
					默认可见度);
				For 全局变量(Temp, 0, 全局.Gamemode ? 7 : 6, 1);
					开始伤害调整(单次赋值(此栏位的玩家(全局.Temp, 队伍1)), 单次赋值(此栏位的玩家(全局.Temp, 队伍1)).GMut_Var, 60, 受伤害者和伤害者);
					创建效果(单次赋值(此栏位的玩家(全局.Temp, 队伍1)).GMut_Var, 火花, 颜色(白色), 此栏位的玩家(全局.Temp, 队伍1), 1, 可见);
				End;
			Else If(全局.Temp == 3);
				全局.GMut_Fortified = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("固若金汤：敌人可抵御眩晕和击退，并获得额外护甲"), 右边, -49.500 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(橙色), 可见, 默认可见度);
				为玩家添加生命池(所有玩家(队伍1), 护甲, 75 * (0.200 + 0.200 * 全局.Combatants_Count), 真, 真);
			Else If(全局.Temp == 4);
				全局.GMut_Blood_Moon_Rising = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("血月起升：所有的治疗来源的效果都将减半"), 右边, -49.500 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(橙色), 可见, 默认可见度);
				设置受到治疗(所有玩家(队伍2), 50);
			End;
		Else If(全局.Bad_Mutators != 空数组);
			大字体信息(所有玩家(所有队伍), 自定义字符串("敌人获得了新的突变！"));
			全局.Temp = 数组随机取值(全局.Bad_Mutators);
			修改全局变量(Bad_Mutators, 根据值从数组中移除, 全局.Temp);
			If(全局.Temp == 0);
				全局.Mut_Amped = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("增强：敌人移动和转向的速度加快"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
			Else If(全局.Temp == 1);
				全局.Mut_Extended_Arsenal = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("扩展武力：敌人可以使用额外的技能"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
			Else If(全局.Temp == 2);
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("狂热：低于50%血量的敌人将额外造成25%的伤害"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
				开始伤害调整(全局.Combatants, 已过滤的数组(所有玩家(队伍1), 标准化生命值(当前数组元素) <= 0.500), 125, 受伤害者和伤害者);
			Else If(全局.Temp == 3);
				全局.Mut_The_Cavalry = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("救兵：猎空的出现几率得到增加"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
			Else If(全局.Temp == 4);
				全局.Mut_Regeneration = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("复生：敌人将缓慢地回复血量"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
			Else If(全局.Temp == 5);
				全局.Mut_Combat_Medic = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("战斗医师：巴蒂斯特的复活技能冷却时间已减半"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
			Else If(全局.Temp == 6);
				全局.Mut_EMP_Rounds = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("EMP子弹：敌人将对屏障和物品额外造成双倍伤害"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
				开始伤害调整(全局.Combatants, 所有玩家(队伍1), 50, 受伤害者和伤害者);
				调用子程序(Scale_Damage);
			Else If(全局.Temp == 7);
				全局.Mut_Death_Guard = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("死亡护卫：当敌人在倒下队友圈内时，复活的速度将减半"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
			Else If(全局.Temp == 8);
				全局.Mut_Deep_Wounds = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("重度伤口：生命值重生延迟加倍"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
			Else If(全局.Temp == 9);
				全局.Mut_Hurt_Me_More = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("伤我太深：倒下的玩家将会持续散发10秒的伤害烟雾"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
			Else If(全局.Temp == 10);
				全局.Mut_Last_Stand = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("最终之敌：最后存活的敌人获得伤害抵御并去除使用技能的限制"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见,
					默认可见度);
				If(全局.Gamemode == 1);
					开始伤害调整(所有玩家(队伍1), 全局.Combatants, 全局.Mut_Last_Stand_active ? 80 : 100, 受伤害者，伤害者及伤害百分比);
				Else;
					开始伤害调整(所有玩家(队伍1), 全局.Combatants, 全局.Mut_Last_Stand_active ? 70 : 100, 受伤害者，伤害者及伤害百分比);
				End;
			Else If(全局.Temp == 11);
				全局.Mut_Advanced_Medkit = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("高级医护：巴蒂斯特现在可以复活Boss"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
			Else If(全局.Temp == 12);
				全局.Mut_Reinforcements = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("大量支援：敌人的刷出率得到增加"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
			Else If(全局.Temp == 13);
				全局.Mut_Mutation = 总计消耗时间;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("突变：敌方已增加生成攻击更强体积更大的对手的几率"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
				创建效果(对任意为”真“(所有玩家(队伍1), 当前数组元素.Is_mutated) ? 所有玩家(所有队伍) : 空数组, 火花, 颜色(红色), 首个(已过滤的数组(所有玩家(队伍1), 当前数组元素.Is_mutated)), 1, 可见，位置和半径);
				开始伤害调整(全局.Combatants, 已过滤的数组(所有玩家(队伍1), 当前数组元素.Is_mutated), 130, 受伤害者和伤害者);
			Else If(全局.Temp == 14);
				全局.Mut_Promotion = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("提升军衔：敌方已增加生成更高等级敌人的几率"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
			Else If(全局.Temp == 15);
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("禁飞区：敌人将对空中的玩家额外造成25%伤害"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
				开始伤害调整(已过滤的数组(全局.Combatants, 当前数组元素.Is_flying), 所有玩家(队伍1), 125, 受伤害者和伤害者);
			Else If(全局.Temp == 16);
				全局.Mut_Meteor_Shower = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("陨石雨：敌方将随机施放毁天灭地技能"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
			Else If(全局.Temp == 17);
				全局.Mut_Deathbed = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("临终之难：复活的玩家仅有30%的生命值"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
			Else If(全局.Temp == 18);
				全局.Mut_Adrenaline = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("肾上腺素：敌人将更频繁的使用技能"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
			Else If(全局.Temp == 19);
				全局.Mut_Partners_In_Crime = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("拉帮结派：相同英雄的敌人将额外造成更多伤害"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
			Else If(全局.Temp == 20);
				全局.Mut_Glass_Cannon = 真;
				创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("玻璃大炮：可造成和受到额外30%的伤害"), 右边, -50 - 数量(全局.Bad_Mutators), 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
				开始伤害调整(所有玩家(队伍2), 所有玩家(所有队伍), 130, 受伤害者，伤害者及伤害百分比);
				开始伤害调整(所有玩家(队伍1), 所有玩家(队伍2), 120, 受伤害者，伤害者及伤害百分比);
			End;
		End;
	}
}

规则("Subroutine: Set Random Perks")
{
	事件
	{
		子程序;
		Set_Random_Perks;
	}

	动作
	{
		If(数量(全局.Current_Perks_HUDs));
			消除地图文本(全局.Current_Perks_HUDs[0]);
			消除地图文本(全局.Current_Perks_HUDs[1]);
			消除地图文本(全局.Current_Perks_HUDs[2]);
			消除地图文本(全局.Current_Perks_HUDs[3]);
		End;
		全局.Current_Perks_HUDs = 空数组;
		If(全局.Wave % (全局.Wave > 8 ? 4 : 3) == 0);
			全局.Current_Perks = 数组分割(随机数组(从数组中移除(数组(11, 12), 全局.Current_Perks)), 0, 2);
		Else;
			全局.Current_Perks = 数组分割(随机数组(从数组中移除(数组(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 13, 14), 全局.Current_Perks)), 0, 2);
		End;
		For 全局变量(Temp, 0, 2, 1);
			If(全局.Current_Perks[全局.Temp] == 0);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Perk_Shockproof), 自定义字符串("绝缘保护\n500$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Perk_Shockproof), 自定义字符串("绝缘保护\n500$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
			Else If(全局.Current_Perks[全局.Temp] == 1);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Perk_Bulletstorm), 自定义字符串("子弹风暴\n800$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Perk_Bulletstorm), 自定义字符串("子弹风暴\n800$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
			Else If(全局.Current_Perks[全局.Temp] == 2);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Perk_Die_Hard), 自定义字符串("生存欲望\n600$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Perk_Die_Hard), 自定义字符串("生存欲望\n600$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
			Else If(全局.Current_Perks[全局.Temp] == 3);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Perk_Pumping_Iron), 自定义字符串("钢铁之手\n700$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Perk_Pumping_Iron), 自定义字符串("钢铁之手\n700$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
			Else If(全局.Current_Perks[全局.Temp] == 4);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Perk_Terrify), 自定义字符串("畏惧\n1000$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Perk_Terrify), 自定义字符串("畏惧\n1000$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
			Else If(全局.Current_Perks[全局.Temp] == 5);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Perk_Running_Riot), 自定义字符串("复生之速\n700$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Perk_Running_Riot), 自定义字符串("复生之速\n700$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
			Else If(全局.Current_Perks[全局.Temp] == 6);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Perk_Up_You_Go), 自定义字符串("起身战斗\n1000$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Perk_Up_You_Go), 自定义字符串("起身战斗\n1000$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
			Else If(全局.Current_Perks[全局.Temp] == 7);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Perk_Stabilizer), 自定义字符串("紧急医疗\n800$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Perk_Stabilizer), 自定义字符串("紧急医疗\n800$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
			Else If(全局.Current_Perks[全局.Temp] == 8);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Perk_Nemesis), 自定义字符串("宿敌\n800$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Perk_Nemesis), 自定义字符串("宿敌\n800$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
			Else If(全局.Current_Perks[全局.Temp] == 9);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Perk_Mystery_Swap), 自定义字符串("神秘英雄\n500$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Perk_Mystery_Swap), 自定义字符串("神秘英雄\n500$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
			Else If(全局.Current_Perks[全局.Temp] == 10);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Perk_Heavy_Weight), 自定义字符串("烈拳\n600$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Perk_Heavy_Weight), 自定义字符串("烈拳\n600$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
			Else If(全局.Current_Perks[全局.Temp] == 11);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Talent_Active_1), 自定义字符串("1号英雄技能\n1200$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Talent_Active_1), 自定义字符串("1号英雄技能\n1200$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰绿色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
			Else If(全局.Current_Perks[全局.Temp] == 12);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Talent_Active_2), 自定义字符串("2号英雄技能\n1200$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Talent_Active_2), 自定义字符串("2号英雄技能\n1200$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰绿色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
			Else If(全局.Current_Perks[全局.Temp] == 13);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.CPerk_Nimble), 自定义字符串("匿踪恢复\n600$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.CPerk_Nimble), 自定义字符串("匿踪恢复\n600$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
			Else If(全局.Current_Perks[全局.Temp] == 14);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && 当前数组元素.Perk_Sharpshooter), 自定义字符串("精确猎杀\n800$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(灰色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
				创建地图文本(已过滤的数组(全局.Combatants, 当前数组元素.In_Buy_Menu_Since && !当前数组元素.Perk_Sharpshooter), 自定义字符串("精确猎杀\n800$"), 全局.Buy_Menu_Pos - (
					全局.Temp ? 25 : 2.500) * 全局.Buy_Menu_Left_Up_Forward[1] - 112.500 * 全局.Buy_Menu_Left_Up_Forward[0], 2.500, 不要截取, 可见, 颜色(绿色),
					默认可见度);
				修改全局变量(Current_Perks_HUDs, 添加至数组, 上一个文本ID);
			End;
		End;
	}
}

规则("Subroutine: Leave Buy Menu")
{
	事件
	{
		子程序;
		Leave_Buy_Menu;
	}

	动作
	{
		事件玩家.In_Buy_Menu_Since = 0;
		开启与玩家的移动碰撞(事件玩家);
		显示英雄HUD(事件玩家);
		设置朝向(事件玩家, 事件玩家.Ab_Var_3, 至地图);
		If(!事件玩家.Downed_since);
			停止镜头(事件玩家);
		End;
		设置瞄准速度(事件玩家, 100);
		停止限制阈值(事件玩家);
		设置主要攻击模式启用(事件玩家, 真);
		设置辅助攻击模式启用(事件玩家, 真);
		设置启用技能 1(事件玩家, 真);
		设置启用技能 2(事件玩家, 真);
		设置启用近战攻击(事件玩家, 真);
		设置启用跳跃(事件玩家, 真);
		设置启用蹲下(事件玩家, 真);
		可用按钮(事件玩家, 按钮(终极技能));
	}
}

规则("Team 2: Teleport to Buy Zone (Reload)")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
		事件玩家.Downed_since == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		(!全局.Wave || 比赛时间) == 真;
		相距距离(事件玩家, 全局.Ability_Buy_Location) > 2;
	}

	动作
	{
		等待(0.400, 当为“假”时中止);
		如条件为“假”则中止;
		播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(黄色), 所选位置(事件玩家), 1);
		传送(事件玩家, 全局.Ability_Buy_Location);
	}
}

规则("Team 2: Open / Leave Buy Menu, Last Facing (3)")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		事件玩家.Downed_since == 假;
		标准化生命值(事件玩家) >= 0.500;
		具有状态(事件玩家, 击晕) == 假;
		事件玩家.Tased_until < 总计消耗时间;
		相距距离(事件玩家, 全局.Ability_Buy_Location) <= 2;
	}

	动作
	{
		If(事件玩家.In_Buy_Menu_Since);
			调用子程序(Leave_Buy_Menu);
		Else;
			施加推力(事件玩家, -1 * 与此角度的相对方向(与此方向的水平角度(速率(事件玩家)), 0), 0.001, 至地图, 取消相反运动XYZ);
			事件玩家.Ab_Var_3 = 面朝方向(事件玩家);
			事件玩家.In_Buy_Menu_Since = 总计消耗时间;
			取消与玩家的移动碰撞(事件玩家);
			隐藏英雄HUD(事件玩家);
			设置朝向(事件玩家, 前, 至地图);
			开始镜头(事件玩家, 全局.Buy_Menu_Cam_Pos, 全局.Buy_Menu_Cam_Pos + 全局.Buy_Menu_Left_Up_Forward[2], 0);
			设置瞄准速度(事件玩家, 200);
			开始限制阈值(事件玩家, 0, 0, 0, 0, 0, 0);
			设置主要攻击模式启用(事件玩家, 假);
			设置辅助攻击模式启用(事件玩家, 假);
			设置启用技能 1(事件玩家, 假);
			设置启用技能 2(事件玩家, 假);
			设置启用近战攻击(事件玩家, 假);
			设置启用跳跃(事件玩家, 假);
			设置启用蹲下(事件玩家, 假);
			禁用按钮(事件玩家, 按钮(终极技能));
		End;
		等待(0.050, 无视条件);
	}
}

规则("Team 2: Leave Buy Menu when downed, health low, stunned, tased or moved")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.In_Buy_Menu_Since == 真;
		(事件玩家.Downed_since || 标准化生命值(事件玩家) < 0.500 || 具有状态(事件玩家, 击晕) || 事件玩家.Tased_until >= 总计消耗时间 || 相距距离(事件玩家, 全局.Ability_Buy_Location)
			> 2) == 真;
	}

	动作
	{
		调用子程序(Leave_Buy_Menu);
	}
}

规则("Team 2: Buy Ability")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.In_Buy_Menu_Since == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
	}

	动作
	{
		根据条件中止(事件玩家.In_Buy_Menu_Since + 0.100 >= 总计消耗时间 || 绝对值(水平朝向角度(事件玩家)) > 135 || 绝对值(垂直朝向角度(事件玩家) + 11.250)
			> 45 || 事件玩家.Tased_until >= 总计消耗时间);
		全局.Temp = 数组(较大(0, 较小(5, 取整((水平朝向角度(事件玩家) + 135) / 45, 下))), 较大(0, 较小(3, 取整((垂直朝向角度(事件玩家) + 56.250) / 22.500, 下))));
		If(全局.Temp[1] == 0);
			If(全局.Temp[0] <= 1);
				调用子程序(Leave_Buy_Menu);
			Else If(全局.Temp[0] >= 4);
				If(事件玩家.Money_spent);
					事件玩家.Money_spent = 0;
					事件玩家.Ab_Headhunter = 0;
					事件玩家.Ab_Quick_Fix = 0;
					事件玩家.Ab_Charged = 0;
					事件玩家.Ab_Heavy_Impact = 0;
					事件玩家.Ab_Second_Wind = 0;
					事件玩家.Ab_Binding_Heal = 0;
					事件玩家.Ab_Resilience = 0;
					事件玩家.Ab_Ambush = 0;
					事件玩家.Ab_Haste = 0;
					事件玩家.Ab_Priority = 0;
					事件玩家.Ab_Health_Bonus = 0;
					事件玩家.Ab_Damage_Bonus = 0;
					事件玩家.Ab_Healing_Bonus = 0;
					事件玩家.Perk_Shockproof = 假;
					If(事件玩家.Perk_Bulletstorm);
						设置弹药(事件玩家, 0, 最大弹药量(事件玩家, 0));
						设置弹药(事件玩家, 1, 最大弹药量(事件玩家, 1));
						事件玩家.Perk_Bulletstorm = 假;
					End;
					事件玩家.Talent_Active_1 = 假;
					事件玩家.Talent_Active_2 = 假;
					事件玩家.CPerk_Nimble = 假;
					事件玩家.Perk_Die_Hard = 假;
					事件玩家.Perk_Pumping_Iron = 假;
					事件玩家.Perk_Terrify = 假;
					事件玩家.Perk_Running_Riot = 假;
					事件玩家.Perk_Up_You_Go = 假;
					事件玩家.Perk_Stabilizer = 假;
					事件玩家.Perk_Nemesis = 假;
					If(事件玩家.Perk_Mystery_Swap);
						停止强制玩家选择英雄(事件玩家);
						事件玩家.Perk_Mystery_Swap = 假;
					End;
					If(事件玩家.Perk_Heavy_Weight);
						设置造成的击退(事件玩家, 100);
						设置受到的击退(事件玩家, 100);
						事件玩家.Perk_Heavy_Weight = 假;
					End;
					事件玩家.Perk_Sharpshooter = 假;
					事件玩家.Max_HP = 100;
					事件玩家.Damage_Dealt = 100;
					事件玩家.Healing_Dealt = 100;
					设置最大生命值(事件玩家, 100);
					设置造成伤害(事件玩家, 100);
					设置造成治疗(事件玩家, 100);
					小字体信息(事件玩家, 自定义字符串("金币已退回"));
					调用子程序(After_Buying_Ability);
				End;
			End;
		Else;
			If(全局.Temp[0] == 0);
				If(全局.Temp[1] >= 2);
					全局.Temp = 全局.Current_Perks[全局.Temp[1] == 3];
					If(全局.Temp == 0);
						If(!事件玩家.Perk_Shockproof);
							If(全局.Money - 事件玩家.Money_spent < 500);
								小字体信息(事件玩家, 自定义字符串("金币不够"));
								中止;
							End;
							事件玩家.Money_spent += 500;
							事件玩家.Perk_Shockproof = 真;
							小字体信息(事件玩家, 自定义字符串("已解锁绝缘保护"));
							调用子程序(After_Buying_Ability);
						End;
					Else If(全局.Temp == 1);
						If(!事件玩家.Perk_Bulletstorm);
							If(全局.Money - 事件玩家.Money_spent < 800);
								小字体信息(事件玩家, 自定义字符串("金币不够"));
								中止;
							End;
							事件玩家.Money_spent += 800;
							事件玩家.Perk_Bulletstorm = 真;
							小字体信息(事件玩家, 自定义字符串("已解锁子弹风暴"));
							调用子程序(After_Buying_Ability);
						End;
					Else If(全局.Temp == 2);
						If(!事件玩家.Perk_Die_Hard);
							If(全局.Money - 事件玩家.Money_spent < 600);
								小字体信息(事件玩家, 自定义字符串("金币不够"));
								中止;
							End;
							事件玩家.Money_spent += 600;
							事件玩家.Perk_Die_Hard = 真;
							小字体信息(事件玩家, 自定义字符串("已解锁生存欲望"));
							调用子程序(After_Buying_Ability);
						End;
					Else If(全局.Temp == 3);
						If(!事件玩家.Perk_Pumping_Iron);
							If(全局.Money - 事件玩家.Money_spent < 700);
								小字体信息(事件玩家, 自定义字符串("金币不够"));
								中止;
							End;
							事件玩家.Money_spent += 700;
							事件玩家.Perk_Pumping_Iron = 真;
							小字体信息(事件玩家, 自定义字符串("已解锁钢铁之手"));
							调用子程序(After_Buying_Ability);
						End;
					Else If(全局.Temp == 4);
						If(!事件玩家.Perk_Terrify);
							If(全局.Money - 事件玩家.Money_spent < 1000);
								小字体信息(事件玩家, 自定义字符串("金币不够"));
								中止;
							End;
							事件玩家.Money_spent += 1000;
							事件玩家.Perk_Terrify = 真;
							小字体信息(事件玩家, 自定义字符串("已解锁畏惧"));
							调用子程序(After_Buying_Ability);
						End;
					Else If(全局.Temp == 5);
						If(!事件玩家.Perk_Running_Riot);
							If(全局.Money - 事件玩家.Money_spent < 700);
								小字体信息(事件玩家, 自定义字符串("金币不够"));
								中止;
							End;
							事件玩家.Money_spent += 700;
							事件玩家.Perk_Running_Riot = 真;
							小字体信息(事件玩家, 自定义字符串("已解锁复生之速"));
							调用子程序(After_Buying_Ability);
						End;
					Else If(全局.Temp == 6);
						If(!事件玩家.Perk_Up_You_Go);
							If(全局.Money - 事件玩家.Money_spent < 1000);
								小字体信息(事件玩家, 自定义字符串("金币不够"));
								中止;
							End;
							事件玩家.Money_spent += 1000;
							事件玩家.Perk_Up_You_Go = 真;
							小字体信息(事件玩家, 自定义字符串("已解锁起身战斗"));
							调用子程序(After_Buying_Ability);
						End;
					Else If(全局.Temp == 7);
						If(!事件玩家.Perk_Stabilizer);
							If(全局.Money - 事件玩家.Money_spent < 800);
								小字体信息(事件玩家, 自定义字符串("金币不够"));
								中止;
							End;
							事件玩家.Money_spent += 800;
							事件玩家.Perk_Stabilizer = 真;
							小字体信息(事件玩家, 自定义字符串("已解锁紧急医疗"));
							调用子程序(After_Buying_Ability);
						End;
					Else If(全局.Temp == 8);
						If(!事件玩家.Perk_Nemesis);
							If(全局.Money - 事件玩家.Money_spent < 800);
								小字体信息(事件玩家, 自定义字符串("金币不够"));
								中止;
							End;
							事件玩家.Money_spent += 800;
							事件玩家.Perk_Nemesis = 真;
							小字体信息(事件玩家, 自定义字符串("已解锁宿敌"));
							调用子程序(After_Buying_Ability);
						End;
					Else If(全局.Temp == 9);
						If(!事件玩家.Perk_Mystery_Swap);
							If(全局.Money - 事件玩家.Money_spent < 500);
								小字体信息(事件玩家, 自定义字符串("金币不够"));
								中止;
							End;
							事件玩家.Money_spent += 500;
							事件玩家.Max_HP += 20;
							事件玩家.Damage_Dealt += 20;
							事件玩家.Healing_Dealt += 20;
							设置最大生命值(事件玩家, 事件玩家.Max_HP);
							设置造成伤害(事件玩家, 事件玩家.Damage_Dealt);
							设置造成治疗(事件玩家, 事件玩家.Healing_Dealt);
							事件玩家.Perk_Mystery_Swap = 总计消耗时间 + 随机整数(45, 75);
							小字体信息(事件玩家, 自定义字符串("已解锁神秘英雄"));
							调用子程序(After_Buying_Ability);
						End;
					Else If(全局.Temp == 10);
						If(!事件玩家.Perk_Heavy_Weight);
							If(全局.Money - 事件玩家.Money_spent < 600);
								小字体信息(事件玩家, 自定义字符串("金币不够"));
								中止;
							End;
							事件玩家.Money_spent += 600;
							设置造成的击退(事件玩家, 200);
							设置受到的击退(事件玩家, 50);
							事件玩家.Perk_Heavy_Weight = 真;
							小字体信息(事件玩家, 自定义字符串("已解锁烈拳"));
							调用子程序(After_Buying_Ability);
						End;
					Else If(全局.Temp == 14);
						If(!事件玩家.Perk_Sharpshooter);
							If(全局.Money - 事件玩家.Money_spent < 800);
								小字体信息(事件玩家, 自定义字符串("金币不够"));
								中止;
							End;
							事件玩家.Money_spent += 800;
							事件玩家.Perk_Sharpshooter = 真;
							小字体信息(事件玩家, 自定义字符串("已解锁精确猎杀"));
							调用子程序(After_Buying_Ability);
						End;
					Else If(全局.Temp == 11);
						If(!事件玩家.Talent_Active_1);
							If(全局.Money - 事件玩家.Money_spent < 1200);
								小字体信息(事件玩家, 自定义字符串("金币不够"));
								中止;
							End;
							事件玩家.Money_spent += 1200;
							事件玩家.Talent_Active_1 = 真;
							小字体信息(事件玩家, 自定义字符串("已解锁{0} {1}", 事件玩家.Talent_Text123_456[1], 事件玩家.Talent_Text123_456[2]));
							调用子程序(After_Buying_Ability);
						End;
					Else If(全局.Temp == 12);
						If(!事件玩家.Talent_Active_2);
							If(全局.Money - 事件玩家.Money_spent < 1200);
								小字体信息(事件玩家, 自定义字符串("金币不够"));
								中止;
							End;
							事件玩家.Money_spent += 1200;
							事件玩家.Talent_Active_2 = 真;
							小字体信息(事件玩家, 自定义字符串("已解锁{0} {1}", 事件玩家.Talent_Text123_456[4], 事件玩家.Talent_Text123_456[5]));
							调用子程序(After_Buying_Ability);
						End;
					Else If(全局.Temp == 13);
						If(!事件玩家.CPerk_Nimble);
							If(全局.Money - 事件玩家.Money_spent < 600);
								小字体信息(事件玩家, 自定义字符串("金币不够"));
								中止;
							End;
							事件玩家.Money_spent += 600;
							事件玩家.CPerk_Nimble = 真;
							小字体信息(事件玩家, 自定义字符串("已解锁匿踪恢复"));
							调用子程序(After_Buying_Ability);
						End;
					End;
				End;
			Else If(全局.Temp[0] == 1);
				If(全局.Money - 事件玩家.Money_spent < 400);
					小字体信息(事件玩家, 自定义字符串("金币不够"));
					中止;
				End;
				事件玩家.Money_spent += 400;
				If(全局.Temp[1] == 1);
					事件玩家.Ab_Health_Bonus += 5;
					事件玩家.Max_HP += 5;
					设置最大生命值(事件玩家, 事件玩家.Max_HP);
					小字体信息(事件玩家, 自定义字符串("已获得额外5%的生命"));
				Else If(全局.Temp[1] == 2);
					事件玩家.Ab_Damage_Bonus += 5;
					事件玩家.Damage_Dealt += 5;
					设置造成伤害(事件玩家, 事件玩家.Damage_Dealt);
					小字体信息(事件玩家, 自定义字符串("已获得额外5%的伤害"));
				Else If(全局.Temp[1] == 3);
					事件玩家.Ab_Healing_Bonus += 5;
					事件玩家.Healing_Dealt += 5;
					设置造成治疗(事件玩家, 事件玩家.Healing_Dealt);
					小字体信息(事件玩家, 自定义字符串("已获得额外5%的治疗"));
				End;
				调用子程序(After_Buying_Ability);
			Else If(全局.Temp[0] == 2);
				If(全局.Temp[1] == 1);
					If(事件玩家.Ab_Resilience < 2);
						If(全局.Money - 事件玩家.Money_spent < 800);
							小字体信息(事件玩家, 自定义字符串("金币不够"));
							中止;
						End;
						事件玩家.Money_spent += 800;
						If(!事件玩家.Ab_Resilience);
							事件玩家.Ab_Resilience = 1;
							小字体信息(事件玩家, 自定义字符串("已解锁强韧基础版"));
						Else;
							事件玩家.Ab_Resilience = 2;
							小字体信息(事件玩家, 自定义字符串("已解锁强韧高级版"));
						End;
						调用子程序(After_Buying_Ability);
					End;
				Else If(全局.Temp[1] == 2);
					If(事件玩家.Ab_Binding_Heal < 2);
						If(全局.Money - 事件玩家.Money_spent < 700);
							小字体信息(事件玩家, 自定义字符串("金币不够"));
							中止;
						End;
						事件玩家.Money_spent += 700;
						If(!事件玩家.Ab_Binding_Heal);
							事件玩家.Ab_Binding_Heal = 1;
							小字体信息(事件玩家, 自定义字符串("已解锁绑定治愈基础版"));
						Else;
							事件玩家.Ab_Binding_Heal = 2;
							小字体信息(事件玩家, 自定义字符串("已解锁绑定治愈高级版"));
						End;
						调用子程序(After_Buying_Ability);
					End;
				Else If(全局.Temp[1] == 3);
					If(事件玩家.Ab_Second_Wind < 2);
						If(全局.Money - 事件玩家.Money_spent < 900);
							小字体信息(事件玩家, 自定义字符串("金币不够"));
							中止;
						End;
						事件玩家.Money_spent += 900;
						If(!事件玩家.Ab_Second_Wind);
							事件玩家.Ab_Second_Wind = 1;
							小字体信息(事件玩家, 自定义字符串("已解锁第二次机会基础版"));
						Else;
							事件玩家.Ab_Second_Wind = 2;
							小字体信息(事件玩家, 自定义字符串("已解锁第二次机会高级版"));
						End;
						调用子程序(After_Buying_Ability);
					End;
				End;
			Else If(全局.Temp[0] == 3);
				If(全局.Temp[1] == 1);
					If(事件玩家.Ab_Charged < 2);
						If(全局.Money - 事件玩家.Money_spent < 700);
							小字体信息(事件玩家, 自定义字符串("金币不够"));
							中止;
						End;
						事件玩家.Money_spent += 700;
						If(!事件玩家.Ab_Charged);
							事件玩家.Ab_Charged = 1;
							小字体信息(事件玩家, 自定义字符串("已解锁充能基础版"));
						Else;
							事件玩家.Ab_Charged = 2;
							小字体信息(事件玩家, 自定义字符串("已解锁充能高级版"));
						End;
						调用子程序(After_Buying_Ability);
					End;
				Else If(全局.Temp[1] == 2);
					If(事件玩家.Ab_Haste < 2);
						If(全局.Money - 事件玩家.Money_spent < 700);
							小字体信息(事件玩家, 自定义字符串("金币不够"));
							中止;
						End;
						事件玩家.Money_spent += 700;
						If(!事件玩家.Ab_Haste);
							事件玩家.Ab_Haste = 1;
							小字体信息(事件玩家, 自定义字符串("已解锁精通基础版"));
						Else;
							事件玩家.Ab_Haste = 2;
							小字体信息(事件玩家, 自定义字符串("已解锁精通高级版"));
						End;
						调用子程序(After_Buying_Ability);
					End;
				Else If(全局.Temp[1] == 3);
					If(事件玩家.Ab_Heavy_Impact < 2);
						If(全局.Money - 事件玩家.Money_spent < 1000);
							小字体信息(事件玩家, 自定义字符串("金币不够"));
							中止;
						End;
						事件玩家.Money_spent += 1000;
						If(!事件玩家.Ab_Heavy_Impact);
							事件玩家.Ab_Heavy_Impact = 1;
							小字体信息(事件玩家, 自定义字符串("已解锁沉重一击基础版"));
						Else;
							事件玩家.Ab_Heavy_Impact = 2;
							小字体信息(事件玩家, 自定义字符串("已解锁沉重一击高级版"));
						End;
						调用子程序(After_Buying_Ability);
					End;
				End;
			Else If(全局.Temp[0] == 4);
				If(全局.Temp[1] == 1);
					If(事件玩家.Ab_Headhunter < 2);
						If(全局.Money - 事件玩家.Money_spent < 800);
							小字体信息(事件玩家, 自定义字符串("金币不够"));
							中止;
						End;
						事件玩家.Money_spent += 800;
						If(!事件玩家.Ab_Headhunter);
							事件玩家.Ab_Headhunter = 1;
							小字体信息(事件玩家, 自定义字符串("已解锁猎头者基础版"));
						Else;
							事件玩家.Ab_Headhunter = 2;
							小字体信息(事件玩家, 自定义字符串("已解锁猎头者高级版"));
						End;
						调用子程序(After_Buying_Ability);
					End;
				Else If(全局.Temp[1] == 2);
					If(事件玩家.Ab_Ambush < 2);
						If(全局.Money - 事件玩家.Money_spent < 800);
							小字体信息(事件玩家, 自定义字符串("金币不够"));
							中止;
						End;
						事件玩家.Money_spent += 800;
						If(!事件玩家.Ab_Ambush);
							事件玩家.Ab_Ambush = 1;
							小字体信息(事件玩家, 自定义字符串("已解锁伏击基础版"));
						Else;
							事件玩家.Ab_Ambush = 2;
							小字体信息(事件玩家, 自定义字符串("已解锁伏击高级版"));
						End;
						调用子程序(After_Buying_Ability);
					End;
				Else If(全局.Temp[1] == 3);
					If(事件玩家.Ab_Quick_Fix < 2);
						If(全局.Money - 事件玩家.Money_spent < 700);
							小字体信息(事件玩家, 自定义字符串("金币不够"));
							中止;
						End;
						事件玩家.Money_spent += 700;
						If(!事件玩家.Ab_Quick_Fix);
							事件玩家.Ab_Quick_Fix = 1;
							小字体信息(事件玩家, 自定义字符串("已解锁快速调整基础版"));
						Else;
							事件玩家.Ab_Quick_Fix = 2;
							小字体信息(事件玩家, 自定义字符串("已解锁快速调整高级版"));
						End;
						调用子程序(After_Buying_Ability);
					End;
				End;
			Else If(全局.Temp[0] == 5);
				If(!事件玩家.Ab_Priority && 全局.Money - 事件玩家.Money_spent < 1200);
					小字体信息(事件玩家, 自定义字符串("金币不够"));
					中止;
				End;
				If(全局.Temp[1] == 1);
					If(!事件玩家.Ab_Priority);
						事件玩家.Money_spent += 1200;
						小字体信息(事件玩家, 自定义字符串("已解锁快来打我"));
					Else If(事件玩家.Ab_Priority == 1);
						中止;
					Else;
						小字体信息(事件玩家, 自定义字符串("切换到快来打我"));
					End;
					事件玩家.Ab_Priority = 1;
				Else If(全局.Temp[1] == 2);
					If(!事件玩家.Ab_Priority);
						事件玩家.Money_spent += 1200;
						小字体信息(事件玩家, 自定义字符串("已解锁劝你三思"));
					Else If(事件玩家.Ab_Priority == 2);
						中止;
					Else;
						小字体信息(事件玩家, 自定义字符串("切换到劝你三思"));
					End;
					事件玩家.Ab_Priority = 2;
				Else If(全局.Temp[1] == 3);
					If(!事件玩家.Ab_Priority);
						事件玩家.Money_spent += 1200;
						小字体信息(事件玩家, 自定义字符串("已解锁别打我啦"));
					Else If(事件玩家.Ab_Priority == 3);
						中止;
					Else;
						小字体信息(事件玩家, 自定义字符串("切换到别打我啦"));
					End;
					事件玩家.Ab_Priority = 3;
				End;
				调用子程序(After_Buying_Ability);
			End;
		End;
	}
}

规则("Subroutine: After Buying Ability")
{
	事件
	{
		子程序;
		After_Buying_Ability;
	}

	动作
	{
		播放效果(事件玩家, 状态爆炸声音, 颜色(白色), 全局.Buy_Menu_Cam_Pos, 200);
		事件玩家.Ab_String = 截取字符串(自定义字符串("{0}{1}{2}", 自定义字符串("{0}{1}{2}", 自定义字符串("{0}{1}{2}", 自定义字符串("{0}{1}{2}", 数组(字符串(""), 自定义字符串(
			"\n快来打我"), 自定义字符串("\n劝你三思"), 自定义字符串("\n别打我啦"))[事件玩家.Ab_Priority], 数组(字符串(""), 自定义字符串("\n猎头者基础版"), 自定义字符串("\n猎头者高级版"))
			[事件玩家.Ab_Headhunter], 数组(字符串(""), 自定义字符串("\n伏击基础版"), 自定义字符串("\n伏击高级版"))[事件玩家.Ab_Ambush]), 自定义字符串("{0}{1}{2}", 数组(字符串(""),
			自定义字符串("\n快速调整基础版"), 自定义字符串("\n快速调整高级版"))[事件玩家.Ab_Quick_Fix], 数组(字符串(""), 自定义字符串("\n充能基础版"), 自定义字符串("\n充能高级版"))
			[事件玩家.Ab_Charged], 数组(字符串(""), 自定义字符串("\n精通基础版"), 自定义字符串("\n精通高级版"))[事件玩家.Ab_Haste]), 自定义字符串("{0}{1}{2}", 数组(字符串(""), 自定义字符串(
			"\n沉重一击基础版"), 自定义字符串("\n沉重一击高级版"))[事件玩家.Ab_Heavy_Impact], 数组(字符串(""), 自定义字符串("\n强韧基础版"), 自定义字符串("\n强韧高级版"))
			[事件玩家.Ab_Resilience], 数组(字符串(""), 自定义字符串("\n绑定治愈基础版"), 自定义字符串("\n绑定治愈高级版"))[事件玩家.Ab_Binding_Heal])), 自定义字符串("{0}{1}{2}",
			自定义字符串("{0}{1}{2}", 数组(字符串(""), 自定义字符串("\n第二次机会基础版"), 自定义字符串("\n第二次机会高级版"))[事件玩家.Ab_Second_Wind],
			事件玩家.Perk_Shockproof ? 自定义字符串("\n绝缘保护") : 字符串(""), 事件玩家.Perk_Bulletstorm ? 自定义字符串("\n子弹风暴") : 字符串("")), 自定义字符串("{0}{1}{2}",
			事件玩家.Perk_Die_Hard ? 自定义字符串("\n生存欲望") : 字符串(""), 事件玩家.Perk_Pumping_Iron ? 自定义字符串("\n钢铁之手") : 字符串(""),
			事件玩家.Perk_Terrify ? 自定义字符串("\n畏惧") : 字符串("")), 自定义字符串("{0}{1}{2}", 事件玩家.Perk_Running_Riot ? 自定义字符串("\n复生之速") : 字符串(""),
			事件玩家.Perk_Up_You_Go ? 自定义字符串("\n起身战斗") : 字符串(""), 事件玩家.Perk_Stabilizer ? 自定义字符串("\n紧急医疗") : 字符串(""))), 自定义字符串("{0}{1}{2}",
			自定义字符串("{0}{1}{2}", 事件玩家.Perk_Nemesis ? 自定义字符串("\n宿敌") : 字符串(""), 事件玩家.Perk_Mystery_Swap ? 自定义字符串("\n神秘英雄") : 字符串(""),
			事件玩家.Perk_Heavy_Weight ? 自定义字符串("\n烈拳") : 字符串("")), 自定义字符串("{0}{1}{2}", 事件玩家.Perk_Sharpshooter ? 自定义字符串("\n精确猎杀") : 字符串(""),
			事件玩家.Ab_Health_Bonus ? 自定义字符串("\n+{0}%生命", 事件玩家.Ab_Health_Bonus) : 字符串(""), 事件玩家.Ab_Damage_Bonus ? 自定义字符串("\n+{0}%伤害",
			事件玩家.Ab_Damage_Bonus) : 字符串("")), 事件玩家.Ab_Healing_Bonus ? 自定义字符串("\n+{0}%治疗", 事件玩家.Ab_Healing_Bonus) : 字符串(""))), 自定义字符串(
			"{0}{1}{2}", 事件玩家.CPerk_Nimble ? 自定义字符串("\n匿踪恢复") : 字符串(""), 事件玩家.Talent_Active_1 ? 自定义字符串("\n{0} {1}",
			事件玩家.Talent_Text123_456[1], 事件玩家.Talent_Text123_456[2]) : 字符串(""), 事件玩家.Talent_Active_2 ? 自定义字符串("\n{0} {1}",
			事件玩家.Talent_Text123_456[4], 事件玩家.Talent_Text123_456[5]) : 字符串("")), 字符串("")), 1, 511);
		等待(0.100, 无视条件);
	}
}

规则("All Teams: Player left Match")
{
	事件
	{
		玩家离开比赛;
		双方;
		全部;
	}

	动作
	{
		调用子程序(Update_Combatants);
		调用子程序(Scale_Damage);
	}
}

规则("Subroutine: Nearest Walkable Position Teleport")
{
	事件
	{
		子程序;
		NWP_Teleport;
	}

	动作
	{
		If(全局.Temp == 空数组);
			传送(事件玩家, 首个(已排序的数组(全局.Nodes, 相距距离(事件玩家, 当前数组元素))));
		Else;
			传送(事件玩家, 全局.Temp);
		End;
	}
}

规则("Team 2: Set Allowed Heroes")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	动作
	{
		根据条件中止(栏位(事件玩家) >= 5);
		设置玩家可选的英雄(事件玩家, 全局.Gamemode || 全局.Upgrade_Counter >= 25 ? 全部英雄 : 数组分割(全局.HR_Hostage_Hero_Array, 0, 全局.Upgrade_Counter + 7));
	}
}

规则("Team 2 (Spawn): Teleport, Set Is Combatant, Healing, Scale Damage, Create HUDs, Effects and Objective Description")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		根据条件中止(栏位(事件玩家) >= 5);
		小字体信息(事件玩家, 自定义字符串("热火街区生存战 2.5.0，由Shingen制作\n由CyberLemon2k修改"));
		事件玩家.Is_Combatant = 真;
		事件玩家.Spectated_Player = 事件玩家;
		事件玩家.Ab_String = 字符串("");
		事件玩家.Max_HP = 100;
		事件玩家.Damage_Dealt = 100;
		事件玩家.Healing_Dealt = 100;
		If(全局.Gamemode == 0);
			设置受到治疗(事件玩家, (全局.GMut_Blood_Moon_Rising ? 50 : 100) + 2 * 全局.Upgrade_Counter);
		Else;
			设置受到治疗(事件玩家, (全局.GMut_Blood_Moon_Rising ? 50 : 100) + 2 * 取整(全局.Upgrade_Counter * 7 / 3, 下));
		End;
		调用子程序(Update_Combatants);
		调用子程序(Scale_Damage);
		创建效果(事件玩家.Downed_since ? 所有玩家(所有队伍) : 空数组, 环, 颜色(黄色), 事件玩家, 3, 可见);
		创建图标(事件玩家.Downed_since ? 从数组中移除(所有玩家(所有队伍), 事件玩家) : 空数组, 事件玩家, 骷髅, 可见, 颜色(黄色), 真);
		创建HUD文本(事件玩家.Downed_since && 事件玩家.Revive_Timer != 10000 ? 添加至数组(已过滤的数组(全局.Combatants, !当前数组元素.Downed_since && !(
			当前数组元素.Is_invisible % 3) && 相距距离(事件玩家, 矢量(X方向分量(所选位置(当前数组元素)), Y方向分量(所选位置(事件玩家)), Z方向分量(所选位置(当前数组元素)))) <= 3 && 绝对值(Y方向分量(所选位置(
			事件玩家)) - Y方向分量(所选位置(当前数组元素))) <= 3 && 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线)), 事件玩家) : 空数组, 自定义字符串("正在复活 {0}: {1}", 事件玩家, 取整(
			事件玩家.Revive_Timer, 上)), 无, 无, 顶部, 栏位(事件玩家) + 全局.Gamemode ? -60 : 40, 全局.Mut_Death_Guard && 对任意为”真“(范围内玩家(事件玩家, 3, 队伍1, 关闭), 存活(
			当前数组元素)) ? 颜色(橙色) : 颜色(天蓝色), 颜色(白色), 颜色(白色), 可见，字符串和颜色, 默认可见度);
		创建HUD文本(所有玩家(队伍2), 自定义字符串("{0}{1}{2}", 英雄图标字符串(所用英雄(事件玩家)), 事件玩家.Tased_until >= 总计消耗时间 ? 图标字符串(箭矢) : 自定义字符串(""),
			事件玩家.Downed_since && 事件玩家.Revive_Timer != 10000 ? 全局.Progress_Bar[取整(2.500 * (4 - 事件玩家.Revive_Timer), 下)] : 字符串("")), 自定义字符串(
			"{0}{1}", 事件玩家, 事件玩家.Ab_Priority ? 数组(自定义字符串(" （快来打我）"), 自定义字符串(" （劝你三思）"), 自定义字符串(" （别打我呀）"))[事件玩家.Ab_Priority - 1] : 字符串(
			"")), 自定义字符串("{0}, {1}$", 事件玩家.Downed_since ? (事件玩家.Revive_Timer == 10000 ? 自定义字符串("已倒下") : 自定义字符串("已被复活")) : (
			事件玩家.Is_changing_Heroes ? 自定义字符串("正在更换英雄") : 自定义字符串("{0} 生命值", 取整(生命值(事件玩家), 上))), 全局.Money - 事件玩家.Money_spent), 左边, 栏位(事件玩家),
			事件玩家.Downed_since ? 颜色(红色) : (事件玩家.Is_changing_Heroes || 标准化生命值(事件玩家) >= 0.500 ? 颜色(天蓝色) : 颜色(橙色)), 事件玩家.Downed_since ? 颜色(红色)
			: (事件玩家.Is_changing_Heroes || 标准化生命值(事件玩家) >= 0.500 ? 颜色(天蓝色) : 颜色(橙色)), 事件玩家.Downed_since ? 颜色(红色) : (
			事件玩家.Is_changing_Heroes || 标准化生命值(事件玩家) >= 0.500 ? 颜色(天蓝色) : 颜色(橙色)), 可见，字符串和颜色, 默认可见度);
		创建效果(全局.Mut_Hurt_Me_More && 事件玩家.Downed_since && 事件玩家.Downed_since + 10 >= 总计消耗时间 ? 所有玩家(所有队伍) : 空数组, 云, 颜色(红色), 事件玩家, 3, 可见);
		If(全局.Gamemode == 0);
			设置目标点描述(事件玩家, 自定义字符串("热火街区生存战 2.5.0 (4ACNY| 原版：RM64A) - 生存22波"), 可见);
		End;
		If(!全局.Wave);
			传送(事件玩家, 全局.Player_Spawn);
			等待(0.200, 无视条件);
			设置朝向(事件玩家, 全局.Player_Spawn_Facing, 至地图);
		End;
		等待(1, 无视条件);
		"Nemesis Killer Effect"
		创建光束效果(事件玩家.Downed_since && 事件玩家.Nemesis_Killer != 无 ? 所有玩家(所有队伍) : 空数组, 有害光束, 所选位置(事件玩家), 事件玩家.Nemesis_Killer, 颜色(黑色), 可见，位置和半径);
		"Create Ability Entities and Cursor"
		创建HUD文本(事件玩家, 无, 无, 事件玩家.Spectated_Player.Ab_String, 左边, 10, 颜色(白色), 颜色(白色), 颜色(绿色), 可见和字符串, 默认可见度);
		创建地图文本(事件玩家.In_Buy_Menu_Since ? 事件玩家 : 空数组, 自定义字符串("{0}$", 全局.Money - 事件玩家.Money_spent),
			全局.Buy_Menu_Pos + 45 * 全局.Buy_Menu_Left_Up_Forward[1], 3, 不要截取, 可见和字符串, 颜色(白色), 默认可见度);
		创建地图文本(事件玩家.In_Buy_Menu_Since ? 事件玩家 : 空数组, 自定义字符串("▲"), 逐帧更新(全局.Buy_Menu_Pos - (4 + 垂直朝向角度(事件玩家))
			* 全局.Buy_Menu_Left_Up_Forward[1] + 水平朝向角度(事件玩家) * 全局.Buy_Menu_Left_Up_Forward[0]), 4, 不要截取, 可见，位置和颜色, 自定义颜色(245 + 10 * 弧度的正弦值(
			4 * 总计消耗时间), 205 + 50 * 弧度的正弦值(4 * 总计消耗时间), 200 * 弧度的正弦值(4 * 总计消耗时间), 255), 默认可见度);
		创建地图文本(事件玩家.In_Buy_Menu_Since && 绝对值(水平朝向角度(事件玩家)) <= 135 && 绝对值(垂直朝向角度(事件玩家) + 11.250) <= 45 ? 事件玩家 : 空数组, 垂直朝向角度(事件玩家)
			< -33.750 ? 数组(自定义字符串("离开购买菜单\n"), 自定义字符串("你现在拥有{0}$金币\n", 全局.Money - 事件玩家.Money_spent), 自定义字符串("退回你的金币\n"))[较大(0, 较小(2, 取整((
			水平朝向角度(事件玩家) + 135) / 90, 下)))] : 数组(垂直朝向角度(事件玩家) < -11.250 ? 自定义字符串("限时特惠将会在每一波后改变\n") : 数组(自定义字符串(
			"绝缘保护：保护你不受黑影的电击影响，并将回火影响她并入侵附近的敌人"), 自定义字符串("子弹风暴：你的武器现可使用无限弹药"), 自定义字符串("生存欲望：你的自动恢复生命值的延迟已减半"), 自定义字符串(
			"钢铁之手：你的快速近战攻击将击倒敌人\n       这个技能有15秒冷却时间"), 自定义字符串("畏惧：击杀一个敌人会有机会获得让附近敌人因恐惧效果而逃亡的效果"), 自定义字符串("复生之速：在移速超过每秒8米时重生生命值"), 自定义字符串(
			"起身战斗：你可以以两倍速被其他玩家复活"), 自定义字符串("紧急医疗：为低于50%生命值的队友额外恢复30%的生命值"), 自定义字符串("宿敌：在击杀你的敌人死亡后自动复活自己"), 自定义字符串(
			"   神秘英雄：经常性的自动切换到随机的英雄并禁用手动切换英雄\n{0}", 自定义字符串("但将额外增加20%的生命值、伤害和治疗，并永远以大招就绪状态出生")), 自定义字符串("烈拳：你将造成两倍的击退效果\n并将受到减半的击退效果"),
			自定义字符串("{0}：{1}", 事件玩家.Talent_Text123_456[2], 事件玩家.Talent_Text123_456[3]), 自定义字符串("{0}：{1}", 事件玩家.Talent_Text123_456[5],
			事件玩家.Talent_Text123_456[6]), 自定义字符串("匿踪恢复：不在敌人视线内时，移速更快，并开始恢复生命值"), 自定义字符串("精确猎杀：对10米之外的敌人额外造成50%的伤害"))
			[全局.Current_Perks[垂直朝向角度(事件玩家) >= 11.250]], 数组(自定义字符串("为你增加额外5%的生命\n"), 自定义字符串("为你增加额外5%的伤害\n"), 自定义字符串("为你增加额外5%的治疗\n"))[较大(0,
			较小(2, 取整((垂直朝向角度(事件玩家) + 33.750) / 22.500, 下)))], 数组(事件玩家.Ab_Resilience ? 自定义字符串("强韧高级版：在低于60%血量的情况下减少承受30%的伤害\n") : 自定义字符串(
			"强韧基础版：在低于30%血量的情况下减少承受30%的伤害\n"), 事件玩家.Ab_Binding_Heal ? 自定义字符串("绑定治愈高级版：在治疗友方英雄时可获得50%的对自身治疗效果\n") : 自定义字符串(
			"绑定治愈基础版：在治疗友方英雄时可获得25%的对自身治疗效果\n"), 事件玩家.Ab_Second_Wind ? 自定义字符串("第二次机会高级版：45%的几率可以在倒下后复活\n     每30秒仅可激活一次") : 自定义字符串(
			"第二次机会基础版：30%的几率可以在倒下后复活\n     每30秒仅可激活一次"))[较大(0, 较小(2, 取整((垂直朝向角度(事件玩家) + 33.750) / 22.500, 下)))], 数组(
			事件玩家.Ab_Charged ? 自定义字符串("充能高级版：终极技能的消耗减少40%\n") : 自定义字符串("充能基础版：终极技能的消耗减少20%\n"), 事件玩家.Ab_Haste ? 自定义字符串(
			"精通高级版：技能冷却时间减少50%\n") : 自定义字符串("精通基础版：技能冷却时间减少25%\n"), 事件玩家.Ab_Heavy_Impact ? 自定义字符串("沉重一击高级版：每一击都有可能眩晕敌人2秒\n") : 自定义字符串(
			"沉重一击基础版；每一击都有可能眩晕敌人1秒\n"))[较大(0, 较小(2, 取整((垂直朝向角度(事件玩家) + 33.750) / 22.500, 下)))], 数组(事件玩家.Ab_Headhunter ? 自定义字符串(
			"猎头者高级版：暴击可造成额外80%的伤害\n") : 自定义字符串("猎头者基础版：暴击可造成额外40%的伤害\n"), 事件玩家.Ab_Ambush ? 自定义字符串("伏击高级版：从背后或头顶发起的进攻将造成60%的额外伤害\n")
			: 自定义字符串("伏击基础版：从背后或头顶发起的进攻将造成30%的额外伤害\n"), 事件玩家.Ab_Quick_Fix ? 自定义字符串("快速调整高级版：消灭敌人将恢复100生命值，并短暂增加40%的移速\n") : 自定义字符串(
			"快速调整基础版：消灭敌人将恢复50生命值，并短暂增加20%的移速\n"))[较大(0, 较小(2, 取整((垂直朝向角度(事件玩家) + 33.750) / 22.500, 下)))], 数组(自定义字符串(
			"    快来打我：敌人更有可能优先攻击你\n优先攻击你的敌人额外承受15%伤害并减少造成15%伤害"), 自定义字符串("           劝你三思：敌人不经常优先攻击你\n{0}", 自定义字符串(
			"对没有攻击你的敌人造成伤害会有几率使他们逃离战场")), 自定义字符串("         别打我啦：敌人不太可能优先攻击你\n{0}", 自定义字符串("如果在过去5秒内没承受过伤害，则额外增加40%的伤害和治疗效果")))[较大(0, 较小(2,
			取整((垂直朝向角度(事件玩家) + 33.750) / 22.500, 下)))])[较大(0, 较小(5, 取整((水平朝向角度(事件玩家) + 135) / 45, 下)))],
			全局.Buy_Menu_Pos - 55 * 全局.Buy_Menu_Left_Up_Forward[1], 2.500, 不要截取, 可见和字符串, 颜色(白色), 默认可见度);
	}
}

规则("Team 2: Add Health Pool")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Is_Combatant == 真;
		全局.Upgrade_Counter > 0;
	}

	动作
	{
		If(全局.Gamemode);
			为玩家添加生命池(事件玩家, 生命值, 20 * 全局.Upgrade_Counter + 10 * 较大(0, 全局.Upgrade_Counter - 10), 真, 真);
		Else;
			为玩家添加生命池(事件玩家, 生命值, 10 * 全局.Upgrade_Counter, 真, 真);
		End;
	}
}

规则("Team 2: Change Hero (Interact), Set Last Position (1), Last Eye Position (2), Last Facing (3)")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
		事件玩家.Downed_since == 假;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		比赛时间 > 0;
		相距距离(事件玩家, 全局.Ability_Buy_Location) > 2;
	}

	动作
	{
		等待(0.250, 当为“假”时中止);
		如条件为“假”则中止;
		If(事件玩家.Perk_Mystery_Swap);
			小字体信息(事件玩家, 自定义字符串("神秘英雄将不再允许你进行手动切换英雄"));
			中止;
		End;
		事件玩家.Is_changing_Heroes = 1;
		事件玩家.Ab_Var_1 = 所选位置(事件玩家);
		事件玩家.Ab_Var_2 = 眼睛位置(事件玩家);
		事件玩家.Ab_Var_3 = 面朝方向(事件玩家);
		播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(黄色), 事件玩家.Ab_Var_1, 1);
		开始镜头(事件玩家, 射线命中位置(事件玩家.Ab_Var_2, 事件玩家.Ab_Var_2 - 8.250 * 与此角度的相对方向(与此方向的水平角度(事件玩家.Ab_Var_3), 20), 无, 无, 假) + 0.250 * 与此角度的相对方向(
			与此方向的水平角度(事件玩家.Ab_Var_3), 20), 事件玩家.Ab_Var_2, 0);
		清除状态(事件玩家, 无法杀死);
		击杀(事件玩家, 无);
		"Lower values might cause the player to fall through the map when respawning"
		传送(事件玩家, 100 * 下);
		等待(0.100, 无视条件);
		事件玩家.Is_changing_Heroes = 2;
		等待直到 (存活(事件玩家), 99999);
		停止镜头(事件玩家);
		传送(事件玩家, 事件玩家.Ab_Var_1);
		等待(0.100, 无视条件);
		设置朝向(事件玩家, 事件玩家.Ab_Var_3, 至地图);
		事件玩家.Is_changing_Heroes = 0;
	}
}

规则("Team 2: Took Damage, Set Last Damage Taken")
{
	事件
	{
		玩家受到伤害;
		队伍2;
		全部;
	}

	动作
	{
		事件玩家.Last_Damage_taken = 总计消耗时间;
	}
}

规则("Team 2 (Death): Start Camera, Play Sounds, Set is Downed, Revive Timer, Knocked down, Phased out, Death Cam Target")
{
	事件
	{
		玩家阵亡;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Is_changing_Heroes != 1;
		栏位(事件玩家) < 5;
	}

	动作
	{
		If(!事件玩家.Downed_since);
			隐藏信息(事件玩家);
			小字体信息(所有玩家(所有队伍), 自定义字符串("{0} 被打倒了！", 事件玩家));
			事件玩家.Death_Cam_Target = 眼睛位置(事件玩家) + 1000 * 与此角度的相对方向(水平朝向角度(事件玩家), 0);
			开始镜头(事件玩家, 射线命中位置(眼睛位置(事件玩家.Spectated_Player), 眼睛位置(事件玩家.Spectated_Player) - (事件玩家.Death_Cam_Target ? 6.250 * 方向(眼睛位置(
				事件玩家.Spectated_Player), 事件玩家.Death_Cam_Target) : 8.250 * 与此角度的相对方向(水平朝向角度(事件玩家.Spectated_Player), 20)), 无, 无, 假) + 0.250 * (
				事件玩家.Death_Cam_Target ? 方向(眼睛位置(事件玩家.Spectated_Player), 事件玩家.Death_Cam_Target) : 与此角度的相对方向(水平朝向角度(事件玩家.Spectated_Player), 20)),
				眼睛位置(事件玩家.Spectated_Player), 事件玩家.Death_Cam_Target ? 10 : 20);
			For 全局变量(Temp, 0, 10, 1);
				播放效果(此栏位的玩家(全局.Temp % 5, 队伍2), 环状爆炸声音, 颜色(白色), 此栏位的玩家(全局.Temp % 5, 队伍2), 200);
			End;
			事件玩家.Downed_since = 总计消耗时间;
			事件玩家.Revive_Timer = 10000;
			If(事件玩家.Perk_Nemesis && 存活(攻击方) && 所在队伍(攻击方) == 队伍1 && 所用英雄(攻击方) != 英雄(托比昂) && (全局.Gamemode != 2 || 栏位(攻击方) != 6));
				事件玩家.Nemesis_Killer = 攻击方;
			Else;
				事件玩家.Nemesis_Killer = 无;
			End;
		End;
		If(事件为环境事件);
			全局.Temp = 最近的可行走位置(事件玩家);
			调用子程序(NWP_Teleport);
		End;
		复活(事件玩家);
		清除状态(事件玩家, 相移);
		设置状态(事件玩家, 无, 无敌, 9999);
		设置状态(事件玩家, 无, 击倒, 9999);
		等待(0.050, 当为“真”时重新开始);
		设置玩家生命值(事件玩家, 1);
		设置状态(事件玩家, 无, 相移, 9999);
		If(攻击方 != 事件玩家);
			事件玩家.Death_Cam_Target = 攻击方;
			等待(5, 当为“真”时重新开始);
		End;
		事件玩家.Death_Cam_Target = 无;
	}
}

规则("Team 2: Player downed fallback")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Downed_since == 真;
		具有状态(事件玩家, 击晕) == 假;
	}

	动作
	{
		等待(0.250, 当为“假”时中止);
		如条件为“假”则中止;
		While(事件玩家.Downed_since && !具有状态(事件玩家, 击晕));
			清除状态(事件玩家, 相移);
			设置状态(事件玩家, 无, 击倒, 9999);
			等待(0.250, 无视条件);
		End;
		If(事件玩家.Downed_since);
			设置状态(事件玩家, 无, 相移, 9999);
		End;
		如条件为”真“则循环;
	}
}

规则("Team 2: Select Next Spectated Player")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Downed_since == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
	}

	动作
	{
		根据条件中止(事件玩家.Downed_since + 0.500 >= 总计消耗时间);
		事件玩家.Death_Cam_Target = 无;
		If(事件玩家.Nemesis_Killer == 无);
			事件玩家.Spectated_Player = 全局.Combatants[(数组值的索引(全局.Combatants, 事件玩家.Spectated_Player) + 1) % 全局.Combatants_Count];
		Else;
			If(事件玩家.Spectated_Player == 事件玩家);
				事件玩家.Spectated_Player = 事件玩家.Nemesis_Killer;
			Else;
				事件玩家.Spectated_Player = 事件玩家;
			End;
		End;
		等待(0.250, 无视条件);
	}
}

规则("Team 2: Spectated Player does not exist anymore")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Downed_since == 真;
		事件玩家.Spectated_Player.Is_Combatant == 假;
		所在队伍(事件玩家.Spectated_Player) != 队伍1;
	}

	动作
	{
		事件玩家.Spectated_Player = 事件玩家;
	}
}

规则("Team 2: Revive, Check Player in Radius, Unset Is Downed")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Downed_since == 真;
		事件玩家.Downed_since + 1 < 总计消耗时间;
	}

	动作
	{
		If(对任意为”真“(全局.Combatants, !当前数组元素.Downed_since && !(当前数组元素.Is_invisible % 3) && 相距距离(事件玩家, 矢量(X方向分量(所选位置(当前数组元素)), Y方向分量(所选位置(
			事件玩家)), Z方向分量(所选位置(当前数组元素)))) <= 3 && 绝对值(Y方向分量(所选位置(事件玩家)) - Y方向分量(所选位置(当前数组元素))) <= 3 && 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线)));
			If(事件玩家.Revive_Timer == 10000);
				事件玩家.Revive_Timer = 事件玩家.Perk_Up_You_Go ? 2 : 4;
			Else If(全局.Mut_Death_Guard && 对任意为”真“(范围内玩家(事件玩家, 3, 队伍1, 关闭), 存活(当前数组元素)));
				事件玩家.Revive_Timer -= 0.100;
			Else;
				事件玩家.Revive_Timer -= 0.200;
			End;
			If(事件玩家.Revive_Timer <= 0);
				小字体信息(所有玩家(所有队伍), 自定义字符串("{0} 被复活了！", 事件玩家));
				事件玩家.Downed_since = 0;
			End;
		Else;
			事件玩家.Revive_Timer = 10000;
		End;
		等待(0.200, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 2: Teleport if Player died on Jumppad")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Downed_since == 真;
		事件玩家.Downed_since + 5 < 总计消耗时间;
		事件玩家.Is_flying == 真;
	}

	动作
	{
		全局.Temp = 最近的可行走位置(所选位置(事件玩家) + 5 * 与此角度的相对方向(随机整数(-179, 180), 0));
		调用子程序(NWP_Teleport);
	}
}

规则("Team 2: Player gets up")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Downed_since == 假;
	}

	动作
	{
		根据条件中止(!事件玩家.Is_Combatant);
		显示信息(事件玩家);
		停止镜头(事件玩家);
		播放效果(所有玩家(所有队伍), 正面状态施加声音, 颜色(白色), 事件玩家, 200);
		设置玩家生命值(事件玩家, 10000);
		事件玩家.Spectated_Player = 事件玩家;
		清除状态(事件玩家, 击倒);
		清除状态(事件玩家, 相移);
		清除状态(事件玩家, 无敌);
		等待(0.150, 无视条件);
		根据条件跳过(全局.Mut_Deathbed, 1);
		设置状态(事件玩家, 无, 无敌, 1);
		If(全局.Mut_Deathbed);
			播放效果(所有玩家(所有队伍), 有害选择效果 , 颜色(红色), 事件玩家, 1);
			播放效果(所有玩家(所有队伍), 负面状态施加声音, 颜色(白色), 事件玩家, 200);
			伤害(事件玩家, 无, 5);
			等待(0.250, 无视条件);
			设置玩家生命值(事件玩家, 最大生命值(事件玩家) * 0.300);
		End;
	}
}

规则("Team 2: Heal after 2.5 sec")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Last_Damage_taken + (事件玩家.Perk_Die_Hard ? 0.500 : 1) * (全局.Mut_Deep_Wounds ? 5 : 2.500) < 总计消耗时间;
		标准化生命值(事件玩家) != 1;
		生命值(事件玩家) != 0;
	}

	动作
	{
		治疗(事件玩家, 无, 100);
		播放效果(事件玩家, 状态爆炸声音, 颜色(白色), 事件玩家, 50);
		While(真);
			等待(0.200, 当为“假”时中止);
			如条件为“假”则中止;
			治疗(事件玩家, 无, 20);
		End;
	}
}

禁用 规则("Team 2: Protect from One-shots if health is over 50%")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Is_Combatant == 真;
		标准化生命值(事件玩家) >= 0.500;
	}

	动作
	{
		设置状态(事件玩家, 无, 无法杀死, 9999);
		等待直到 (标准化生命值(事件玩家) < 0.500, 99999);
		等待(0.250, 当为“真”时重新开始);
		清除状态(事件玩家, 无法杀死);
	}
}

规则("Team 2: Set / Unset Is Flying")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		在地面上(事件玩家) == 假;
		事件玩家.Is_Combatant == 真;
	}

	动作
	{
		等待(1.500, 当为“假”时中止);
		事件玩家.Is_flying = 真;
		等待直到 (在地面上(事件玩家), 99999);
		事件玩家.Is_flying = 假;
	}
}

规则("MUT Team 2 (Mutator): Hurt Me More")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		全局.Mut_Hurt_Me_More == 真;
		事件玩家.Downed_since == 真;
		事件玩家.Downed_since + 10 >= 总计消耗时间;
	}

	动作
	{
		全局.Temp = 已过滤的数组(范围内玩家(眼睛位置(事件玩家), 3, 队伍2, 表面), 当前数组元素.Is_Combatant && !当前数组元素.Downed_since);
		伤害(全局.Temp, 无, 7);
		全局.Temp.Last_Damage_taken = 总计消耗时间;
		等待(0.250, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 2 (Ability): Ambush")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Ab_Ambush == 真;
		事件技能 != 无;
		所用英雄(被攻击方) != 英雄(托比昂);
		(Y方向分量(所选位置(事件玩家)) - Y方向分量(所选位置(被攻击方)) >= 3 || 绝对值(水平方向夹角(被攻击方, 事件玩家)) >= 90) == 真;
	}

	动作
	{
		伤害(被攻击方, 事件玩家, 事件玩家.Ab_Ambush * 30 / 事件玩家.Damage_Dealt * 事件伤害);
	}
}

规则("Team 2 (Ability): Binding Heal")
{
	事件
	{
		玩家造成治疗;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Ab_Binding_Heal == 真;
		受治疗者 != 事件玩家;
	}

	动作
	{
		设置玩家生命值(事件玩家, 生命值(事件玩家) + 事件玩家.Ab_Binding_Heal * 0.250 * 事件治疗);
	}
}

规则("Team 2 (Ability): Charged")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Ab_Charged == 真;
		终极技能充能百分比(事件玩家) < 事件玩家.Ab_Charged * 20;
	}

	动作
	{
		设置终极技能充能(事件玩家, 事件玩家.Ab_Charged * 20);
		If(正在人格复制(事件玩家));
			等待(0.016, 无视条件);
			设置终极技能充能(事件玩家, 事件玩家.Ab_Charged * 20);
		End;
	}
}

规则("Team 2 (Ability): Haste Primary Fire")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Ab_Haste == 真;
		技能冷却时间(事件玩家, 按钮(主要攻击模式)) > 0.100;
	}

	动作
	{
		设置技能冷却(事件玩家, 按钮(主要攻击模式), (1 - 0.300 * 事件玩家.Ab_Haste) * 技能冷却时间(事件玩家, 按钮(主要攻击模式)));
	}
}

规则("Team 2 (Ability): Haste Secondary Fire")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Ab_Haste == 真;
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) > 0.100;
	}

	动作
	{
		设置技能冷却(事件玩家, 按钮(辅助攻击模式), (1 - 0.300 * 事件玩家.Ab_Haste) * 技能冷却时间(事件玩家, 按钮(辅助攻击模式)));
	}
}

规则("Team 2 (Ability): Haste Ability 1")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Ab_Haste == 真;
		技能冷却时间(事件玩家, 按钮(技能1)) > 0.100;
	}

	动作
	{
		设置技能冷却(事件玩家, 按钮(技能1), (1 - 0.300 * 事件玩家.Ab_Haste) * 技能冷却时间(事件玩家, 按钮(技能1)));
	}
}

规则("Team 2 (Ability): Haste Ability 2")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Ab_Haste == 真;
		技能冷却时间(事件玩家, 按钮(技能2)) > 0.100;
	}

	动作
	{
		设置技能冷却(事件玩家, 按钮(技能2), (1 - 0.300 * 事件玩家.Ab_Haste) * 技能冷却时间(事件玩家, 按钮(技能2)));
	}
}

规则("Team 2 (Ability): Haste Jump")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Ab_Haste == 真;
		技能冷却时间(事件玩家, 按钮(跳跃)) > 0.100;
	}

	动作
	{
		设置技能冷却(事件玩家, 按钮(跳跃), (1 - 0.300 * 事件玩家.Ab_Haste) * 技能冷却时间(事件玩家, 按钮(跳跃)));
	}
}

规则("Team 2 (Ability): Haste Crouch")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Ab_Haste == 真;
		技能冷却时间(事件玩家, 按钮(蹲下)) > 0.100;
	}

	动作
	{
		设置技能冷却(事件玩家, 按钮(蹲下), (1 - 0.300 * 事件玩家.Ab_Haste) * 技能冷却时间(事件玩家, 按钮(蹲下)));
	}
}

规则("Team 2 (Ability): Headhunter")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Ab_Headhunter == 真;
		事件暴击 == 真;
	}

	动作
	{
		伤害(被攻击方, 事件玩家, 事件玩家.Ab_Headhunter * 40 / 事件玩家.Damage_Dealt * 事件伤害);
	}
}

规则("Team 2 (Ability): Priority C")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Ab_Priority == 3;
		事件玩家.Last_Damage_taken + 5 < 总计消耗时间;
	}

	动作
	{
		事件玩家.Damage_Dealt += 40;
		事件玩家.Healing_Dealt += 40;
		设置造成伤害(事件玩家, 事件玩家.Damage_Dealt);
		设置造成治疗(事件玩家, 事件玩家.Healing_Dealt);
		等待直到 (!(事件玩家.Ab_Priority == 3 && 事件玩家.Last_Damage_taken + 5 < 总计消耗时间), 99999);
		根据条件中止(!事件玩家.Ab_Priority);
		事件玩家.Damage_Dealt -= 40;
		事件玩家.Healing_Dealt -= 40;
		设置造成伤害(事件玩家, 事件玩家.Damage_Dealt);
		设置造成治疗(事件玩家, 事件玩家.Healing_Dealt);
	}
}

规则("Team 2 (Ability): Quick Fix")
{
	事件
	{
		玩家参与消灭;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Ab_Quick_Fix == 真;
	}

	动作
	{
		治疗(事件玩家, 无, 事件玩家.Ab_Quick_Fix * 50);
		设置移动速度(事件玩家, 100 + 事件玩家.Ab_Quick_Fix * 20);
		等待(5, 当为“真”时重新开始);
		设置移动速度(事件玩家, 100);
	}
}

规则("Team 2 (Ability): Resilience")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Ab_Resilience == 真;
		标准化生命值(事件玩家) < 事件玩家.Ab_Resilience * 0.300;
	}

	动作
	{
		设置受到伤害(事件玩家, 70);
		等待直到 (!(事件玩家.Ab_Resilience && 标准化生命值(事件玩家) < 事件玩家.Ab_Resilience * 0.300), 99999);
		设置受到伤害(事件玩家, 100);
	}
}

规则("Team 2 (Ability): Second Wind")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Ab_Second_Wind == 真;
		事件玩家.Downed_since == 真;
		事件玩家.Downed_since + 1.500 < 总计消耗时间;
	}

	动作
	{
		根据条件中止(随机整数(1, 100) > 事件玩家.Ab_Second_Wind * 30);
		小字体信息(所有玩家(所有队伍), 自定义字符串("{0}获得了第二次机会！", 事件玩家));
		播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(绿色), 事件玩家, 1);
		事件玩家.Downed_since = 0;
		等待(30, 无视条件);
	}
}

规则("Team 2 (Ability): Sharpshooter")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Perk_Sharpshooter == 真;
		事件技能 != 无;
		所用英雄(被攻击方) != 英雄(托比昂);
		相距距离(事件玩家, 被攻击方) >= 10;
	}

	动作
	{
		伤害(被攻击方, 事件玩家, 50 / 事件玩家.Damage_Dealt * 事件伤害);
	}
}

规则("Team 2 (Perk): Bulletstorm")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Perk_Bulletstorm == 真;
		(弹药(事件玩家, 0) < 最大弹药量(事件玩家, 0) || 弹药(事件玩家, 1) < 最大弹药量(事件玩家, 1)) == 真;
	}

	动作
	{
		设置弹药(事件玩家, 0, 1000);
		设置弹药(事件玩家, 1, 1000);
	}
}

规则("Team 2 (Perk): Mystery Swap")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Perk_Mystery_Swap == 真;
		事件玩家.Perk_Mystery_Swap < 总计消耗时间;
		事件玩家.Downed_since == 假;
	}

	动作
	{
		等待(1, 当为“假”时中止);
		如条件为“假”则中止;
		事件玩家.Perk_Mystery_Swap = 总计消耗时间 + 随机整数(45, 75);
		开始强制玩家选择英雄(事件玩家, 数组随机取值(从数组中移除(全局.Gamemode || 全局.Upgrade_Counter >= 25 ? 全部英雄 : 数组分割(全局.HR_Hostage_Hero_Array, 0,
			全局.Upgrade_Counter + 7), 所用英雄(事件玩家))));
		事件玩家.Is_invisible = 0;
		等待(0.100, 无视条件);
		设置终极技能充能(事件玩家, 100);
	}
}

规则("Team 2 (Perk): Pumping Iron")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Perk_Pumping_Iron == 真;
		事件技能 == 按钮(近身攻击);
		所用英雄(被攻击方) != 英雄(托比昂);
		存活(被攻击方) == 真;
	}

	动作
	{
		被攻击方.Perk_Pumping_Iron = 较大(总计消耗时间 + (全局.GMut_Fortified || 被攻击方.Is_Living_Boss ? 1.250 : 2.500), 被攻击方.Perk_Pumping_Iron);
		设置状态(被攻击方, 无, 击倒, 全局.GMut_Fortified || 被攻击方.Is_Living_Boss ? 1.250 : 2.500);
		等待(0.400, 当为“真”时重新开始);
		等待(14.600, 无视条件);
	}
}

规则("Team 2 (Perk): Running Riot")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Perk_Running_Riot == 真;
		速度(事件玩家) >= 8;
	}

	动作
	{
		治疗(事件玩家, 无, 8);
		等待(0.200, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 2 (Perk): Terrify")
{
	事件
	{
		玩家造成最后一击;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Perk_Terrify == 真;
	}

	动作
	{
		根据条件中止(随机整数(1, 100) > 20);
		全局.Temp = 首个(已排序的数组(已过滤的数组(范围内玩家(眼睛位置(被攻击方), 20, 队伍1, 表面), 存活(当前数组元素) && 所用英雄(当前数组元素) != 英雄(托比昂) && !具有状态(当前数组元素, 相移)), 相距距离(被攻击方,
			当前数组元素)));
		根据条件中止(全局.Temp == 0);
		全局.Temp.Feared_until = 总计消耗时间 + (全局.Temp.Is_Living_Boss ? 2.500 : 5);
	}
}

规则("Team 2 Doomfist: Meteor Strike (Invisibility 2, not detectable)")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		末日铁拳;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		事件玩家.Is_invisible = 2;
		等待直到 (!正在使用终极技能(事件玩家), 99999);
		事件玩家.Is_invisible = 0;
	}
}

规则("Team 2 D.Va: Fill Ultimate Charge when downed")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		D.Va;
	}

	条件
	{
		事件玩家.Downed_since == 真;
		终极技能充能百分比(事件玩家) != 100;
	}

	动作
	{
		等待(0.100, 当为“假”时中止);
		设置终极技能充能(事件玩家, 100);
	}
}

规则("Team 2 Echo: (Workaround) Player died Event failed to trigger")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		回声;
	}

	条件
	{
		死亡(事件玩家) == 真;
		事件玩家.Is_changing_Heroes == 假;
	}

	动作
	{
		等待(0.100, 当为“假”时中止);
		复活(事件玩家);
	}
}

规则("Team 2 Echo: Stealth (Invisibility 1, detectable)")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(回声);
		正在复制的英雄(事件玩家) == 英雄(黑影);
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		等待(0.800, 当为“假”时中止);
		事件玩家.Is_invisible = 1;
		等待直到 (!(正在复制的英雄(事件玩家) == 英雄(黑影) && 正在使用技能 1(事件玩家)), 99999);
		事件玩家.Is_invisible = 0;
	}
}

规则("Team 2 Junkrat: Detonate RIP-Tire when downed")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		狂鼠;
	}

	条件
	{
		事件玩家.Downed_since == 真;
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		按下按键(事件玩家, 按钮(终极技能));
		等待(0.500, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 2 Mercy: Revive Ability (Player)")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		天使;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		技能冷却时间(事件玩家, 按钮(技能2)) == 0;
		事件玩家.Downed_since == 假;
		具有状态(事件玩家, 被入侵) == 假;
		具有状态(事件玩家, 击晕) == 假;
	}

	动作
	{
		事件玩家.Ab_Player = 最后(已排序的数组(已过滤的数组(范围内玩家(事件玩家, 10, 队伍2, 关闭),
			当前数组元素.Is_Combatant && 当前数组元素.Downed_since && 当前数组元素.Downed_since + 0.100 < 总计消耗时间 && 在视野内(事件玩家, 当前数组元素, 45)), 标量积(面朝方向(事件玩家),
			方向(眼睛位置(事件玩家), 当前数组元素))));
		If(事件玩家.Ab_Player != 0);
			小字体信息(所有玩家(所有队伍), 自定义字符串("{0} 已经被 {1}{2}复活！", 事件玩家.Ab_Player, 英雄图标字符串(英雄(天使)), 事件玩家));
			事件玩家.Ab_Player.Downed_since = 0;
			播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(天蓝色), 事件玩家.Ab_Player, 1);
			设置技能冷却(事件玩家, 按钮(技能2), 30);
		End;
		等待(0.050, 无视条件);
		If(事件玩家.Talent_Active_1);
			设置状态(事件玩家.Ab_Player, 无, 点燃, 8);
			设置状态(事件玩家.Ab_Player, 无, 无敌, 8);
			大字体信息(事件玩家.Ab_Player, 自定义字符串("已获得奇迹现临效果！"));
		End;
	}
}

规则("Team 2 Mei: Cryo-Freeze (Invisibility 3, not detectable, can contest)")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		美;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		事件玩家.Is_invisible = 3;
		等待直到 (!正在使用技能 1(事件玩家), 99999);
		事件玩家.Is_invisible = 0;
	}
}

规则("IV Team 2 Moira: Biotic Grasp on Portal Simulation")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		莫伊拉;
	}

	条件
	{
		全局.Gamemode == 1;
		全局.IV_Portal_Status == 1;
		正在使用辅助武器(事件玩家) == 真;
	}

	动作
	{
		If(相距距离(眼睛位置(事件玩家), 全局.IV_Objective_Position + 1.110 * 上) <= 20 && 在视线内(眼睛位置(事件玩家), 全局.IV_Objective_Position + 1.110 * 上,
			屏障不会阻挡视线));
			"If Facing ray intersects sphere"
			If(相距距离(全局.IV_Objective_Position + 1.110 * 上, 眼睛位置(事件玩家) + 较大(0, 标量积(面朝方向(事件玩家), 向量(眼睛位置(事件玩家),
				全局.IV_Objective_Position + 1.110 * 上))) * 面朝方向(事件玩家)) <= 0.850);
				伤害(此栏位的玩家(6, 队伍1), 事件玩家, 9.600);
			End;
		End;
		等待(0.192, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 2 Sombra: Stealth (Invisibility 1, detectable), end after 30 seconds")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		黑影;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		等待(0.800, 当为“假”时中止);
		事件玩家.Is_invisible = 1;
		等待直到 (!正在使用技能 1(事件玩家), 30);
		If(正在使用技能 1(事件玩家));
			按下按键(事件玩家, 按钮(技能1));
		End;
		事件玩家.Is_invisible = 0;
	}
}

规则("Team 2 Tracer: Start Health Regeneration after Recall")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		猎空;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		等待(0.850, 无视条件);
		事件玩家.Last_Damage_taken = 0;
	}
}

规则("Global: Set / Unset Is Infrasight on (Players)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.Is_Infrasight_on_Players1 != 对任意为”真“(所有玩家(队伍2), (所用英雄(当前数组元素) == 英雄(黑百合) || 正在复制的英雄(当前数组元素) == 英雄(黑百合)) && 正在使用终极技能(当前数组元素));
	}

	动作
	{
		全局.Is_Infrasight_on_Players1 = !全局.Is_Infrasight_on_Players1;
		等待(0.016, 无视条件);
		如条件为”真“则循环;
	}
}

规则("HR Team 2 Hostage: Create Entities, Rescuer (Player), Status (2), 0 = NA, 1 = Waiting, 2 = Rescuable, Timer (3)")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		栏位 5;
	}

	动作
	{
		创建地图文本(所有玩家(所有队伍), 自定义字符串("英雄解救点"), 全局.Player_Spawn, 1.500, 不要截取, 可见, 颜色(白色), 默认可见度);
		创建效果(所有玩家(所有队伍), 环, 颜色(白色), 全局.Player_Spawn, 2, 可见);
		设置状态(事件玩家, 无, 相移, 9999);
		开始朝向(事件玩家, 向量(事件玩家, 事件玩家.Ab_Player), 事件玩家.Ab_Player == 0 ? 0 : 100, 至地图, 方向及角速率);
		开始定向阈值(事件玩家, 向量(事件玩家, 事件玩家.Ab_Player), 事件玩家.Ab_Player != 0 && 相距距离(事件玩家.Ab_Player, 矢量(X方向分量(所选位置(事件玩家)), Y方向分量(所选位置(
			事件玩家.Ab_Player)), Z方向分量(所选位置(事件玩家)))) >= 2, 至地图, 替换现有阈值, 方向和幅度);
		创建光束效果(事件玩家.Ab_Player != 0 ? 所有玩家(所有队伍) : 空数组, 抓钩光束, 事件玩家, 事件玩家.Ab_Player, 颜色(白色), 可见，位置和半径);
		创建HUD文本(事件玩家.Ab_Var_2 == 2 ? 所有玩家(所有队伍) : 空数组, 英雄图标字符串(所用英雄(事件玩家)), 自定义字符串("解救 {0}", 所用英雄(事件玩家)), 自定义字符串("解锁英雄可以同时为你获得额外生命", 所用英雄(
			事件玩家)), 右边, -20, 颜色(黄色), 颜色(黄色), 颜色(黄色), 可见和字符串, 默认可见度);
		创建HUD文本(事件玩家.Ab_Player, 自定义字符串("把{0}带到英雄解救点！", 所用英雄(事件玩家)), 无, 无, 顶部, 70, 颜色(黄色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(事件玩家.Ab_Player != 0 ? 已过滤的数组(范围内玩家(事件玩家, 3, 队伍2, 表面), !当前数组元素.Downed_since && 当前数组元素 != 事件玩家.Ab_Player) : 空数组, 自定义字符串(
			"使用“集合”语音指令来带走{0}。", 所用英雄(事件玩家)), 无, 无, 顶部, 70, 颜色(黄色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建地图文本(事件玩家.Ab_Var_2 == 2 && 事件玩家.Ab_Player == 0 ? 所有玩家(所有队伍) : 空数组, 自定义字符串("解救 {0}：{1}", 所用英雄(事件玩家), 取整(事件玩家.Ab_Var_3 - 总计消耗时间,
			上)), 事件玩家, 1.500, 不要截取, 可见，位置和字符串, 颜色(黄色), 默认可见度);
		创建图标(事件玩家.Ab_Var_2 == 2 ? 从数组中移除(所有玩家(所有队伍), 事件玩家.Ab_Player) : 空数组, 事件玩家, 感叹号, 可见, 颜色(黄色), 真);
		创建图标(事件玩家.Ab_Player, 全局.Player_Spawn + 2 * 上, 箭头：向下, 可见, 颜色(黄色), 真);
		等待(0.250, 无视条件);
		事件玩家.Ab_Var_2 = 1;
	}
}

规则("HR Team 2 Hostage: Set Rescuable")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		栏位 5;
	}

	条件
	{
		事件玩家.Ab_Var_2 == 1;
		全局.Upgrade_Counter < 1.500 * 全局.Wave + 1.500;
	}

	动作
	{
		事件玩家.Ab_Var_2 = 2;
		事件玩家.Ab_Var_3 = 总计消耗时间 + 60;
		设置不可见(事件玩家, 无);
	}
}

规则("HR Team 2 Hostage: Is Rescuable (2), Change Hero, Stop Forcing Position, Teleport")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		栏位 5;
	}

	条件
	{
		事件玩家.Ab_Var_2 == 2;
	}

	动作
	{
		开始强制玩家选择英雄(事件玩家, 全局.HR_Hostage_Hero_Array[全局.Upgrade_Counter + 7]);
		停止强制设置玩家位置(事件玩家);
		等待(0.250, 无视条件);
		传送(事件玩家, 数组随机取值(全局.Objective_Spawns));
	}
}

规则("HR Team 2: Make Hostage Follow")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		此栏位的玩家(5, 队伍2).Ab_Var_2 == 2;
		此栏位的玩家(5, 队伍2).Ab_Player == 0;
		事件玩家.Is_Combatant == 真;
		事件玩家.Downed_since == 假;
		事件玩家.Is_changing_Heroes == 假;
		相距距离(事件玩家, 此栏位的玩家(5, 队伍2)) <= 3;
		在视线内(事件玩家, 此栏位的玩家(5, 队伍2), 屏障不会阻挡视线) == 真;
	}

	动作
	{
		如条件为“假”则中止;
		此栏位的玩家(5, 队伍2).Ab_Player = 事件玩家;
		交流(事件玩家, 我跟着你);
	}
}

规则("HR Team 2: Take Hostage from another Player")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		此栏位的玩家(5, 队伍2).Ab_Var_2 == 2;
		此栏位的玩家(5, 队伍2).Ab_Player != 0;
		事件玩家.Is_Combatant == 真;
		事件玩家.Downed_since == 假;
		事件玩家.Is_changing_Heroes == 假;
		正在交流(事件玩家, 集合) == 真;
		相距距离(事件玩家, 此栏位的玩家(5, 队伍2)) <= 3;
		在视线内(事件玩家, 此栏位的玩家(5, 队伍2), 屏障不会阻挡视线) == 真;
	}

	动作
	{
		如条件为“假”则中止;
		此栏位的玩家(5, 队伍2).Ab_Player = 事件玩家;
		等待(1, 无视条件);
		交流(此栏位的玩家(5, 队伍2), 收到);
		等待(3.100, 无视条件);
		如条件为”真“则循环;
	}
}

规则("HR Team 2 Hostage: Stop if too far away")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		栏位 5;
	}

	条件
	{
		事件玩家.Ab_Player != 0;
		事件玩家.Ab_Var_2 == 2;
		相距距离(事件玩家, 事件玩家.Ab_Player) >= 10;
	}

	动作
	{
		等待(0.500, 当为“假”时中止);
		事件玩家.Ab_Player = 0;
		事件玩家.Ab_Var_3 = 总计消耗时间 + 30;
		交流(事件玩家, 需要帮助);
	}
}

规则("HR Team 2 Hostage: Stop if downed or Player left or changing heroes")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		栏位 5;
	}

	条件
	{
		事件玩家.Ab_Player != 0;
		事件玩家.Ab_Var_2 == 2;
		(事件玩家.Ab_Player.Downed_since || !事件玩家.Ab_Player.Is_Combatant || 事件玩家.Ab_Player.Is_changing_Heroes) == 真;
	}

	动作
	{
		事件玩家.Ab_Player = 0;
		事件玩家.Ab_Var_3 = 总计消耗时间 + 30;
		交流(事件玩家, 需要帮助);
	}
}

规则("HR Team 2 Hostage: Stop if Hostage dies")
{
	事件
	{
		玩家阵亡;
		队伍2;
		栏位 5;
	}

	动作
	{
		全局.Temp = 最近的可行走位置(事件玩家);
		调用子程序(NWP_Teleport);
		复活(事件玩家);
		事件玩家.Ab_Player = 0;
		事件玩家.Ab_Var_3 = 总计消耗时间 + 30;
		交流(事件玩家, 需要帮助);
	}
}

规则("HR Team 2 Hostage: Jump if stuck")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		栏位 5;
	}

	条件
	{
		阈值(事件玩家) != 矢量(0, 0, 0);
		速度(事件玩家) <= 3;
	}

	动作
	{
		按下按键(事件玩家, 按钮(跳跃));
		等待(1, 无视条件);
		如条件为”真“则循环;
	}
}

规则("HR Team 2 Hostage: At Hero Drop-off")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		栏位 5;
	}

	条件
	{
		相距距离(事件玩家, 全局.Player_Spawn) <= 2;
	}

	动作
	{
		全局.Upgrade_Counter += 1;
		设置玩家可选的英雄(从数组中移除(所有玩家(队伍2), 事件玩家), 全局.Upgrade_Counter >= 25 ? 全部英雄 : 数组分割(全局.HR_Hostage_Hero_Array, 0, 全局.Upgrade_Counter + 7));
		设置受到治疗(所有玩家(队伍2), 100 + 2 * 全局.Upgrade_Counter);
		开始持续治疗(所有玩家(队伍2), 无, 1, 10000);
		大字体信息(所有玩家(所有队伍), 自定义字符串("解锁了{0}！并获得额外生命值", 所用英雄(事件玩家)));
		播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(白色), 所选位置(事件玩家), 1);
		播放效果(所有玩家(所有队伍), 爆炸声音, 颜色(白色), 所选位置(事件玩家), 200);
		交流(事件玩家, 感谢);
		事件玩家.Ab_Player = 0;
		事件玩家.Ab_Var_2 = 0;
		设置不可见(事件玩家, 全部);
		If(全局.Upgrade_Counter < 25);
			等待(15, 无视条件);
			事件玩家.Ab_Var_2 = 1;
		Else;
			等待(2, 无视条件);
			移除机器人(队伍2, 5);
		End;
	}
}

规则("HR Team 2 Hostage: Timer is over")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		栏位 5;
	}

	条件
	{
		事件玩家.Ab_Player == 0;
		事件玩家.Ab_Var_2 == 2;
		事件玩家.Ab_Var_3 < 总计消耗时间;
	}

	动作
	{
		大字体信息(所有玩家(所有队伍), 自定义字符串("没能解救{0}", 所用英雄(事件玩家)));
		事件玩家.Ab_Player = 0;
		事件玩家.Ab_Var_2 = 0;
		设置不可见(事件玩家, 全部);
		等待(30, 无视条件);
		事件玩家.Ab_Var_2 = 1;
	}
}

规则("HR Team 2 Hostage: Start Forcing Position")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		栏位 5;
	}

	条件
	{
		事件玩家.Ab_Var_2 != 2;
	}

	动作
	{
		开始强制设置玩家位置(事件玩家, 100 * 上, 假);
	}
}

规则("Subroutine: Teleport to free Spawn")
{
	事件
	{
		子程序;
		Teleport_to_free_Spawn;
	}

	动作
	{
		If(全局.Gamemode == 1 && (栏位(事件玩家) == 6 || 全局.Boss_Spawns_remaining > 0) && 死亡(事件玩家));
			事件玩家.Nav_is_reachable_Node = 假;
			If(栏位(事件玩家) == 6 && !全局.IV_Portal_Status);
				传送(事件玩家, 100 * 上);
			Else;
				传送(事件玩家, 全局.IV_Objective_Position + 上);
			End;
		Else If(全局.Gamemode == 2 && 全局.HVT_Call_Reinforcements1 >= 总计消耗时间 && 全局.Boss_Spawns_remaining > 0 && 死亡(事件玩家));
			事件玩家.Nav_is_reachable_Node = 假;
			传送(事件玩家, 此栏位的玩家(6, 队伍1));
		Else;
			全局.Temp = 首个(已排序的数组(全局.Spawns, 随机实数(0, 1) + ((此栏位的玩家(0, 队伍2).Is_Combatant && 在视线内(当前数组元素 + 上, 此栏位的玩家(0, 队伍2), 屏障不会阻挡视线)) || (
				此栏位的玩家(1, 队伍2).Is_Combatant && 在视线内(当前数组元素 + 上, 此栏位的玩家(1, 队伍2), 屏障不会阻挡视线)) || (此栏位的玩家(2, 队伍2).Is_Combatant && 在视线内(当前数组元素 + 上,
				此栏位的玩家(2, 队伍2), 屏障不会阻挡视线)) || (此栏位的玩家(3, 队伍2).Is_Combatant && 在视线内(当前数组元素 + 上, 此栏位的玩家(3, 队伍2), 屏障不会阻挡视线)) || (此栏位的玩家(4, 队伍2)
				.Is_Combatant && 在视线内(当前数组元素 + 上, 此栏位的玩家(4, 队伍2), 屏障不会阻挡视线)) ? 100 : ((此栏位的玩家(0, 队伍2).Is_Combatant && 相距距离(当前数组元素, 此栏位的玩家(0,
				队伍2)) <= 10) || (此栏位的玩家(1, 队伍2).Is_Combatant && 相距距离(当前数组元素, 此栏位的玩家(1, 队伍2)) <= 10) || (此栏位的玩家(2, 队伍2).Is_Combatant && 相距距离(
				当前数组元素, 此栏位的玩家(2, 队伍2)) <= 10) || (此栏位的玩家(3, 队伍2).Is_Combatant && 相距距离(当前数组元素, 此栏位的玩家(3, 队伍2)) <= 10) || (此栏位的玩家(4, 队伍2)
				.Is_Combatant && 相距距离(当前数组元素, 此栏位的玩家(4, 队伍2)) <= 10) ? 50 : 0))));
			事件玩家.Nav_Index = 全局.Spawns_Nearest_Nodes_by_Index[数组值的索引(全局.Spawns, 全局.Temp)];
			事件玩家.Nav = 全局.Nodes[事件玩家.Nav_Index];
			事件玩家.Nav_is_reachable_Node = 真;
			传送(事件玩家, 全局.Temp);
		End;
	}
}

规则("Subroutine: Roam")
{
	事件
	{
		子程序;
		Roam;
	}

	动作
	{
		事件玩家.Nav = 所选位置(事件玩家) + 3.500 * 与此角度的相对方向(随机整数(-179, 180), 0);
		调用子程序(Find_NWP_near_Nav);
	}
}

规则("Subroutine: Find NWP near Nav (try to find a reachable walkable position near the Nav)")
{
	事件
	{
		子程序;
		Find_NWP_near_Nav;
	}

	动作
	{
		全局.Temp = 最近的可行走位置(事件玩家.Nav);
		"If NWP is valid and probably reachable"
		If(全局.Temp != 空数组 && 相距距离(事件玩家.Nav, 全局.Temp) < 3);
			事件玩家.Nav = 全局.Temp;
		Else;
			"If Nav is not walkable"
			If(相距距离(事件玩家.Nav + 上, 射线命中位置(事件玩家.Nav + 上, 事件玩家.Nav + 2 * 下, 无, 无, 假)) >= 3);
				If(事件玩家.Is_Ranged_Hero || 相距距离(事件玩家, 事件玩家.Target) < 2);
					事件玩家.Nav = 所选位置(事件玩家);
				Else;
					事件玩家.Nav = 所选位置(事件玩家.Target) + 2 * 方向(事件玩家.Target, 事件玩家);
				End;
			End;
		End;
	}
}

规则("Subroutine: Find Chase Target")
{
	事件
	{
		子程序;
		Find_Chase_Target;
	}

	动作
	{
		事件玩家.Target = 首个(已排序的数组(已过滤的数组(全局.Combatants, !当前数组元素.Downed_since && 当前数组元素.Is_invisible <= (相距距离(事件玩家, 当前数组元素)
			<= 2.400 || 全局.Is_Infrasight_on_Bots1)), 相距距离(事件玩家, 当前数组元素)));
	}
}

规则("Team 1: Start Facing, Throttle, Set Respawn Max Time, Set Healing Dealt, Create Info HUD")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	动作
	{
		开始定向阈值(事件玩家, 向量(事件玩家, 事件玩家.Nav), 相距距离(事件玩家, 矢量(X方向分量(事件玩家.Nav), Y方向分量(所选位置(事件玩家)), Z方向分量(事件玩家.Nav))) >= 0.500, 至地图, 替换现有阈值, 方向和幅度);
		设置最大复生时间(事件玩家, 9999);
		设置造成治疗(事件玩家, 0);
		事件玩家.Ab_String = 字符串("");
		事件玩家.Is_assaulting = 真;
		创建HUD文本(事件玩家, 自定义字符串("{0}\n{1}", 自定义字符串("目标：{0}\n目标位于视野：{1}\n目标寻路位置：{2}", 事件玩家.Target, 事件玩家.Is_Target_in_LOS,
			事件玩家.Target.Nav_Index), 自定义字符串("目标最后寻路更新：{0}\n使用作战寻路：{1}\n寻路节点可到达：{2}", 事件玩家.Target.Last_Nav_Update,
			事件玩家.Is_using_Combat_Pathfinding, 事件玩家.Nav_is_reachable_Node)), 无, 无, 左边, -100, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
	}
}

规则("Team 1 (Death): Field Resurrection, Set Near Baptiste, Set Can respawn after, Unset Is Target in LOS")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		全局.Wave > 0;
	}

	动作
	{
		清除状态(事件玩家, 点燃);
		停止所有持续伤害(事件玩家);
		If(全局.Gamemode == 2 && 栏位(事件玩家) == 6 && (全局.IV_Portal_Status == 1 || 全局.IV_Portal_Status == 2));
			If(全局.IV_Portal_Status == 1);
				If(全局.HVT_Times_Subdued);
					大字体信息(所有玩家(所有队伍), 自定义字符串("已压制高价值目标！"));
				Else;
					大字体信息(所有玩家(所有队伍), 自定义字符串("已压制高价值目标！已获得额外生命值！"));
				End;
				全局.HVT_Times_Subdued += 1;
				全局.IV_Portal_Status = 2;
				事件玩家.Revive_Timer = 0;
				事件玩家.Downed_since = 2;
				事件玩家.Perk_Pumping_Iron = 100000;
			End;
			If(事件为环境事件);
				全局.Temp = 最近的可行走位置(事件玩家);
				调用子程序(NWP_Teleport);
			End;
			复活(事件玩家);
			清除状态(事件玩家, 相移);
			设置状态(事件玩家, 无, 无敌, 9999);
			设置状态(事件玩家, 无, 击倒, 9999);
			等待(0.050, 当为“真”时重新开始);
			设置状态(事件玩家, 无, 相移, 9999);
			中止;
		End;
		If(!事件为环境事件 && 栏位(事件玩家) != 6 && !事件玩家.Is_mutated && 所用英雄(事件玩家) != 英雄(巴蒂斯特) && (全局.Mut_Advanced_Medkit || !事件玩家.Is_Living_Boss));
			全局.Temp = 数组随机取值(已过滤的数组(选择英雄的玩家(英雄(巴蒂斯特), 队伍1), 存活(当前数组元素) && !(具有状态(当前数组元素, 被入侵) || 具有状态(当前数组元素, 击晕)
				|| 当前数组元素.Feared_until >= 总计消耗时间) && 当前数组元素.Ab_Var_2 + (全局.Mut_Combat_Medic ? 2 : 4) < 总计消耗时间 && 相距距离(事件玩家, 当前数组元素)
				<= 8 && 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线)));
			If(全局.Temp != 0);
				全局.Temp.Ab_Var_2 = 总计消耗时间;
				按下按键(全局.Temp, 按钮(技能1));
				复活(事件玩家);
				播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(绿色), 事件玩家, 1);
				"Knocked Down Status is not applied when the bot is killed while stunned without a wait"
				等待(0.016, 当为“真”时重新开始);
				事件玩家.Perk_Pumping_Iron = 较大(总计消耗时间 + 1.750, 事件玩家.Perk_Pumping_Iron);
				设置状态(事件玩家, 无, 击倒, 1.750);
				中止;
			End;
		End;
		If(全局.GMut_Storm_Raging && 事件玩家.GMut_Var);
			数组分割(已排序的数组(已过滤的数组(范围内玩家(眼睛位置(事件玩家), 10, 队伍1, 表面), 存活(当前数组元素) && !当前数组元素.GMut_Var && 所用英雄(当前数组元素) != 英雄(托比昂)), 相距距离(事件玩家, 当前数组元素)),
				0, 2).GMut_Var = 真;
		End;
		事件玩家.Nemesis_Killer = 已过滤的数组(全局.Combatants,
			当前数组元素.Downed_since && 当前数组元素.Downed_since + 0.100 < 总计消耗时间 && 当前数组元素.Nemesis_Killer == 事件玩家);
		If(事件玩家.Nemesis_Killer != 空数组);
			小字体信息(所有玩家(所有队伍), 自定义字符串("一名宿敌已阵亡！"));
			事件玩家.Nemesis_Killer.Downed_since = 0;
			For 全局变量(Temp, 0, 数量(事件玩家.Nemesis_Killer), 1);
				播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(绿色), 事件玩家.Nemesis_Killer[全局.Temp], 1);
			End;
		End;
		If(全局.Gamemode == 0);
			事件玩家.Can_respawn_after = 总计消耗时间 + 较大(0, 4 - 0.300 * 全局.Wave);
			全局.Money += (全局.Mutators_activated ? 4 : 2) * (事件玩家.Level != 4 && 事件玩家.Is_Living_Boss ? (所用英雄(事件玩家) == 英雄(源氏) || 所用英雄(事件玩家) == 英雄(
				半藏) ? 50 : 70) : 5);
			If(事件玩家.Is_Living_Boss);
				停止强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍));
			End;
		End;
		事件玩家.Is_Living_Boss = 假;
		事件玩家.Is_Target_in_LOS = 0;
	}
}

规则("Team 1 (Respawn): Reset Dummy, Change Hero, Set Last Hero Change")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		死亡(事件玩家) == 真;
		(全局.Gamemode ? (栏位(事件玩家) == 6 ? 全局.IV_HVT_Spawn_Slot_Six : 全局.Spawns_remaining || 全局.Boss_Spawns_remaining) : (
			全局.Spawns_remaining > 0 || (全局.Boss_Spawns_remaining > 0 && 栏位(事件玩家) >= 4))) == 真;
		事件玩家.Can_respawn_after < 总计消耗时间;
		事件玩家.Level != 0;
	}

	动作
	{
		If(栏位(事件玩家) != 6);
			等待(0.500 + 0.200 * 栏位(事件玩家), 当为“假”时中止);
			如条件为“假”则中止;
		End;
		If(事件玩家.Is_mutated);
			停止调整玩家大小(事件玩家);
			停止修改英雄语音(事件玩家);
			事件玩家.Is_mutated = 假;
			全局.Mut_Mutation = 总计消耗时间 + 30;
		End;
		调用子程序(Teleport_to_free_Spawn);
		"Select Hero"
		If(全局.Gamemode == 0);
			If(全局.Boss_Spawns_remaining > 0 && 栏位(事件玩家) >= 4);
				全局.Boss_Spawns_remaining -= 1;
				If(全局.Wave == 5 || 全局.Wave == 16);
					开始强制玩家选择英雄(事件玩家, 栏位(事件玩家) == 4 ? 英雄(源氏) : 英雄(半藏));
				Else If(全局.Wave == 10 || 全局.Wave == 19);
					开始强制玩家选择英雄(事件玩家, 英雄(莱因哈特));
				Else;
					开始强制玩家选择英雄(事件玩家, 英雄(堡垒));
				End;
			Else;
				全局.Spawns_remaining -= 1;
				全局.Temp = 全局.Mut_Promotion && 随机整数(1, 100) <= 20 && 事件玩家.Level < 3;
				If(全局.Mut_The_Cavalry && 栏位(事件玩家) == 0 && 所用英雄(事件玩家) != 英雄(猎空));
					开始强制玩家选择英雄(事件玩家, 英雄(猎空));
				Else If(事件玩家.Level + 全局.Temp == 1);
					开始强制玩家选择英雄(事件玩家, 数组随机取值(已过滤的数组(数组(英雄(卡西迪), 英雄(士兵：76), 全局.Wave >= 3 ? 英雄(布丽吉塔) : 假), 当前数组元素)));
				Else If(事件玩家.Level + 全局.Temp == 2);
					If(全局.Wave >= 8 && 全局.HR_Wave_Start + 100 < 总计消耗时间 && !正在使用英雄(英雄(死神), 队伍1));
						开始强制玩家选择英雄(事件玩家, 英雄(死神));
					Else;
						开始强制玩家选择英雄(事件玩家, 数组随机取值(已过滤的数组(数组(英雄(黑百合), 数量(选择英雄的玩家(英雄(回声), 队伍1)) < 2 ? 英雄(回声) : 假, 全局.Wave >= 6 ? 英雄(巴蒂斯特) : 假,
							全局.Wave >= 8 && !正在使用英雄(英雄(黑影), 队伍1) ? 英雄(黑影) : 假, 英雄(秩序之光), 全局.Wave >= 9 ? 英雄(法老之鹰) : 假, 全局.Mut_Meteor_Shower ? 英雄(末日铁拳) : 假),
							当前数组元素)));
					End;
				Else If(事件玩家.Level + 全局.Temp == 3);
					开始强制玩家选择英雄(事件玩家, 数组随机取值(已过滤的数组(数组(英雄(路霸), 全局.Wave >= 7 && 数量(选择英雄的玩家(英雄(奥丽莎), 队伍1)) < 2 ? 英雄(奥丽莎) : 假, 全局.Wave >= 9 ? 英雄(猎空) : 假,
						全局.Wave >= 11 && !正在使用英雄(英雄(西格玛), 队伍1) ? 英雄(西格玛) : 假, 全局.Wave >= 9 ? 英雄(破坏球) : 假, 全局.Wave >= 13 && !正在使用英雄(英雄(美), 队伍1) ? 英雄(美)
						: 假), 当前数组元素)));
				Else If(事件玩家.Level == 4);
					开始强制玩家选择英雄(事件玩家, 数组随机取值(数组(英雄(源氏), 英雄(半藏))));
				End;
			End;
		Else;
			If(栏位(事件玩家) == 6);
				全局.IV_HVT_Spawn_Slot_Six = 假;
				If(全局.Gamemode == 1);
					If(全局.IV_Portal_Status);
						开始强制玩家选择英雄(事件玩家, 数组(英雄(奥丽莎), 英雄(西格玛), 英雄(半藏), 英雄(源氏), 英雄(回声), 英雄(黑影), 英雄(猎空), 英雄(莱因哈特), 英雄(堡垒), 英雄(死神), 英雄(路霸), 英雄(法老之鹰), 英雄(源氏),
							英雄(莱因哈特), 英雄(堡垒))[全局.Wave - 1]);
					Else;
						开始强制玩家选择英雄(事件玩家, 英雄(托比昂));
						全局.IV_Portal_Status = 1;
						大字体信息(所有玩家(所有队伍), 自定义字符串("传送门已开启！"));
					End;
				Else If(全局.Gamemode == 2);
					开始强制玩家选择英雄(事件玩家, 数组(英雄(卡西迪), 英雄(布丽吉塔), 英雄(巴蒂斯特), 英雄(黑百合), 英雄(回声), 英雄(黑影), 英雄(法老之鹰), 英雄(奥丽莎), 英雄(路霸), 英雄(美), 英雄(西格玛), 英雄(半藏), 英雄(
						源氏), 英雄(莱因哈特), 英雄(堡垒))[全局.Wave - 1]);
					全局.IV_Portal_Status = 1;
					全局.HVT_Times_Subdued = 0;
					事件玩家.Perk_Pumping_Iron = 0;
					大字体信息(所有玩家(所有队伍), 自定义字符串("发现高价值目标！"));
				End;
			Else If(全局.Boss_Spawns_remaining > 0);
				全局.Boss_Spawns_remaining -= 1;
				If(全局.IV_HVT_Boss_Spawns_blocked_until >= 总计消耗时间 || 全局.Wave < 5);
					开始强制玩家选择英雄(事件玩家, 数组随机取值(已过滤的数组(数组(英雄(路霸), 全局.Wave >= 2 ? 英雄(奥丽莎) : 假, 全局.Wave >= 3 ? 英雄(猎空) : 假, 全局.Wave >= 4 ? 英雄(西格玛) : 假,
						全局.Wave >= 7 ? 英雄(死神) : 假, 全局.Wave >= 9 ? 英雄(破坏球) : 假, !正在使用英雄(英雄(美), 队伍1) && 全局.Wave >= 11 ? 英雄(美) : 假), 当前数组元素)));
				Else;
					全局.IV_HVT_Boss_Spawns_blocked_until = 总计消耗时间 + 10;
					开始强制玩家选择英雄(事件玩家, 首个(已排序的数组(已过滤的数组(数组(英雄(半藏), 全局.Wave >= 6 ? 英雄(源氏) : 假, 全局.Wave >= 10 ? 英雄(莱因哈特) : 假, 全局.Wave >= 11 ? 英雄(堡垒) : 假),
						当前数组元素), 随机实数(0, 0.500) + 数量(选择英雄的玩家(当前数组元素, 队伍1)))));
				End;
			Else;
				全局.Temp = 全局.Mut_Promotion && 随机整数(1, 100) <= 20 && 事件玩家.Level < 3;
				If(全局.Mut_The_Cavalry && 栏位(事件玩家) == 0 && 所用英雄(事件玩家) != 英雄(猎空));
					开始强制玩家选择英雄(事件玩家, 英雄(猎空));
				Else If(事件玩家.Level + 全局.Temp == 1);
					开始强制玩家选择英雄(事件玩家, 数组随机取值(已过滤的数组(数组(英雄(卡西迪), 英雄(士兵：76), 全局.Wave >= 3 ? 英雄(布丽吉塔) : 假), 当前数组元素)));
				Else If(事件玩家.Level + 全局.Temp == 2);
					开始强制玩家选择英雄(事件玩家, 数组随机取值(已过滤的数组(数组(英雄(黑百合), 数量(选择英雄的玩家(英雄(回声), 队伍1)) < 2 ? 英雄(回声) : 假, 全局.Wave >= 5 ? 英雄(巴蒂斯特) : 假,
						全局.Wave >= 7 && !正在使用英雄(英雄(黑影), 队伍1) ? 英雄(黑影) : 假, 全局.Wave >= 11 && !正在使用英雄(英雄(死神), 队伍1) ? 英雄(死神) : 假, 英雄(秩序之光),
						全局.Mut_Meteor_Shower ? 英雄(末日铁拳) : 假, 全局.Wave >= 7 ? 英雄(法老之鹰) : 假), 当前数组元素)));
				Else If(事件玩家.Level + 全局.Temp == 3);
					开始强制玩家选择英雄(事件玩家, 数组随机取值(已过滤的数组(数组(英雄(路霸), 全局.Wave >= 6 && 数量(选择英雄的玩家(英雄(奥丽莎), 队伍1)) < 2 ? 英雄(奥丽莎) : 假, 全局.Wave >= 8 ? 英雄(猎空) : 假,
						全局.Wave >= 9 && !正在使用英雄(英雄(西格玛), 队伍1) ? 英雄(西格玛) : 假, !正在使用英雄(英雄(美), 队伍1) && 全局.Wave >= 12 ? 英雄(美) : 假, 全局.Wave >= 8 ? 英雄(破坏球)
						: 假), 当前数组元素)));
				End;
			End;
		End;
		"Selected Hero is the same as current Hero"
		If(死亡(事件玩家));
			复活(事件玩家);
			设置弹药(事件玩家, 0, 最大弹药量(事件玩家, 0));
		End;
		If(全局.Gamemode == 0);
			设置最大生命值(事件玩家, (全局.Mutators_activated ? 1.100 : 1) * (80 + 3 * (全局.Wave + 2 * 较大(0, 全局.Wave - 13))) * (
				0.200 + 0.200 * 全局.Combatants_Count));
		Else;
			设置最大生命值(事件玩家, (全局.Mutators_activated ? 1.100 : 1) * (75 + 5 * (全局.Wave + 2 * 较大(0, 全局.Wave - 10))) * (
				0.200 + 0.200 * 全局.Combatants_Count));
		End;
		开始持续治疗(事件玩家, 无, 1, 10000);
		停止按下按钮(事件玩家, 按钮(主要攻击模式));
		停止按下按钮(事件玩家, 按钮(辅助攻击模式));
		清除状态(事件玩家, 无法杀死);
		设置状态(事件玩家, 无, 定身, 1);
		调用子程序(Find_Chase_Target);
		If(栏位(事件玩家) == 6);
			设置移动速度(事件玩家, 全局.Mut_Amped ? 115 : 100);
			事件玩家.Has_Spawn_Speed_Bonus = 假;
		Else;
			设置移动速度(事件玩家, (全局.Mut_Reinforcements ? 50 : 0) + 较小(全局.Max_Speed_Bonus, 100 + 较大(5 * 全局.Wave, 2 * 相距距离(事件玩家, 事件玩家.Target))));
			事件玩家.Has_Spawn_Speed_Bonus = 真;
		End;
		事件玩家.Last_Knockback_received = 0;
		事件玩家.Ab_Var_1 = 假;
		事件玩家.Feared_until = 0;
		事件玩家.Is_Ranged_Hero = 所用英雄(事件玩家) == 英雄(卡西迪) || 所用英雄(事件玩家) == 英雄(士兵：76) || 所用英雄(事件玩家) == 英雄(巴蒂斯特) || 所用英雄(事件玩家) == 英雄(黑百合) || 所用英雄(
			事件玩家) == 英雄(回声) || 所用英雄(事件玩家) == 英雄(奥丽莎) || 所用英雄(事件玩家) == 英雄(西格玛) || 所用英雄(事件玩家) == 英雄(半藏);
		事件玩家.Allow_Flinch = 所用英雄(事件玩家) != 英雄(布丽吉塔) && 所用英雄(事件玩家) != 英雄(黑影) && 所用英雄(事件玩家) != 英雄(奥丽莎) && 所用英雄(事件玩家) != 英雄(猎空) && 所用英雄(事件玩家)
			!= 英雄(源氏) && 所用英雄(事件玩家) != 英雄(堡垒) && 所用英雄(事件玩家) != 英雄(托比昂);
		事件玩家.Can_Quick_Melee = 所用英雄(事件玩家) != 英雄(布丽吉塔) && 所用英雄(事件玩家) != 英雄(莱因哈特) && 所用英雄(事件玩家) != 英雄(托比昂);
		事件玩家.Is_Living_Boss = 所用英雄(事件玩家) == 英雄(源氏) || 所用英雄(事件玩家) == 英雄(半藏) || 所用英雄(事件玩家) == 英雄(堡垒) || 所用英雄(事件玩家) == 英雄(莱因哈特);
		设置受到的击退(事件玩家, 全局.GMut_Fortified || 事件玩家.Is_Living_Boss ? 25 : 100);
		If(栏位(事件玩家) == 6);
			If(所用英雄(事件玩家) == 英雄(托比昂));
				设置受到伤害(事件玩家, 100);
				设置受到治疗(事件玩家, 0);
			Else;
				设置受到伤害(事件玩家, 事件玩家.Is_Living_Boss ? 75 : (所用英雄(事件玩家) == 英雄(奥丽莎) || 所用英雄(事件玩家) == 英雄(西格玛) ? 25 : 15));
				设置受到治疗(事件玩家, 事件玩家.Is_Living_Boss ? 75 : (所用英雄(事件玩家) == 英雄(奥丽莎) || 所用英雄(事件玩家) == 英雄(西格玛) ? 25 : 15));
			End;
		Else;
			If(全局.Mut_Mutation && 全局.Mut_Mutation < 总计消耗时间 && 随机整数(1, 100) <= 15 && !事件玩家.Is_Living_Boss && !对任意为”真“(所有玩家(队伍1),
				当前数组元素.Is_mutated));
				开始调整玩家大小(事件玩家, 1.300, 假);
				开始修改英雄语音(事件玩家, 0.700, 假);
				事件玩家.Is_mutated = 真;
				设置受到伤害(事件玩家, 40);
				设置受到治疗(事件玩家, 40);
			Else;
				设置受到伤害(事件玩家, 全局.Gamemode && 事件玩家.Is_Living_Boss ? 130 : 100);
				设置受到治疗(事件玩家, 全局.Gamemode && 事件玩家.Is_Living_Boss ? 130 : 100);
			End;
		End;
		If(全局.GMut_Storm_Raging);
			事件玩家.GMut_Var = 栏位(事件玩家) != 6 && !事件玩家.Is_Living_Boss && 随机整数(1, 100) > 50 * 数量(已过滤的数组(所有存活玩家(队伍1), 当前数组元素.GMut_Var));
		End;
		等待(0.100, 无视条件);
		If(全局.Gamemode == 0 && 事件玩家.Is_Living_Boss);
			开始强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍), 真, 颜色(灰绿色), 默认);
		Else If(栏位(事件玩家) == 6);
			If(全局.Gamemode == 1);
				开始强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍), 真, 颜色(绿色), 默认);
			Else If(全局.Gamemode == 2);
				开始强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍), 真, 颜色(绿色), 总是);
			End;
		End;
		如条件为”真“则循环;
	}
}

规则("Team 1: Remove Spawn Speed Bonus")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.Has_Spawn_Speed_Bonus == 真;
		(事件玩家.Is_Target_in_LOS || !事件玩家.Target.Is_Combatant || 事件玩家.Feared_until >= 总计消耗时间 || 全局.Is_Infrasight_on_Players1) == 真;
	}

	动作
	{
		事件玩家.Has_Spawn_Speed_Bonus = 假;
		设置移动速度(事件玩家, 全局.Mut_Amped ? 115 : 100);
	}
}

规则("Team 1: Enable Combat Pathfinding")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.Is_using_Combat_Pathfinding == 假;
		事件玩家.Is_Target_in_LOS == 真;
		事件玩家.Is_assaulting == 真;
		在地面上(事件玩家) == 真;
		(Y方向分量(所选位置(事件玩家.Target)) - Y方向分量(所选位置(事件玩家)) <= 2 || Y方向分量(全局.Nodes[事件玩家.Target.Nav_Index]) - Y方向分量(所选位置(事件玩家)) <= 1) == 真;
		(事件玩家.Is_Ranged_Hero || 相距距离(事件玩家, 事件玩家.Target) <= 1 + 相距距离(事件玩家.Target, 全局.Nodes[事件玩家.Target.Nav_Index])) == 真;
		在视线内(眼睛位置(事件玩家), 眼睛位置(事件玩家.Target) + 全局.Aim_Offset, 屏障不会阻挡视线) == 真;
	}

	动作
	{
		If(对任意为”真“(全局.Elevator_Nodes, 相距距离(矢量(1, 0, 1) * 事件玩家, 矢量(1, 0, 1) * 当前数组元素) < 1.500));
			等待(1, 无视条件);
			如条件为“假”则中止;
		End;
		事件玩家.Is_using_Combat_Pathfinding = 真;
		事件玩家.Target_Last_Pos_seen = 所选位置(事件玩家.Target);
		事件玩家.Nav_is_reachable_Node = 假;
	}
}

规则("Team 1: Disable Combat Pathfinding")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.Is_using_Combat_Pathfinding == 真;
		(事件玩家.Is_assaulting && 事件玩家.Is_Target_in_LOS) == 假;
	}

	动作
	{
		事件玩家.Is_using_Combat_Pathfinding = 假;
	}
}

规则("Team 1: Set Nav (Not in Combat), Get Back to Node, Set Nav is Node")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
		事件玩家.Is_using_Combat_Pathfinding == 假;
		事件玩家.Nav_is_reachable_Node == 假;
		所用英雄(事件玩家) != 英雄(托比昂);
	}

	动作
	{
		If(!事件玩家.Has_Spawn_Speed_Bonus && (所用英雄(事件玩家) == 英雄(卡西迪) || 所用英雄(事件玩家) == 英雄(士兵：76) || 所用英雄(事件玩家) == 英雄(巴蒂斯特)));
			设置移动速度(事件玩家, 全局.Mut_Amped ? 115 : 100);
		End;
		事件玩家.Nav = 首个(已排序的数组(已过滤的数组(全局.Nodes, 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线)), 相距距离(事件玩家, 当前数组元素)));
		If(事件玩家.Nav == 0);
			事件玩家.Nav = 首个(已排序的数组(全局.Nodes, 相距距离(事件玩家, 当前数组元素)));
		End;
		事件玩家.Nav_Index = 数组值的索引(全局.Nodes, 事件玩家.Nav);
		事件玩家.Nav_is_reachable_Node = 真;
		等待(0.500, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1: Set Nav (Not in Combat), Select Next Node, Set Last Time at Node")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
		事件玩家.Is_using_Combat_Pathfinding == 假;
		事件玩家.Nav_is_reachable_Node == 真;
		相距距离(事件玩家, 事件玩家.Nav) <= 1;
	}

	动作
	{
		事件玩家.Last_Time_at_Node = 总计消耗时间;
		If(事件玩家.Target.Is_Combatant);
			If(事件玩家.Target.Last_Nav_Update + 全局.Combatants_Count * 0.400 < 总计消耗时间);
				事件玩家.Target.Last_Nav_Update = 总计消耗时间;
				事件玩家.Target.Nav_Index = 数组值的索引(全局.Nodes, 首个(已排序的数组(已过滤的数组(从数组中移除(全局.Nodes, 全局.Elevator_Nodes), 在视线内(当前数组元素 + 矢量(0, 1.500, 0), 眼睛位置(
					事件玩家.Target) + 全局.Aim_Offset, 屏障不会阻挡视线)), 相距距离(事件玩家.Target, 当前数组元素) + 绝对值(Y方向分量(所选位置(事件玩家.Target)) - Y方向分量(当前数组元素)))));
				If(事件玩家.Target.Nav_Index == -1);
					事件玩家.Target.Nav_Index = 数组值的索引(全局.Nodes, 首个(已排序的数组(从数组中移除(全局.Nodes, 全局.Elevator_Nodes), 相距距离(事件玩家.Target, 当前数组元素))));
				End;
			End;
			If(事件玩家.Nav_Index == 事件玩家.Target.Nav_Index && 事件玩家.Is_assaulting && 事件玩家.Feared_until < 总计消耗时间);
				事件玩家.Is_Target_in_LOS = 5;
				事件玩家.Is_using_Combat_Pathfinding = 真;
				事件玩家.Target_Last_Pos_seen = 所选位置(事件玩家.Target);
				事件玩家.Nav_is_reachable_Node = 假;
			Else;
				事件玩家.Nav_Index = 首个(已排序的数组(全局.Edges[事件玩家.Nav_Index], (事件玩家.Is_assaulting && 事件玩家.Feared_until < 总计消耗时间 ? 1 : -1) * (随机实数(0, 0.500)
					+ 数组值的索引(全局.Char_Array, 截取字符串(全局.Distance_Matrix[取整((当前数组元素 * 全局.Nodes_Count + 事件玩家.Target.Nav_Index) / 128, 下)], (
					当前数组元素 * 全局.Nodes_Count + 事件玩家.Target.Nav_Index) % 128, 1)))));
				事件玩家.Nav = 全局.Nodes[事件玩家.Nav_Index];
			End;
		Else;
			事件玩家.Nav_Index = 数组随机取值(全局.Edges[事件玩家.Nav_Index]);
			事件玩家.Nav = 全局.Nodes[事件玩家.Nav_Index];
		End;
	}
}

规则("Team 1: Set Nav (in Combat)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) != 英雄(托比昂);
		"Not while Echo is landing"
		(所用英雄(事件玩家) == 英雄(回声) && 事件玩家.Ab_Var_1) == 假;
		事件玩家.Is_using_Combat_Pathfinding == 真;
	}

	动作
	{
		If(在视线内(眼睛位置(事件玩家), 眼睛位置(事件玩家.Target) + 全局.Aim_Offset, 屏障不会阻挡视线));
			事件玩家.Target_Last_Pos_seen = 所选位置(事件玩家.Target);
			If(事件玩家.Is_flying);
				事件玩家.Nav = 射线命中位置(眼睛位置(事件玩家.Target), 眼睛位置(事件玩家.Target) + 12 * 与此角度的相对方向(水平朝向角度(事件玩家.Target) + (随机整数(0, 1) ? -45 : 45), -60), 无, 无,
					假);
				等待(0.500, 无视条件);
			Else If(事件玩家.Target.Is_flying && 所用英雄(事件玩家) != 英雄(黑百合));
				调用子程序(Roam);
			Else;
				If(所用英雄(事件玩家) == 英雄(卡西迪) || 所用英雄(事件玩家) == 英雄(士兵：76) || 所用英雄(事件玩家) == 英雄(巴蒂斯特) || 所用英雄(事件玩家) == 英雄(法老之鹰));
					If(相距距离(事件玩家, 事件玩家.Target) <= (所用英雄(事件玩家) == 英雄(巴蒂斯特) ? 20 : 15));
						事件玩家.Nav = 所选位置(事件玩家) + 2.500 * 与此角度的相对方向(随机整数(-179, 180), 0);
					Else;
						事件玩家.Nav = 所选位置(事件玩家) + 2.500 * 与此角度的相对方向(与此方向的水平角度(方向(事件玩家, 事件玩家.Target)) + 数组随机取值(数组(-45, 0, 45)), 0);
					End;
					调用子程序(Find_NWP_near_Nav);
				Else If(所用英雄(事件玩家) == 英雄(布丽吉塔) || 所用英雄(事件玩家) == 英雄(莱因哈特) || 所用英雄(事件玩家) == 英雄(秩序之光));
					事件玩家.Nav = 所选位置(事件玩家.Target) + 2 * 方向(事件玩家.Target, 事件玩家);
					调用子程序(Find_NWP_near_Nav);
				Else If(所用英雄(事件玩家) == 英雄(奥丽莎));
					事件玩家.Nav = 所选位置(事件玩家) + 较小(1.500, 相距距离(事件玩家, 事件玩家.Target) - 2) * 方向(事件玩家, 事件玩家.Target);
					调用子程序(Find_NWP_near_Nav);
				Else If(所用英雄(事件玩家) == 英雄(黑影) || 所用英雄(事件玩家) == 英雄(堡垒));
					事件玩家.Nav = 所选位置(事件玩家.Target) + 5 * 与此角度的相对方向(水平朝向角度(事件玩家.Target) + 数组随机取值(数组(-45, 45)), 0);
					调用子程序(Find_NWP_near_Nav);
				Else If(所用英雄(事件玩家) == 英雄(黑百合));
					If(相距距离(事件玩家, 事件玩家.Target) <= 12);
						事件玩家.Nav = 所选位置(事件玩家) + 3.500 * 与此角度的相对方向(与此方向的水平角度(方向(事件玩家.Target, 事件玩家)), 0);
						调用子程序(Find_NWP_near_Nav);
					Else;
						事件玩家.Nav = 所选位置(事件玩家);
					End;
				Else If(所用英雄(事件玩家) == 英雄(路霸) || 所用英雄(事件玩家) == 英雄(死神));
					事件玩家.Nav = 所选位置(事件玩家.Target) + 3 * 与此角度的相对方向(水平朝向角度(事件玩家.Target), 0);
					调用子程序(Find_NWP_near_Nav);
				Else If(所用英雄(事件玩家) == 英雄(猎空) || 所用英雄(事件玩家) == 英雄(源氏) || 所用英雄(事件玩家) == 英雄(破坏球));
					事件玩家.Nav = 所选位置(事件玩家.Target) + 1.500 * 与此角度的相对方向(水平朝向角度(事件玩家.Target) + (水平方向夹角(事件玩家.Target, 事件玩家) > 0 ? 90 : -90), 0);
					调用子程序(Find_NWP_near_Nav);
				Else If(所用英雄(事件玩家) == 英雄(回声) || 所用英雄(事件玩家) == 英雄(西格玛) || 所用英雄(事件玩家) == 英雄(半藏) || 所用英雄(事件玩家) == 英雄(美));
					If(相距距离(事件玩家, 事件玩家.Target) <= 17);
						事件玩家.Nav = 所选位置(事件玩家) + 3.500 * 与此角度的相对方向(随机整数(-179, 180), 0);
					Else;
						事件玩家.Nav = 所选位置(事件玩家) + 3.500 * 与此角度的相对方向(与此方向的水平角度(方向(事件玩家, 事件玩家.Target)) + 数组随机取值(数组(-45, 0, 45)), 0);
					End;
					调用子程序(Find_NWP_near_Nav);
				End;
			End;
			If(所用英雄(事件玩家) == 英雄(卡西迪) || 所用英雄(事件玩家) == 英雄(士兵：76) || 所用英雄(事件玩家) == 英雄(巴蒂斯特));
				设置移动速度(事件玩家, 全局.Mut_Amped ? 80.500 : 70);
			End;
		"Go to the last position where the target was seen"
		Else;
			If(相距距离(事件玩家, 矢量(X方向分量(事件玩家.Target_Last_Pos_seen), Y方向分量(所选位置(事件玩家)), Z方向分量(事件玩家.Target_Last_Pos_seen))) < 0.500);
				事件玩家.Target_Last_Pos_seen = 所选位置(事件玩家.Target);
			End;
			事件玩家.Nav = 所选位置(事件玩家) + 较小(3.500, 相距距离(事件玩家, 事件玩家.Target_Last_Pos_seen)) * 方向(事件玩家, 事件玩家.Target_Last_Pos_seen);
			调用子程序(Find_NWP_near_Nav);
			If(所用英雄(事件玩家) == 英雄(卡西迪) || 所用英雄(事件玩家) == 英雄(士兵：76) || 所用英雄(事件玩家) == 英雄(巴蒂斯特));
				设置移动速度(事件玩家, 全局.Mut_Amped ? 115 : 100);
			End;
		End;
		等待(0.500, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1: Find Target")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
		事件玩家.Feared_until < 总计消耗时间;
		所用英雄(事件玩家) != 英雄(托比昂);
		事件玩家.Is_Wraith == 假;
	}

	动作
	{
		全局.Temp = 首个(已排序的数组(已过滤的数组(全局.Combatants, !当前数组元素.Downed_since && 当前数组元素.Is_invisible <= (相距距离(事件玩家, 当前数组元素)
			<= 2.400 || 全局.Is_Infrasight_on_Bots1) && 在视线内(眼睛位置(事件玩家), 眼睛位置(当前数组元素) + 全局.Aim_Offset, 屏障不会阻挡视线)), 数组(1, 0.250, 2, 4)
			[当前数组元素.Ab_Priority] * (当前数组元素 == 事件玩家.Target ? 0.250 : 1) * 相距距离(事件玩家, 当前数组元素) + (
			!事件玩家.Is_Ranged_Hero && 当前数组元素.Is_flying ? 1000 : 0) + (具有状态(当前数组元素, 无敌) || 具有状态(当前数组元素, 相移) ? 2000 : 0)));
		If(全局.Temp == 0);
			If(事件玩家.Target.Downed_since || !事件玩家.Target.Is_Combatant || 事件玩家.Target.Is_invisible > (相距距离(事件玩家, 事件玩家.Target)
				<= 2.400 || 全局.Is_Infrasight_on_Bots1));
				调用子程序(Find_Chase_Target);
				事件玩家.Is_Target_in_LOS = 0;
			Else If(事件玩家.Is_Target_in_LOS);
				If(!事件玩家.Is_flying && Y方向分量(所选位置(事件玩家.Target)) - Y方向分量(所选位置(事件玩家)) > 2);
					事件玩家.Is_using_Combat_Pathfinding = 假;
				End;
				事件玩家.Is_Target_in_LOS -= 1;
			End;
			If(!事件玩家.Is_Target_in_LOS && 弹药(事件玩家, 0) < 0.500 * 最大弹药量(事件玩家, 0));
				按下按键(事件玩家, 按钮(装填));
			End;
		Else;
			事件玩家.Is_Target_in_LOS = 5;
			事件玩家.Target = 全局.Temp;
			事件玩家.Target_Last_Pos_seen = 所选位置(事件玩家.Target);
		End;
		等待(事件玩家.Has_Spawn_Speed_Bonus ? 0.250 : 0.500, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1: Improve Air Movement")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
		正在空中(事件玩家) == 真;
		事件玩家.Is_using_Combat_Pathfinding == 假;
		事件玩家.Last_Knockback_received + 3 < 总计消耗时间;
		水平速度(事件玩家) >= 5;
		相距距离(事件玩家, 矢量(X方向分量(事件玩家.Nav), Y方向分量(所选位置(事件玩家)), Z方向分量(事件玩家.Nav))) <= 2;
		绝对值(角度差(与此方向的水平角度(向量(事件玩家, 事件玩家.Nav)), 与此方向的水平角度(速率(事件玩家)))) >= 90;
	}

	动作
	{
		施加推力(事件玩家, -1 * 与此角度的相对方向(与此方向的水平角度(速率(事件玩家)), 0), 0.001, 至地图, 取消相反运动XYZ);
	}
}

规则("Team 1: Calculate Primary Speed")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
	}

	动作
	{
		事件玩家.Pos_1 = 所选位置(事件玩家);
		If(正在跳跃(事件玩家));
			事件玩家.Last_Jump = 总计消耗时间;
		End;
		If(事件玩家.Last_Jump + 0.150 >= 总计消耗时间);
			事件玩家.Primary_Speed = 相距距离(矢量(X方向分量(事件玩家.Pos_1), Y方向分量(事件玩家.Pos_2), Z方向分量(事件玩家.Pos_1)), 事件玩家.Pos_2) / 0.112;
		Else;
			事件玩家.Primary_Speed = 相距距离(事件玩家.Pos_1, 事件玩家.Pos_2) / 0.112;
		End;
		等待(0.112, 当为“假”时中止);
		事件玩家.Pos_2 = 所选位置(事件玩家);
		If(正在跳跃(事件玩家));
			事件玩家.Last_Jump = 总计消耗时间;
		End;
		If(事件玩家.Last_Jump + 0.150 >= 总计消耗时间);
			事件玩家.Primary_Speed = 相距距离(矢量(X方向分量(事件玩家.Pos_1), Y方向分量(事件玩家.Pos_2), Z方向分量(事件玩家.Pos_1)), 事件玩家.Pos_2) / 0.112;
		Else;
			事件玩家.Primary_Speed = 相距距离(事件玩家.Pos_1, 事件玩家.Pos_2) / 0.112;
		End;
		等待(0.112, 当为“假”时中止);
		如条件为”真“则循环;
	}
}

规则("Team 1: Bot is stuck")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
		事件玩家.Primary_Speed <= 1.500;
		具有状态(事件玩家, 定身) == 假;
		具有状态(事件玩家, 击晕) == 假;
		所用英雄(事件玩家) != 英雄(托比昂);
		(所用英雄(事件玩家) == 英雄(莱因哈特) && 正在使用终极技能(事件玩家)) == 假;
		相距距离(事件玩家, 矢量(X方向分量(事件玩家.Nav), Y方向分量(事件玩家.Is_using_Combat_Pathfinding ? 所选位置(事件玩家) : 事件玩家.Nav), Z方向分量(事件玩家.Nav))) >= 0.500;
	}

	动作
	{
		等待(0.500, 当为“假”时中止);
		If(对任意为”真“(全局.Elevator_Nodes, 相距距离(矢量(1, 0, 1) * 事件玩家, 矢量(1, 0, 1) * 当前数组元素) < 1.500));
			等待(1.500, 当为“假”时中止);
		End;
		If(事件玩家.Is_using_Combat_Pathfinding);
			If(绝对值(与此方向的水平角度(阈值(事件玩家))) <= 45);
				按下按键(事件玩家, 按钮(跳跃));
			End;
		Else;
			按下按键(事件玩家, 按钮(跳跃));
			If(!(事件玩家.Is_Target_in_LOS || 事件玩家.Feared_until >= 总计消耗时间));
				取消与玩家的移动碰撞(事件玩家);
				等待(0.500, 无视条件);
				开启与玩家的移动碰撞(事件玩家);
			End;
			等待(0.500, 当为“假”时中止);
			事件玩家.Nav_is_reachable_Node = 假;
		End;
		等待(0.500, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1: Teleport if Target not in LOS and hasn't reached Node for 8 seconds")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
		具有状态(事件玩家, 定身) == 假;
		具有状态(事件玩家, 击晕) == 假;
		事件玩家.Is_Wraith == 假;
		事件玩家.Feared_until < 总计消耗时间;
		事件玩家.Is_Target_in_LOS == 假;
		事件玩家.Last_Time_at_Node < 总计消耗时间;
		所用英雄(事件玩家) != 英雄(托比昂);
	}

	动作
	{
		等待(8, 当为“假”时中止);
		调用子程序(Teleport_to_free_Spawn);
		等待(8, 当为“假”时中止);
		传送(事件玩家, 1000 * 下);
	}
}

规则("Team 1: Bot took damage")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.Allow_Flinch == 真;
		事件玩家.Is_using_Combat_Pathfinding == 真;
	}

	动作
	{
		If(所用英雄(事件玩家) == 英雄(黑百合) || 所用英雄(事件玩家) == 英雄(西格玛));
			事件玩家.Nav = 所选位置(事件玩家) - 3.500 * 与此角度的相对方向(与此方向的水平角度(向量(事件玩家, 事件玩家.Target)) + 随机整数(-90, 90), 0);
		Else;
			事件玩家.Nav = 所选位置(事件玩家) + 3.500 * 与此角度的相对方向(与此方向的水平角度(向量(事件玩家, 事件玩家.Target)) + 随机整数(-90, 90), 0);
		End;
		调用子程序(Find_NWP_near_Nav);
		等待(0.500, 无视条件);
	}
}

规则("Team 1: Bot received Knockback")
{
	事件
	{
		玩家受到击退;
		队伍1;
		全部;
	}

	条件
	{
		所在队伍(攻击方) == 队伍2;
	}

	动作
	{
		事件玩家.Last_Knockback_received = 总计消耗时间;
	}
}

规则("Team 1: Is Hacked, Apply Fear")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		具有状态(事件玩家, 被入侵) == 真;
		事件玩家.Feared_until - 0.250 < 总计消耗时间;
		所用英雄(事件玩家) != 英雄(托比昂);
	}

	动作
	{
		事件玩家.Feared_until = 总计消耗时间 + 0.250;
		等待(0.200, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1: Quick Melee")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.Can_Quick_Melee == 真;
		事件玩家.Is_Target_in_LOS == 真;
		正在装填(事件玩家) == 假;
		具有状态(事件玩家, 击晕) == 假;
		相距距离(事件玩家, 事件玩家.Target) <= 2.500;
	}

	动作
	{
		If(随机整数(1, 100) <= 20);
			按下按键(事件玩家, 按钮(近身攻击));
			等待(5, 无视条件);
		Else;
			等待(1, 无视条件);
		End;
		如条件为”真“则循环;
	}
}

规则("Team 1: Call Incoming")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.Called_Incoming == 假;
		事件玩家.Is_Target_in_LOS == 真;
	}

	动作
	{
		全局.Called_Incoming = 真;
		等待(0.400, 无视条件);
		交流(事件玩家.Target, 敌人来袭);
	}
}

规则("Team 1: Bot is feared")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.Feared_until >= 总计消耗时间;
		存活(事件玩家) == 真;
	}

	动作
	{
		事件玩家.Is_Target_in_LOS = 0;
		取消主要动作(事件玩家);
		If(栏位(事件玩家) == 6 && 全局.Gamemode == 2);
			开始强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍), 真, 颜色(亮紫色), 总是);
		Else;
			开始强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍), 真, 颜色(亮紫色), 默认);
		End;
		等待直到 (!(事件玩家.Feared_until >= 总计消耗时间 && 存活(事件玩家)), 99999);
		If(全局.Gamemode == 0 && 事件玩家.Is_Living_Boss);
			开始强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍), 真, 颜色(灰绿色), 默认);
		Else If(栏位(事件玩家) == 6);
			If(全局.Gamemode == 1);
				开始强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍), 真, 颜色(灰绿色), 默认);
			Else If(全局.Gamemode == 2);
				开始强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍), 真, 颜色(灰绿色), 总是);
			End;
		Else;
			停止强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍));
		End;
	}
}

规则("MUT Team 1 (Gamechanging Mutator): Close Quarters")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.GMut_Close_Quarters == 真;
		存活(事件玩家) == 真;
		所用英雄(事件玩家) != 英雄(托比昂);
	}

	动作
	{
		If(对任意为”真“(范围内玩家(事件玩家, 5, 队伍2, 关闭), 当前数组元素.Is_Combatant));
			事件玩家.GMut_Var = 假;
		Else;
			If(所用英雄(事件玩家) != 英雄(堡垒) || 正在使用终极技能(事件玩家));
				设置状态(事件玩家, 无, 无法杀死, 0.250);
			End;
			事件玩家.GMut_Var = 真;
		End;
		等待(0.250, 无视条件);
		如条件为”真“则循环;
		事件玩家.GMut_Var = 假;
	}
}

规则("MUT Team 1 (Gamechanging Mutator): Fortified")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.GMut_Fortified == 真;
		具有状态(事件玩家, 击晕) == 真;
		事件玩家.Perk_Pumping_Iron < 总计消耗时间;
	}

	动作
	{
		If(具有状态(事件玩家, 冰冻));
			清除状态(事件玩家, 冰冻);
		Else;
			If(具有状态(事件玩家, 击倒) || 具有状态(事件玩家, 沉睡));
				设置状态(事件玩家, 无, 击晕, 3);
				等待直到 (!(具有状态(事件玩家, 击倒) || 具有状态(事件玩家, 沉睡)), 0.050);
			End;
			清除状态(事件玩家, 击晕);
		End;
		等待(0.250, 当为“假”时中止);
		如条件为”真“则循环;
	}
}

规则("MUT Team 1 (Gamechanging Mutator): Keep your Distance")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.GMut_Keep_your_Distance == 真;
		存活(事件玩家) == 真;
		所用英雄(事件玩家) != 英雄(托比昂);
	}

	动作
	{
		事件玩家.GMut_Var = 范围内玩家(事件玩家, 8, 队伍2, 关闭);
		等待(0.250, 无视条件);
		如条件为”真“则循环;
		事件玩家.GMut_Var = 空数组;
	}
}

规则("MUT Team 1 (Gamechanging Mutator): Storm Raging, Set / Clear Burning")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.GMut_Storm_Raging == 真;
		事件玩家.GMut_Var == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(红色), 事件玩家, 1);
		设置状态(事件玩家, 无, 点燃, 9999);
		等待直到 (!事件玩家.GMut_Var, 99999);
		清除状态(事件玩家, 点燃);
	}
}

规则("MUT Global (Mutator): Regeneration")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.Mut_Regeneration == 真;
	}

	动作
	{
		治疗(所有存活玩家(队伍1), 无, 5 * (0.200 + 0.200 * 全局.Combatants_Count));
		等待(0.500, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 (Ability): Heavy Impact")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		全部;
	}

	条件
	{
		攻击方.Ab_Heavy_Impact == 真;
		所用英雄(事件玩家) != 英雄(托比昂);
	}

	动作
	{
		根据条件中止(随机实数(-0.020, 1) > 事件伤害 / 最大生命值(事件玩家));
		事件玩家.Perk_Pumping_Iron = 较大(总计消耗时间 + (全局.GMut_Fortified || 事件玩家.Is_Living_Boss ? 0.500 : 1) * 攻击方.Ab_Heavy_Impact,
			事件玩家.Perk_Pumping_Iron);
		设置状态(事件玩家, 攻击方, 击晕, (全局.GMut_Fortified || 事件玩家.Is_Living_Boss ? 0.500 : 1) * 攻击方.Ab_Heavy_Impact);
		等待(5, 无视条件);
	}
}

规则("Team 1 (Ability): Priority B")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		全部;
	}

	条件
	{
		攻击方.Ab_Priority == 2;
		(事件玩家.Is_Target_in_LOS && 事件玩家.Target == 攻击方) == 假;
		所用英雄(事件玩家) != 英雄(托比昂);
	}

	动作
	{
		根据条件中止(随机实数(-0.020, 1) > 事件伤害 / 最大生命值(事件玩家));
		事件玩家.Feared_until = 总计消耗时间 + (事件玩家.Is_Living_Boss ? 2.500 : 5);
		等待(10, 无视条件);
	}
}

规则("Team 1 Brigitte: Hold / Drop Shield if Target and Distance to Target >= 6m")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		布丽吉塔;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		相距距离(事件玩家, 事件玩家.Target) >= 6;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(辅助攻击模式));
		等待直到 (!(事件玩家.Is_Target_in_LOS && 相距距离(事件玩家, 事件玩家.Target) >= 6), 99999);
		停止按下按钮(事件玩家, 按钮(辅助攻击模式));
	}
}

规则("Team 1 Brigitte: Start / Stop Attacking if Distance to Target < 6m")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		布丽吉塔;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		相距距离(事件玩家, 事件玩家.Target) < 6;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(主要攻击模式));
		等待直到 (!(事件玩家.Is_Target_in_LOS && 相距距离(事件玩家, 事件玩家.Target) < 6), 99999);
		停止按下按钮(事件玩家, 按钮(主要攻击模式));
	}
}

规则("Team 1 Brigitte: Increase / Normalize Move Speed while holding Shield")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		布丽吉塔;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		事件玩家.Has_Spawn_Speed_Bonus == 假;
	}

	动作
	{
		设置移动速度(事件玩家, 全局.Mut_Amped ? 164.286 : 142.857);
		等待直到 (!正在使用辅助武器(事件玩家), 99999);
		设置移动速度(事件玩家, 全局.Mut_Amped ? 115 : 100);
	}
}

规则("Team 1 Brigitte: Whip Shot")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		布丽吉塔;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > (事件玩家.Target.Is_flying ? 100 : 50));
		根据条件循环(相距距离(事件玩家, 事件玩家.Target) <= 6 || 相距距离(事件玩家, 事件玩家.Target) >= 20);
		按下按键(事件玩家, 按钮(技能1));
		等待(3, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 McCree: Shoot")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		卡西迪;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
		绝对值(水平方向夹角(事件玩家, 事件玩家.Target)) <= 5;
	}

	动作
	{
		If(相距距离(事件玩家, 事件玩家.Target) > 5);
			开始按下按钮(事件玩家, 按钮(主要攻击模式));
			等待(随机实数(0.400, 0.600), 无视条件);
			停止按下按钮(事件玩家, 按钮(主要攻击模式));
		Else;
			按下按键(事件玩家, 按钮(辅助攻击模式));
		End;
		等待(随机实数(0.800, 1.200), 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 McCree: Combat Roll")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		卡西迪;
	}

	条件
	{
		事件玩家.Is_using_Combat_Pathfinding == 真;
	}

	动作
	{
		根据条件中止(随机整数(1, 100) > 30);
		按下按键(事件玩家, 按钮(技能1));
		等待(10, 无视条件);
	}
}

规则("MUT Team 1 (Mutator) McCree: Extended, Flashbang")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		卡西迪;
	}

	条件
	{
		全局.Mut_Extended_Arsenal == 真;
		事件玩家.Is_Target_in_LOS >= 4;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > 40);
		根据条件循环(相距距离(事件玩家, 事件玩家.Target) >= 8);
		按下按键(事件玩家, 按钮(技能2));
		等待(10, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Soldier: Shoot")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		士兵：76;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
		绝对值(水平方向夹角(事件玩家, 事件玩家.Target)) <= 5;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(主要攻击模式));
		等待(随机实数(0.400, 0.600), 无视条件);
		停止按下按钮(事件玩家, 按钮(主要攻击模式));
		If(弹药(事件玩家, 0) <= 2);
			按下按键(事件玩家, 按钮(装填));
		End;
		等待(随机实数(1.200, 1.800), 无视条件);
		如条件为”真“则循环;
	}
}

规则("MUT Team 1 (Mutator) Soldier: Extended, Helix Rockets")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		士兵：76;
	}

	条件
	{
		全局.Mut_Extended_Arsenal == 真;
		事件玩家.Is_Target_in_LOS >= 4;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > 50);
		按下按键(事件玩家, 按钮(辅助攻击模式));
		等待(8, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Baptiste: Revive last time used (2)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		巴蒂斯特;
	}

	动作
	{
		事件玩家.Ab_Var_2 = 0;
	}
}

规则("Team 1 Baptiste: Shoot")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		巴蒂斯特;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
		绝对值(水平方向夹角(事件玩家, 事件玩家.Target)) <= 5;
	}

	动作
	{
		按下按键(事件玩家, 按钮(主要攻击模式));
		If(弹药(事件玩家, 0) <= 3);
			按下按键(事件玩家, 按钮(装填));
		End;
		等待(随机实数(0.700, 1.100), 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Baptiste: Immortality Field, Has Used Immortality Field (1)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		巴蒂斯特;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		事件玩家.Ab_Var_1 == 假;
		标准化生命值(事件玩家) <= 0.250;
		生命值(事件玩家) != 0;
		(全局.Wave >= (全局.Gamemode ? 10 : 12) || 全局.Mut_Last_Stand_active) == 真;
		具有状态(事件玩家, 被入侵) == 假;
		具有状态(事件玩家, 击晕) == 假;
	}

	动作
	{
		事件玩家.Ab_Var_1 = 真;
		根据条件中止(随机整数(1, 100) > 40);
		按下按键(事件玩家, 按钮(技能2));
	}
}

规则("Team 1 Echo: Shoot")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		回声;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
		绝对值(水平方向夹角(事件玩家, 事件玩家.Target)) <= 5;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(主要攻击模式));
		等待(随机实数(0.800, 1.200), 无视条件);
		停止按下按钮(事件玩家, 按钮(主要攻击模式));
		等待(随机实数(0.400, 0.600), 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Echo: Sticky Bombs")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		回声;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > 50);
		根据条件循环(相距距离(事件玩家, 事件玩家.Target) >= 20);
		按下按键(事件玩家, 按钮(辅助攻击模式));
		等待(全局.Mut_Adrenaline ? 3 : 6, 无视条件);
		如条件为”真“则循环;
	}
}

规则("MUT Team 1 Echo (Mutator): Extended, Focusing Beam")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		回声;
	}

	条件
	{
		全局.Mut_Extended_Arsenal == 真;
		事件玩家.Is_Target_in_LOS >= 4;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(标准化生命值(事件玩家.Target) > 0.500);
		根据条件循环(相距距离(事件玩家, 事件玩家.Target) >= 15);
		按下按键(事件玩家, 按钮(技能2));
		等待(10, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Echo: Flight, Is Landing (1)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		回声;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 5;
		事件玩家.Is_assaulting == 真;
		相距距离(事件玩家, 事件玩家.Target) <= 40;
	}

	动作
	{
		事件玩家.Is_using_Combat_Pathfinding = 真;
		事件玩家.Nav_is_reachable_Node = 假;
		按下按键(事件玩家, 按钮(技能1));
		If(正在使用技能 1(事件玩家));
			事件玩家.Is_flying = 真;
			"Workaround: Ascend and Descend Buttons do not work"
			开始加速(事件玩家, Y方向分量(所选位置(事件玩家)) < Y方向分量(事件玩家.Nav) ? 上 : 下, 具有状态(事件玩家, 击晕) || 具有状态(事件玩家, 定身) || 绝对值(Y方向分量(所选位置(事件玩家)) - Y方向分量(
				事件玩家.Nav)) < 1 ? 0 : 100, 3.500, 至地图, 方向，速率，及最大速度);
			等待直到 (!正在使用技能 1(事件玩家), 99999);
			事件玩家.Is_flying = 假;
			停止加速(事件玩家);
			事件玩家.Ab_Var_1 = 真;
			If(事件玩家.Is_Target_in_LOS);
				事件玩家.Nav = 首个(已排序的数组(已过滤的数组(全局.Nodes, 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线)), 2 * 相距距离(事件玩家, 当前数组元素) - 垂直方向夹角(事件玩家, 当前数组元素)));
				If(事件玩家.Nav == 0);
					事件玩家.Nav = 首个(已排序的数组(全局.Nodes, 相距距离(事件玩家, 当前数组元素)));
				End;
			End;
			等待直到 (在地面上(事件玩家) || 死亡(事件玩家), 99999);
			事件玩家.Ab_Var_1 = 假;
			等待(2, 无视条件);
		End;
		等待(2, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Echo: Glide")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		回声;
	}

	条件
	{
		事件玩家.Ab_Var_1 == 真;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(跳跃));
		等待直到 (!事件玩家.Ab_Var_1, 3);
		停止按下按钮(事件玩家, 按钮(跳跃));
	}
}

规则("Team 1 Sombra: Tase Target (Player), Tase / EMP Start Health (2), Last Translocator (3)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		黑影;
	}

	动作
	{
		事件玩家.Ab_Player = 0;
		事件玩家.Ab_Var_3 = 0;
	}
}

规则("Team 1 Sombra: Shoot")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		黑影;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
		事件玩家.Ab_Player == 0;
		绝对值(水平方向夹角(事件玩家, 事件玩家.Target)) <= 5;
		(!正在使用技能 1(事件玩家) || 相距距离(事件玩家, 事件玩家.Target) <= 8) == 真;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(主要攻击模式));
		等待(随机实数(0.400, 0.600), 无视条件);
		停止按下按钮(事件玩家, 按钮(主要攻击模式));
		If(弹药(事件玩家, 0) <= 5);
			按下按键(事件玩家, 按钮(装填));
		End;
		等待(随机实数(0.800, 1.200), 无视条件);
		如条件为”真“则循环;
	}
}

规则("MUT Team 1 Sombra (Mutator): Extended, Stealth")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		黑影;
	}

	条件
	{
		全局.Mut_Extended_Arsenal == 真;
		存活(事件玩家) == 真;
		事件玩家.Is_assaulting == 真;
		事件玩家.Is_Target_in_LOS == 假;
		正在使用技能 1(事件玩家) == 假;
	}

	动作
	{
		等待(1, 当为“假”时中止);
		按下按键(事件玩家, 按钮(技能1));
	}
}

规则("Team 1 Sombra: Translocator")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		黑影;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		事件玩家.Is_assaulting == 真;
		事件玩家.Target.Is_flying == 假;
		正在使用技能 2(事件玩家) == 假;
		相距距离(事件玩家, 事件玩家.Target) >= 7.500;
		相距距离(事件玩家, 事件玩家.Target) <= 25;
		Y方向分量(所选位置(事件玩家.Target)) - Y方向分量(所选位置(事件玩家)) >= 3;
		在视野内(事件玩家, 事件玩家.Target, 5) == 真;
		在视线内(眼睛位置(事件玩家), 眼睛位置(事件玩家.Target) + 全局.Aim_Offset, 屏障不会阻挡视线) == 真;
	}

	动作
	{
		按下按键(事件玩家, 按钮(技能2));
		等待(0.200 + 相距距离(事件玩家, 事件玩家.Target) / 25, 无视条件);
		根据条件中止(!正在使用技能 2(事件玩家));
		按下按键(事件玩家, 按钮(技能2));
		等待(0.100, 无视条件);
		根据条件中止(!具有状态(事件玩家, 相移));
		事件玩家.Ab_Var_3 = 总计消耗时间;
		事件玩家.Nav_is_reachable_Node = 假;
		等待(10, 无视条件);
	}
}

规则("Team 1 Sombra: EMP")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		黑影;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 5;
		(全局.Wave >= (全局.Gamemode ? 13 : 18) || 全局.Mut_Last_Stand_active) == 真;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > (事件玩家.Ab_Var_3 + 2 >= 总计消耗时间 ? 60 : 30));
		根据条件循环(具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 击晕));
		根据条件循环(相距距离(事件玩家, 事件玩家.Target) >= 12);
		根据条件循环(!在视线内(眼睛位置(事件玩家), 眼睛位置(事件玩家.Target), 屏障不会阻挡视线));
		播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(亮紫色), 事件玩家, 1);
		等待(0.500, 无视条件);
		设置终极技能充能(事件玩家, 100);
		按下按键(事件玩家, 按钮(终极技能));
		事件玩家.Ab_Var_2 = 生命值(事件玩家);
		等待直到 (终极技能充能百分比(事件玩家) != 100 && 生命值(事件玩家) < 事件玩家.Ab_Var_2, 0.300);
		If(终极技能充能百分比(事件玩家) != 100 && 生命值(事件玩家) < 事件玩家.Ab_Var_2);
			设置状态(事件玩家, 无, 击晕, 0.500);
			等待(8, 无视条件);
		Else;
			等待(18, 无视条件);
		End;
		如条件为”真“则循环;
	}
}

规则("Team 1 Sombra: Tase")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		黑影;
	}

	条件
	{
		存活(事件玩家) == 真;
		事件玩家.Is_Target_in_LOS == 真;
		正在使用技能 1(事件玩家) == 假;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > (事件玩家.Target.Is_flying ? 80 : 40));
		根据条件循环(具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 击晕));
		根据条件循环(具有状态(事件玩家.Target, 无敌) || 具有状态(事件玩家.Target, 相移) || 正在使用终极技能(事件玩家.Target) || 终极技能充能百分比(事件玩家.Target)
			<= 事件玩家.Target.Ab_Charged * 20);
		根据条件循环(相距距离(事件玩家, 事件玩家.Target) >= 10);
		根据条件循环(!在视线内(眼睛位置(事件玩家), 眼睛位置(事件玩家.Target), 所有屏障阻挡视线));
		事件玩家.Ab_Player = 事件玩家.Target;
		事件玩家.Ab_Var_2 = 生命值(事件玩家);
		事件玩家.Ab_Player.Tased_until = 总计消耗时间 + 5;
		设置状态(事件玩家, 无, 定身, 5);
		If(!事件玩家.Ab_Player.Perk_Shockproof);
			小字体信息(事件玩家.Ab_Player, 自定义字符串("黑影正在电击你！射击她来挣脱！"));
		End;
		等待(13, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Sombra: Tase times out / Lost Health / Target is downed / Target left / Is CCd / Distance too High / LOS lost")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		黑影;
	}

	条件
	{
		事件玩家.Ab_Player != 0;
		(事件玩家.Ab_Player.Tased_until < 总计消耗时间 || 生命值(事件玩家)
			< 事件玩家.Ab_Var_2 || 事件玩家.Ab_Player.Downed_since || !事件玩家.Ab_Player.Is_Combatant || 具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 击晕) || 相距距离(
			事件玩家, 事件玩家.Ab_Player) >= 11 || !在视线内(眼睛位置(事件玩家), 眼睛位置(事件玩家.Ab_Player), 所有屏障阻挡视线)) == 真;
	}

	动作
	{
		If(事件玩家.Ab_Player.Perk_Shockproof);
			伤害(事件玩家, 事件玩家.Ab_Player, 50);
			设置状态(已过滤的数组(范围内玩家(眼睛位置(事件玩家), 10, 队伍1, 表面), !具有状态(当前数组元素, 相移)), 无, 被入侵, 2);
			播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(亮紫色), 事件玩家, 10);
			播放效果(所有玩家(所有队伍), 爆炸声音, 颜色(白色), 事件玩家, 200);
		End;
		事件玩家.Ab_Player.Tased_until = 0;
		事件玩家.Ab_Player = 0;
		清除状态(事件玩家, 定身);
	}
}

规则("Team 1 Sombra: Took Damage while Tasing")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		黑影;
	}

	条件
	{
		事件玩家.Ab_Player != 0;
	}

	动作
	{
		If(事件玩家.Ab_Player.Perk_Shockproof);
			设置状态(范围内玩家(眼睛位置(事件玩家), 10, 队伍1, 表面), 无, 被入侵, 3);
			播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(亮紫色), 事件玩家, 10);
			播放效果(所有玩家(所有队伍), 爆炸声音, 颜色(白色), 事件玩家, 200);
		End;
		事件玩家.Ab_Player.Tased_until = 0;
		事件玩家.Ab_Player = 0;
		清除状态(事件玩家, 定身);
	}
}

规则("Team 2: Is Tased, Disable Abilities, Movement, Shake Facing, Set Aimspeed, Shoot")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Tased_until >= 总计消耗时间;
	}

	动作
	{
		根据条件中止(事件玩家.Perk_Shockproof);
		设置状态(事件玩家, 无, 点燃, 10);
		设置状态(事件玩家, 无, 被入侵, 10);
		设置状态(事件玩家, 无, 定身, 10);
		开始朝向(事件玩家, 与此角度的相对方向(水平朝向角度(事件玩家) + 随机整数(-100, 20), 垂直朝向角度(事件玩家) + 随机整数(-100, 80)), 100, 至地图, 方向及角速率);
		按下按键(事件玩家, 所用英雄(事件玩家) == 英雄(莫伊拉) ? 按钮(辅助攻击模式) : 按钮(主要攻击模式));
		等待(0.300, 无视条件);
		停止朝向(事件玩家);
		While(事件玩家.Tased_until >= 总计消耗时间);
			设置瞄准速度(事件玩家, 50);
			按下按键(事件玩家, 所用英雄(事件玩家) == 英雄(莫伊拉) ? 按钮(辅助攻击模式) : 按钮(主要攻击模式));
			等待直到 (事件玩家.Tased_until < 总计消耗时间, 随机实数(0.100, 0.300));
			设置瞄准速度(事件玩家, 200);
			按下按键(事件玩家, 所用英雄(事件玩家) == 英雄(莫伊拉) ? 按钮(辅助攻击模式) : 按钮(主要攻击模式));
			等待直到 (事件玩家.Tased_until < 总计消耗时间, 随机实数(0.100, 0.300));
		End;
		设置瞄准速度(事件玩家, 100);
		清除状态(事件玩家, 点燃);
		清除状态(事件玩家, 被入侵);
		清除状态(事件玩家, 定身);
	}
}

规则("Team 1 Widowmaker: Shoot, Target (Player), Scoped Since (2)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		黑百合;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
	}

	动作
	{
		If(相距距离(事件玩家, 事件玩家.Target) > 8);
			事件玩家.Ab_Player = 事件玩家.Target;
			事件玩家.Ab_Var_2 = 总计消耗时间;
			开始按下按钮(事件玩家, 按钮(辅助攻击模式));
			等待(0.100, 无视条件);
			While(正在使用辅助武器(事件玩家) && 事件玩家.Is_Target_in_LOS && 事件玩家.Ab_Var_2 + (全局.Is_Infrasight_on_Bots1 ? 0.900 : 1.300) >= 总计消耗时间);
				等待(0.100, 无视条件);
				If(事件玩家.Ab_Player != 事件玩家.Target);
					事件玩家.Ab_Player = 事件玩家.Target;
					事件玩家.Ab_Var_2 = 总计消耗时间;
				End;
			End;
			If(正在使用辅助武器(事件玩家) && 事件玩家.Is_Target_in_LOS >= 4);
				按下按键(事件玩家, 按钮(主要攻击模式));
				等待(0.016, 无视条件);
			End;
			停止按下按钮(事件玩家, 按钮(辅助攻击模式));
		Else;
			开始按下按钮(事件玩家, 按钮(主要攻击模式));
			等待(随机实数(0.400, 0.600), 无视条件);
			停止按下按钮(事件玩家, 按钮(主要攻击模式));
			If(弹药(事件玩家, 0) <= 2);
				按下按键(事件玩家, 按钮(装填));
			End;
		End;
		等待(随机实数(0.800, 1.200), 无视条件);
		如条件为”真“则循环;
	}
}

规则("MUT Team 1 Widowmaker (Mutator): Extended, Venom Mine")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		黑百合;
	}

	条件
	{
		全局.Mut_Extended_Arsenal == 真;
		存活(事件玩家) == 真;
		事件玩家.Is_Target_in_LOS == 假;
	}

	动作
	{
		等待(1, 当为“假”时中止);
		按下按键(事件玩家, 按钮(技能2));
		等待(20, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Widowmaker: Infra-Sight")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		黑百合;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		全局.Is_Infrasight_on_Bots1 == 假;
		(全局.Wave >= (全局.Gamemode ? 13 : 17) || 全局.Mut_Last_Stand_active) == 真;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > 20);
		设置终极技能充能(事件玩家, 100);
		按下按键(事件玩家, 按钮(终极技能));
		等待(全局.Mut_Adrenaline ? 14 : 29, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Widowmaker: Infra-Sight if Sombra is stealthed")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		黑百合;
	}

	条件
	{
		事件玩家.Target == 0;
		全局.Is_Infrasight_on_Bots1 == 假;
		对任意为”真“(全局.Combatants, 当前数组元素.Is_invisible == 1) == 真;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > 40);
		设置终极技能充能(事件玩家, 100);
		按下按键(事件玩家, 按钮(终极技能));
	}
}

规则("Global: Set / Unset Is Infrasight on (Bots)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.Is_Infrasight_on_Bots1 != 对任意为”真“(选择英雄的玩家(英雄(黑百合), 队伍1), 正在使用终极技能(当前数组元素));
	}

	动作
	{
		全局.Is_Infrasight_on_Bots1 = !全局.Is_Infrasight_on_Bots1;
		全局.Aim_Offset = (全局.Is_Infrasight_on_Bots1 ? 0 : 0.500) * 下;
		等待(0.016, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Reaper: Shoot")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		死神;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
		绝对值(水平方向夹角(事件玩家, 事件玩家.Target)) <= 5;
		正在使用技能 1(事件玩家) == 假;
	}

	动作
	{
		按下按键(事件玩家, 按钮(主要攻击模式));
		等待(0.600, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Reaper: Wraith Form, Wraith Position (3), Force Position")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		死神;
	}

	条件
	{
		存活(事件玩家) == 真;
		事件玩家.Is_assaulting == 真;
		事件玩家.Feared_until < 总计消耗时间;
		具有状态(事件玩家, 被入侵) == 假;
		具有状态(事件玩家, 定身) == 假;
		具有状态(事件玩家, 击晕) == 假;
		相距距离(事件玩家, 事件玩家.Target) >= 10;
		相距距离(事件玩家, 事件玩家.Target) <= 40;
	}

	动作
	{
		按下按键(事件玩家, 按钮(技能1));
		If(正在使用技能 1(事件玩家));
			事件玩家.Ab_Var_3 = 所选位置(事件玩家);
			追踪玩家变量频率(事件玩家, Ab_Var_3, 所选位置(事件玩家.Target) + 0.500 * 上, 相距距离(事件玩家, 事件玩家.Target) <= 10 ? 10 : 20, 速率及最终值);
			开始强制设置玩家位置(事件玩家, 事件玩家.Ab_Var_3, 真);
			取消与环境的移动碰撞(事件玩家, 真);
			事件玩家.Is_Wraith = 真;
			等待(8, 无视条件);
		Else;
			等待(1, 无视条件);
		End;
		如条件为”真“则循环;
	}
}

规则("Team 1 Reaper: Cancel Wraith Form, Stop Forcing Position")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		死神;
	}

	条件
	{
		事件玩家.Is_Wraith == 真;
		正在使用技能 1(事件玩家) == 真;
		相距距离(事件玩家, 事件玩家.Target) <= 3;
		在视线内(事件玩家.Target, 所选位置(事件玩家), 屏障不会阻挡视线) == 真;
	}

	动作
	{
		按下按键(事件玩家, 按钮(技能1));
		停止追踪玩家变量(事件玩家, Ab_Var_3);
		停止强制设置玩家位置(事件玩家);
		开启与环境的移动碰撞(事件玩家);
		事件玩家.Is_Wraith = 假;
		事件玩家.Nav_is_reachable_Node = 假;
	}
}

规则("Team 1 Reaper: Wraith Form Timed out / Target left / Target is invisible, Stop Forcing Position")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		死神;
	}

	条件
	{
		事件玩家.Is_Wraith == 真;
		(!正在使用技能 1(事件玩家) || !事件玩家.Target.Is_Combatant || 事件玩家.Target.Is_invisible > (相距距离(事件玩家, 事件玩家.Target)
			<= 2.400 || 全局.Is_Infrasight_on_Bots1)) == 真;
	}

	动作
	{
		停止追踪玩家变量(事件玩家, Ab_Var_3);
		停止强制设置玩家位置(事件玩家);
		开启与环境的移动碰撞(事件玩家);
		事件玩家.Is_Wraith = 假;
		事件玩家.Nav_is_reachable_Node = 假;
	}
}

规则("Team 1 Reaper: Death Blossom")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		死神;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 5;
		正在使用技能 1(事件玩家) == 假;
		(全局.Wave >= (全局.Gamemode ? 12 : 15) || 全局.Mut_Last_Stand_active) == 真;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > 20);
		根据条件循环(相距距离(事件玩家, 事件玩家.Target) >= 7);
		设置终极技能充能(事件玩家, 100);
		按下按键(事件玩家, 按钮(终极技能));
		等待(全局.Mut_Adrenaline ? 14 : 28, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Orisa: Start / Stop Shooting")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		奥丽莎;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 3;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(主要攻击模式));
		等待直到 (事件玩家.Is_Target_in_LOS < 3, 99999);
		停止按下按钮(事件玩家, 按钮(主要攻击模式));
	}
}

规则("Team 1 Orisa: Decrease / Normalize Move Speed while shooting on ground")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		奥丽莎;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		在地面上(事件玩家) == 真;
		事件玩家.Has_Spawn_Speed_Bonus == 假;
	}

	动作
	{
		设置移动速度(事件玩家, 全局.Mut_Amped ? 57.500 : 50);
		等待直到 (!(按钮被按下(事件玩家, 按钮(主要攻击模式)) && 在地面上(事件玩家)), 99999);
		设置移动速度(事件玩家, 全局.Mut_Amped ? 115 : 100);
	}
}

规则("Team 1 Orisa: Halt!")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		奥丽莎;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		事件玩家.Target.Is_flying == 真;
		相距距离(事件玩家, 事件玩家.Target) >= 10;
		在视野内(事件玩家, 事件玩家.Target, 5) == 真;
		在视线内(眼睛位置(事件玩家), 眼睛位置(事件玩家.Target) + 全局.Aim_Offset, 屏障不会阻挡视线) == 真;
	}

	动作
	{
		按下按键(事件玩家, 按钮(辅助攻击模式));
		等待(0.100 + 相距距离(事件玩家, 事件玩家.Target) / 25, 无视条件);
		按下按键(事件玩家, 按钮(辅助攻击模式));
		等待(15, 无视条件);
		如条件为”真“则循环;
	}
}

规则("MUT Team 1 Orisa (Mutator): Extended, Fortify, Has Used Fortify (1)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		奥丽莎;
	}

	条件
	{
		全局.Mut_Extended_Arsenal == 真;
		事件玩家.Is_Target_in_LOS == 真;
		事件玩家.Ab_Var_1 == 假;
		标准化生命值(事件玩家) <= (具有状态(事件玩家, 定身) ? 0.900 : 0.500);
		生命值(事件玩家) != 0;
		具有状态(事件玩家, 被入侵) == 假;
		具有状态(事件玩家, 击晕) == 假;
	}

	动作
	{
		事件玩家.Ab_Var_1 = 真;
		If(随机整数(1, 100) <= 50);
			按下按键(事件玩家, 按钮(技能2));
		Else;
			按下按键(事件玩家, 按钮(技能1));
		End;
	}
}

规则("Team 1 Orisa: Supercharger")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		奥丽莎;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		(全局.Wave >= (全局.Gamemode ? 12 : 15) || 全局.Mut_Last_Stand_active) == 真;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > 20);
		根据条件循环(对任意为”真“(选择英雄的玩家(英雄(奥丽莎), 队伍1), 正在使用终极技能(当前数组元素)));
		设置终极技能充能(事件玩家, 100);
		按下按键(事件玩家, 按钮(终极技能));
		等待(全局.Mut_Adrenaline ? 14 : 23, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Roadhog: Shoot")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		路霸;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
		绝对值(水平方向夹角(事件玩家, 事件玩家.Target)) <= 5;
		正在使用技能 1(事件玩家) == 假;
	}

	动作
	{
		If(相距距离(事件玩家, 事件玩家.Target) > 9);
			按下按键(事件玩家, 按钮(辅助攻击模式));
		Else;
			按下按键(事件玩家, 按钮(主要攻击模式));
		End;
		等待(随机实数(0.900, 1.300), 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Roadhog: Chain Hook")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		路霸;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
		弹药(事件玩家, 0) > 0;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > (事件玩家.Target.Is_flying ? 80 : 40));
		根据条件循环(相距距离(事件玩家, 事件玩家.Target) >= 20);
		按下按键(事件玩家, 按钮(技能1));
		等待(全局.Mut_Adrenaline ? 4 : 8, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Roadhog: Whole Hog")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		路霸;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 5;
		(全局.Wave >= (全局.Gamemode ? 11 : 14) || 全局.Mut_Last_Stand_active) == 真;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > 20);
		根据条件循环(相距距离(事件玩家, 事件玩家.Target) >= 5);
		设置终极技能充能(事件玩家, 100);
		按下按键(事件玩家, 按钮(终极技能));
		等待(全局.Mut_Adrenaline ? 14 : 28, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Tracer: Shoot")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		猎空;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
		绝对值(水平方向夹角(事件玩家, 事件玩家.Target)) <= 5;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(主要攻击模式));
		等待(随机实数(0.400, 0.600), 无视条件);
		停止按下按钮(事件玩家, 按钮(主要攻击模式));
		If(弹药(事件玩家, 0) <= 10);
			按下按键(事件玩家, 按钮(装填));
		End;
		等待(随机实数(0.400, 0.600), 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Tracer: Blink")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		猎空;
	}

	条件
	{
		事件玩家.Is_assaulting == 真;
		事件玩家.Is_Target_in_LOS >= 4;
		相距距离(事件玩家, 事件玩家.Target) <= 5;
		绝对值(水平方向夹角(事件玩家.Target, 事件玩家)) <= 45;
	}

	动作
	{
		事件玩家.Nav = 所选位置(事件玩家.Target);
		按下按键(事件玩家, 按钮(技能1));
		等待(1, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Tracer: Recall to enemy on high ground")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		猎空;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		事件玩家.Is_assaulting == 真;
		事件玩家.Target.Is_flying == 假;
		相距距离(事件玩家, 事件玩家.Target) <= 20;
		Y方向分量(所选位置(事件玩家.Target)) - Y方向分量(所选位置(事件玩家)) >= 3;
	}

	动作
	{
		设置技能冷却(事件玩家, 按钮(技能2), 0);
		按下按键(事件玩家, 按钮(技能2));
		等待(0.800, 无视条件);
		If(正在使用技能 2(事件玩家) && 事件玩家.Is_Target_in_LOS);
			传送(事件玩家, 射线命中位置(眼睛位置(事件玩家.Target), 所选位置(事件玩家.Target) - 2.500 * 与此角度的相对方向(水平朝向角度(事件玩家.Target), 0), 无, 无, 假) + 0.500 * 与此角度的相对方向(
				水平朝向角度(事件玩家.Target), 0));
			事件玩家.Nav_is_reachable_Node = 假;
			等待(15, 无视条件);
		End;
		等待(5, 无视条件);
	}
}

规则("Team 1 Tracer: Pulse Bomb, Has Used Pulse Bomb (1)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		猎空;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		事件玩家.Is_assaulting == 真;
		事件玩家.Ab_Var_1 == 假;
		标准化生命值(事件玩家) <= 0.400;
		生命值(事件玩家) != 0;
		具有状态(事件玩家, 被入侵) == 假;
		具有状态(事件玩家, 击晕) == 假;
	}

	动作
	{
		事件玩家.Ab_Var_1 = 真;
		设置终极技能充能(事件玩家, 100);
		按下按键(事件玩家, 按钮(终极技能));
		等待(0.200, 无视条件);
		取消主要动作(事件玩家);
		设置技能冷却(事件玩家, 按钮(技能2), 0);
		按下按键(事件玩家, 按钮(技能2));
		等待(0.800, 无视条件);
		根据条件中止(!(正在使用技能 2(事件玩家) && 事件玩家.Is_Target_in_LOS));
		传送(事件玩家, 射线命中位置(眼睛位置(事件玩家.Target), 所选位置(事件玩家.Target) - 2.500 * 与此角度的相对方向(水平朝向角度(事件玩家.Target), 0), 无, 无, 假) + 0.500 * 与此角度的相对方向(
			水平朝向角度(事件玩家.Target), 0));
		事件玩家.Nav_is_reachable_Node = 假;
	}
}

规则("Team 1 Sigma: Shoot")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		西格玛;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
		绝对值(水平方向夹角(事件玩家, 事件玩家.Target)) <= 5;
	}

	动作
	{
		按下按键(事件玩家, 按钮(主要攻击模式));
		等待(1.800, 无视条件);
		如条件为”真“则循环;
	}
}

规则("MUT Team 1 Sigma (Mutator): Extended, Kinetic Grasp")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		西格玛;
	}

	条件
	{
		全局.Mut_Extended_Arsenal == 真;
	}

	动作
	{
		根据条件中止(随机整数(1, 100) > 20);
		按下按键(事件玩家, 按钮(技能1));
		等待(10, 无视条件);
	}
}

规则("Team 1 Sigma: Accretion")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		西格玛;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > (事件玩家.Target.Is_flying ? 80 : 40));
		根据条件循环(相距距离(事件玩家, 事件玩家.Target) >= 20);
		按下按键(事件玩家, 按钮(技能2));
		等待(13, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Sigma: Experimental Barrier, Set Is Using Experimental Barrier (1)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		西格玛;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
	}

	动作
	{
		事件玩家.Ab_Var_1 = 真;
		等待直到 (技能冷却时间(事件玩家, 按钮(辅助攻击模式)) > 0 || 死亡(事件玩家) || 具有状态(事件玩家, 被入侵), 99999);
		事件玩家.Ab_Var_1 = 假;
	}
}

规则("Team 1 Sigma: Send Experimental Barrier")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		西格玛;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		事件玩家.Ab_Var_1 == 假;
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) == 0;
		正在使用主要武器(事件玩家) == 假;
		在视野内(事件玩家, 事件玩家.Target, 5) == 真;
		在视线内(事件玩家.Target, 事件玩家, 敌方屏障阻挡视线) == 真;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(辅助攻击模式));
		等待(0.100, 无视条件);
		If(!事件玩家.Ab_Var_1);
			停止按下按钮(事件玩家, 按钮(辅助攻击模式));
			等待(0.500, 无视条件);
			如条件为”真“则循环;
		End;
		等待(相距距离(事件玩家, 事件玩家.Target) / 50 - 0.100, 无视条件);
		停止按下按钮(事件玩家, 按钮(辅助攻击模式));
	}
}

规则("Team 1 Sigma: Recall Experimental Barrier")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		西格玛;
	}

	条件
	{
		事件玩家.Ab_Var_1 == 真;
		存活(事件玩家) == 真;
		(!事件玩家.Is_Target_in_LOS || 在视线内(事件玩家.Target, 事件玩家, 敌方屏障阻挡视线)) == 真;
	}

	动作
	{
		等待(1.500, 当为“假”时中止);
		按下按键(事件玩家, 按钮(辅助攻击模式));
		等待(0.500, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Sigma: Gravitic Flux")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		西格玛;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		(全局.Wave >= (全局.Gamemode ? 15 : 20) || 全局.Mut_Last_Stand_active) == 真;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > 30);
		根据条件循环(相距距离(事件玩家, 事件玩家.Target) >= 25);
		设置终极技能充能(事件玩家, 100);
		按下按键(事件玩家, 按钮(终极技能));
		等待(28, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Genji: Shoot")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		源氏;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
		(正在使用终极技能(事件玩家) && 相距距离(事件玩家, 事件玩家.Target) > 5) == 假;
	}

	动作
	{
		If(相距距离(事件玩家, 事件玩家.Target) > 4 || 正在使用终极技能(事件玩家));
			按下按键(事件玩家, 按钮(主要攻击模式));
		Else;
			按下按键(事件玩家, 按钮(辅助攻击模式));
		End;
		等待(1, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Genji: Jump")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		源氏;
	}

	条件
	{
		存活(事件玩家) == 真;
		事件玩家.Is_using_Combat_Pathfinding == 真;
		在地面上(事件玩家) == 真;
	}

	动作
	{
		按下按键(事件玩家, 按钮(跳跃));
		等待(0.500, 无视条件);
		按下按键(事件玩家, 按钮(跳跃));
		等待(随机实数(0.800, 1.200), 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Genji: Swift Strike")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		源氏;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
		事件玩家.Is_assaulting == 真;
		相距距离(事件玩家, 事件玩家.Target) <= 10;
		绝对值(水平方向夹角(事件玩家, 事件玩家.Target)) <= 5;
		正在使用技能 2(事件玩家) == 假;
	}

	动作
	{
		按下按键(事件玩家, 按钮(技能1));
		等待(全局.Mut_Adrenaline ? 3 : 4, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Genji: Deflect")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		源氏;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 假;
	}

	动作
	{
		根据条件中止(随机整数(1, 100) > 30);
		按下按键(事件玩家, 按钮(技能2));
		等待(10, 无视条件);
	}
}

规则("Team 1 Genji: Dragonblade")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		源氏;
	}

	条件
	{
		标准化生命值(事件玩家) <= 0.500;
		生命值(事件玩家) != 0;
		正在使用终极技能(事件玩家) == 假;
	}

	动作
	{
		设置终极技能充能(事件玩家, 100);
		按下按键(事件玩家, 按钮(终极技能));
		等待(0.500, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Hanzo: Shoot")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		半藏;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(主要攻击模式));
		等待(0.800, 无视条件);
		停止按下按钮(事件玩家, 按钮(主要攻击模式));
		等待(0.600, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Hanzo: Lunge")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		半藏;
	}

	条件
	{
		事件玩家.Is_using_Combat_Pathfinding == 真;
	}

	动作
	{
		根据条件中止(随机整数(1, 100) > 50);
		按下按键(事件玩家, 按钮(跳跃));
		等待(0.400, 无视条件);
		按下按键(事件玩家, 按钮(跳跃));
		等待(6, 无视条件);
	}
}

规则("Team 1 Hanzo: Storm Arrows")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		半藏;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		标准化生命值(事件玩家) <= 0.500;
		生命值(事件玩家) != 0;
		正在使用技能 2(事件玩家) == 假;
	}

	动作
	{
		按下按键(事件玩家, 按钮(技能2));
		等待(0.500, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Hanzo: Dragonstrike")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		半藏;
	}

	条件
	{
		存活(事件玩家) == 真;
		事件玩家.Is_Target_in_LOS == 假;
		相距距离(事件玩家, 事件玩家.Target) >= 15;
	}

	动作
	{
		等待(1, 当为“假”时中止);
		设置终极技能充能(事件玩家, 100);
		按下按键(事件玩家, 按钮(终极技能));
		等待(全局.Mut_Adrenaline ? 25 : 45, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Bastion: Use Ultimate (1), Use Sentry Mode (2), Set Unkillable")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		堡垒;
	}

	条件
	{
		存活(事件玩家) == 真;
	}

	动作
	{
		事件玩家.Ab_Var_2 = 假;
		根据条件中止(事件玩家.Ab_Var_1);
		设置状态(事件玩家, 无, 无法杀死, 9999);
	}
}

规则("Team 1 Bastion: Shoot")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		堡垒;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 3;
	}

	动作
	{
		If(正在使用终极技能(事件玩家));
			按下按键(事件玩家, 按钮(主要攻击模式));
			等待(1.100, 无视条件);
		Else;
			开始按下按钮(事件玩家, 按钮(主要攻击模式));
			等待(随机实数(1.600, 2.400), 无视条件);
			停止按下按钮(事件玩家, 按钮(主要攻击模式));
			If(弹药(事件玩家, 0) <= 8 || 弹药(事件玩家, 1) <= 30);
				按下按键(事件玩家, 按钮(装填));
			End;
			等待(随机实数(0.400, 0.600), 无视条件);
		End;
		如条件为”真“则循环;
	}
}

规则("Team 1 Bastion: Set / Unset Use Sentry Mode (2)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		堡垒;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 3;
		事件玩家.Is_assaulting == 真;
		正在使用终极技能(事件玩家) == 假;
		相距距离(事件玩家, 事件玩家.Target) <= 20;
	}

	动作
	{
		等待(2.500, 当为“假”时中止);
		事件玩家.Ab_Var_2 = 真;
		等待直到 (事件玩家.Is_Target_in_LOS < 3, 5);
		事件玩家.Ab_Var_2 = 假;
		如条件为”真“则循环;
	}
}

规则("Team 1 Bastion: Reconfigure")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		堡垒;
	}

	条件
	{
		存活(事件玩家) == 真;
		正在使用终极技能(事件玩家) == 假;
	}

	动作
	{
		If(事件玩家.Ab_Var_2 != 处于非初始状态(事件玩家));
			按下按键(事件玩家, 按钮(技能1));
		End;
		等待(0.500, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Bastion: Health reaches 1, Set Use Ultimate (1), Heal, Clear Unkillable")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		堡垒;
	}

	条件
	{
		生命值(事件玩家) == 1;
		事件玩家.Ab_Var_1 == 假;
	}

	动作
	{
		事件玩家.Ab_Var_1 = 真;
		开始持续治疗(事件玩家, 无, 1.500, 最大生命值(事件玩家));
		等待(1.500, 无视条件);
		清除状态(事件玩家, 无法杀死);
	}
}

规则("Team 1 Bastion: Configuration: Tank")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		堡垒;
	}

	条件
	{
		存活(事件玩家) == 真;
		事件玩家.Ab_Var_1 == 真;
		正在使用终极技能(事件玩家) == 假;
	}

	动作
	{
		设置终极技能充能(事件玩家, 100);
		按下按键(事件玩家, 按钮(终极技能));
		等待(0.500, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Reinhardt: Disable Barrier Field after breaking")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		莱因哈特;
	}

	条件
	{
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) > 0;
	}

	动作
	{
		设置技能冷却(事件玩家, 按钮(辅助攻击模式), 1000);
	}
}

规则("Team 1 Reinhardt: Hold / Drop Shield if Target and Distance to Target >= 5m")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		莱因哈特;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		相距距离(事件玩家, 事件玩家.Target) >= 5;
		"Reinhardt won't automatically raise his shield again after charging or being hacked"
		正在使用技能 1(事件玩家) == 假;
		具有状态(事件玩家, 被入侵) == 假;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(辅助攻击模式));
		等待直到 (!(事件玩家.Is_Target_in_LOS && 相距距离(事件玩家, 事件玩家.Target) >= 5 && !正在使用技能 1(事件玩家) && !具有状态(事件玩家, 被入侵)), 99999);
		停止按下按钮(事件玩家, 按钮(辅助攻击模式));
	}
}

规则("Team 1 Reinhardt: Start / Stop Attacking if Distance to Target < 5m")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		莱因哈特;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		相距距离(事件玩家, 事件玩家.Target) < 5;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(主要攻击模式));
		等待直到 (!(事件玩家.Is_Target_in_LOS && 相距距离(事件玩家, 事件玩家.Target) < 5), 99999);
		停止按下按钮(事件玩家, 按钮(主要攻击模式));
	}
}

规则("Team 1 Reinhardt: Fire Strike")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		莱因哈特;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 4;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > 75);
		根据条件循环(相距距离(事件玩家, 事件玩家.Target) <= 5 || 相距距离(事件玩家, 事件玩家.Target) >= 25);
		按下按键(事件玩家, 按钮(技能2));
		等待(全局.Mut_Adrenaline ? 2.500 : 5, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Reinhardt: Charge")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		莱因哈特;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 5;
		事件玩家.Is_assaulting == 真;
		事件玩家.Target.Last_Time_hit_by_Shatter + 1 >= 总计消耗时间;
		事件玩家.Target.Last_Time_hit_by_Shatter + 0.300 < 总计消耗时间;
		绝对值(水平方向夹角(事件玩家, 事件玩家.Target)) <= 5;
	}

	动作
	{
		按下按键(事件玩家, 按钮(技能1));
		等待(6, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Reinhardt: Earthshatter")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		莱因哈特;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS >= 5;
		事件玩家.Target.Is_flying == 假;
		正在使用辅助武器(事件玩家) == 假;
	}

	动作
	{
		等待(1, 当为“假”时中止);
		根据条件循环(随机整数(1, 100) <= 100 * 标准化生命值(事件玩家));
		根据条件循环(相距距离(事件玩家, 事件玩家.Target) >= 18 || 绝对值(水平方向夹角(事件玩家, 事件玩家.Target)) >= 30);
		设置终极技能充能(事件玩家, 100);
		按下按键(事件玩家, 按钮(终极技能));
		等待(全局.Mut_Adrenaline ? 4 : 7, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 2: Is Shattered, Start Accelerating")
{
	事件
	{
		玩家受到伤害;
		队伍2;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(莱因哈特);
		事件技能 == 按钮(终极技能);
	}

	动作
	{
		设置状态(事件玩家, 无, 击晕, 3);
		事件玩家.Last_Time_hit_by_Shatter = 总计消耗时间;
		施加推力(事件玩家, 与此角度的相对方向(与此方向的水平角度(事件方向), 30), 15, 至地图, 取消相反运动XYZ);
		开始加速(事件玩家, 与此角度的相对方向(与此方向的水平角度(事件方向), 30), 正在空中(事件玩家) ? 100 : (1 - (总计消耗时间 - 事件玩家.Last_Time_hit_by_Shatter)) * 500, 15, 至地图,
			方向，速率，及最大速度);
		等待(1, 当为“真”时重新开始);
		清除状态(事件玩家, 击晕);
		停止加速(事件玩家);
	}
}

规则("IV HVT Team 1 Slot 6: Create Portal / HVT Entities, Start Damage Modifications")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		栏位 6;
	}

	动作
	{
		If(全局.Gamemode == 1);
			创建进度条HUD文本(全局.IV_Portal_Status == 1 || 全局.IV_Portal_Status == 2 ? 所有玩家(所有队伍) : 空数组, 全局.IV_Portal_Status == 1 ? 200 * 标准化生命值(事件玩家)
				: 全局.IV_HVT_Objective_Timer, 全局.IV_Portal_Status == 1 ? 自定义字符串("摧毁传送门") : 自定义字符串("传送门正在关闭"), 顶部, -97,
				全局.IV_Portal_Status == 1 ? (全局.Boss_Spawns_remaining ? 颜色(白色) : 自定义颜色(较大(200, 255 - (总计消耗时间 - 事件玩家.Ab_Var_2 - 10) * 165), 较大(0,
				255 - (总计消耗时间 - 事件玩家.Ab_Var_2 - 10) * 765), 较大(19, 255 - (总计消耗时间 - 事件玩家.Ab_Var_2 - 10) * 708), 255)) : 颜色(黄色), 颜色(白色), 可见，值和颜色,
				默认可见度);
			创建图标(全局.IV_Portal_Status == 1 || 全局.IV_Portal_Status == 2 ? 所有玩家(所有队伍) : 空数组, 全局.IV_Objective_Position + 2 * 上, 感叹号, 可见和位置, 颜色(黄色),
				真);
			创建地图文本(全局.IV_Portal_Status == 1 || 全局.IV_Portal_Status == 2 ? 所有玩家(所有队伍) : 空数组, 全局.IV_Portal_Status == 1 ? 自定义字符串("摧毁传送门")
				: 自定义字符串("传送门正在关闭"), 全局.IV_Objective_Position + 1.700 * 上, 1.500, 不要截取, 可见，位置和字符串, 颜色(黄色), 默认可见度);
			创建效果(全局.IV_Portal_Status == 1 || 全局.IV_Portal_Status == 2 ? 所有玩家(所有队伍) : 空数组, 球体, 全局.IV_Portal_Status == 1 ? 颜色(红色) : 颜色(黄色),
				全局.IV_Objective_Position + 1.110 * 上, 0.850 + (全局.IV_Portal_Status == 1 ? 0 : 0.300 * 弧度的正弦值(6 * 总计消耗时间)), 可见，位置，半径和颜色);
			创建效果(全局.IV_Portal_Status == 1 || 全局.IV_Portal_Status == 2 ? 所有玩家(所有队伍) : 空数组, 有害光环, 颜色(红色), 全局.IV_Objective_Position + 1.110 * 上,
				1, 可见，位置和半径);
			创建效果(全局.IV_Portal_Status == 1 && (事件玩家.Ab_Var_2 + 10 >= 总计消耗时间 || 全局.Boss_Spawns_remaining) ? 所有玩家(所有队伍) : 空数组, 光柱, 颜色(白色),
				全局.IV_Objective_Position - 2 * 上, 1, 可见，位置和半径);
		Else If(全局.Gamemode == 2);
			创建进度条HUD文本(全局.IV_Portal_Status == 1 || 全局.IV_Portal_Status == 2 ? 所有玩家(所有队伍) : 空数组, 全局.IV_Portal_Status == 1 ? 100 * 标准化生命值(事件玩家)
				: (事件玩家.Downed_since ? 全局.IV_HVT_Objective_Timer : 事件玩家.Revive_Timer) / 1.500, 全局.IV_Portal_Status == 1 ? 自定义字符串("压制高价值目标") : (
				事件玩家.Downed_since ? 自定义字符串("捕捉高价值目标") : 自定义字符串("高价值目标正在被复活中")), 顶部, -97, 全局.IV_Portal_Status == 1 ? 自定义颜色(较大(200, 255 - (
				总计消耗时间 - 全局.HVT_Call_Reinforcements1) * 165), 较大(0, 255 - (总计消耗时间 - 全局.HVT_Call_Reinforcements1) * 765), 较大(19, 255 - (
				总计消耗时间 - 全局.HVT_Call_Reinforcements1) * 708), 255) : (事件玩家.Downed_since ? (事件玩家.Downed_since == 2 ? 颜色(绿色) : 颜色(白色)) : 颜色(红色)),
				全局.IV_Portal_Status == 1 ? 颜色(白色) : (事件玩家.Downed_since ? 颜色(白色) : 颜色(黄色)), 可见，值和颜色, 默认可见度);
			创建图标(全局.IV_Portal_Status == 1 || 全局.IV_Portal_Status == 2 ? 所有玩家(所有队伍) : 空数组, 事件玩家, 感叹号, 可见, 颜色(黄色), 真);
			创建地图文本(全局.IV_Portal_Status == 1 || 全局.IV_Portal_Status == 2 ? 所有玩家(所有队伍) : 空数组, 全局.HVT_Call_Reinforcements1 >= 总计消耗时间 ? 自定义字符串(
				"正在呼叫支援") : (全局.IV_Portal_Status == 1 ? 自定义字符串("压制目标") : 自定义字符串("捕捉目标")), 事件玩家, 1.500, 不要截取, 可见和字符串, 颜色(黄色), 默认可见度);
			创建效果(全局.IV_Portal_Status == 2 ? 所有玩家(所有队伍) : 空数组, 环, 事件玩家.Downed_since ? (事件玩家.Downed_since == 2 ? 颜色(绿色) : 颜色(白色)) : 颜色(红色), 所选位置(
				事件玩家) + 0.650 * 上, 10, 可见，位置，半径和颜色);
			创建效果(全局.IV_Portal_Status == 2 ? 所有玩家(所有队伍) : 空数组, 环, 事件玩家.Downed_since ? (事件玩家.Downed_since == 2 ? 颜色(绿色) : 颜色(白色)) : 颜色(红色), 所选位置(
				事件玩家) + 0.650 * 下, 10, 可见，位置，半径和颜色);
			创建效果(全局.IV_Portal_Status == 2 ? 所有玩家(所有队伍) : 空数组, 环, 事件玩家.Downed_since ? (事件玩家.Downed_since == 2 ? 颜色(绿色) : 颜色(白色)) : 颜色(红色), 所选位置(
				事件玩家), (总计消耗时间 % 1.333 < 0.666) * (15 * 总计消耗时间 % 10), 可见，位置，半径和颜色);
			创建效果(全局.HVT_Call_Reinforcements1 >= 总计消耗时间 ? 所有玩家(所有队伍) : 空数组, 云, 颜色(白色), 事件玩家, 3, 可见);
			For 全局变量(Temp, 0, 2, 1);
				创建效果(全局.IV_Portal_Status == 2 ? 已过滤的数组(全局.Combatants, !当前数组元素.Downed_since && !(当前数组元素.Is_invisible % 3) && 相距距离(事件玩家, 矢量(X方向分量(
					所选位置(当前数组元素)), Y方向分量(所选位置(事件玩家)), Z方向分量(所选位置(当前数组元素)))) <= 10 && 绝对值(Y方向分量(所选位置(事件玩家)) - Y方向分量(所选位置(当前数组元素))) <= 5 && 在视线内(
					事件玩家, 当前数组元素, 屏障不会阻挡视线)) : 空数组, 信标声音, 颜色(白色), 事件玩家, 200, 可见);
			End;
		End;
		"Slot 6 to Players Damage Increase"
		开始伤害调整(全局.Combatants, 事件玩家, 事件玩家.Is_Living_Boss ? 140 : 225, 受伤害者，伤害者及伤害百分比);
		"Boss to Players Damage Decrease"
		开始伤害调整(全局.Combatants, 已过滤的数组(所有玩家(队伍1), 当前数组元素.Is_Living_Boss), 75, 受伤害者和伤害者);
		"Sentry Bastion Players to Bots Damage Decrease"
		开始伤害调整(所有玩家(队伍1), 已过滤的数组(选择英雄的玩家(英雄(堡垒), 队伍2), 处于非初始状态(当前数组元素) && !正在使用终极技能(当前数组元素)), 较小(100, 30 + 7 * 全局.Wave), 受伤害者，伤害者及伤害百分比);
		全局.IV_HVT_Damage_Mods[0] = 上一个伤害调整ID;
		"Bots to Tank Players Damage Increase"
		开始伤害调整(已过滤的数组(全局.Combatants, 数组包含(所有重装英雄, 所用英雄(当前数组元素))), 所有玩家(队伍1), 较大(100, 200 - 10 * 全局.Wave), 受伤害者，伤害者及伤害百分比);
		全局.IV_HVT_Damage_Mods[1] = 上一个伤害调整ID;
	}
}

规则("IV Team 1 Torbjörn: Start Portal Mode, Open (Status 1), Last Breakpoint (2), Set Health to half to remove armor")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		托比昂;
	}

	动作
	{
		全局.IV_Objective_Position = 数组随机取值(从数组中移除(全局.Objective_Spawns, 全局.IV_Objective_Position));
		开始强制设置玩家位置(事件玩家, 全局.IV_Objective_Position, 假);
		取消与环境的移动碰撞(事件玩家, 真);
		设置不可见(事件玩家, 全部);
		设置状态(事件玩家, 无, 无法杀死, 9999);
		事件玩家.Ab_Var_2 = -100;
		设置玩家生命值(事件玩家, 0.500 * 最大生命值(事件玩家));
	}
}

规则("IV Subroutine: Defend Portal, Current Player (Player), Last Breakpoint (2)")
{
	事件
	{
		子程序;
		IV_Defend_Portal;
	}

	动作
	{
		全局.Boss_Spawns_remaining += 全局.Wave >= 5 ? 2 : 1;
		全局.Spawns_remaining = 真;
		事件玩家.Ab_Var_2 = 总计消耗时间;
		事件玩家.Ab_Player = 已过滤的数组(范围内玩家(全局.IV_Objective_Position, 10, 队伍2, 表面), 当前数组元素.Is_Combatant && !具有状态(当前数组元素, 相移) && 在视线内(事件玩家,
			当前数组元素, 敌方屏障阻挡视线));
		For 全局变量(Temp, 0, 数量(事件玩家.Ab_Player), 1);
			施加推力(事件玩家.Ab_Player[全局.Temp], 与此角度的相对方向(与此方向的水平角度(向量(全局.IV_Objective_Position, 事件玩家.Ab_Player[全局.Temp])), -20), 15, 至地图,
				取消相反运动XYZ);
		End;
		全局.Temp = 随机整数(0, 5);
		If(全局.Temp == 5 && 全局.Wave >= 7);
			事件玩家.Ab_Player.Tased_until = 总计消耗时间 + 1;
			播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(亮紫色), 全局.IV_Objective_Position + 1.110 * 上, 10);
		Else If(全局.Temp == 4 && 全局.Wave >= 4);
			设置终极技能充能(事件玩家, 100);
			按下按键(事件玩家, 按钮(终极技能));
			播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(红色), 全局.IV_Objective_Position + 1.110 * 上, 10);
		Else;
			播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(红色), 全局.IV_Objective_Position + 1.110 * 上, 10);
		End;
		播放效果(所有玩家(所有队伍), 爆炸声音, 颜色(白色), 事件玩家, 200);
	}
}

规则("IV Team 1 Torbjörn: Health reaches Breakpoint, Health reaches 1 -> Portal Closing (Status 2)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		托比昂;
	}

	条件
	{
		标准化生命值(事件玩家) <= 0.333;
		生命值(事件玩家) != 0;
	}

	动作
	{
		全局.Money += 全局.Mutators_activated ? 240 : 120;
		设置玩家生命值(事件玩家, 0.333 * 最大生命值(事件玩家));
		调用子程序(IV_Defend_Portal);
		等待直到 (标准化生命值(事件玩家) <= 0.166, 99999);
		全局.Money += 全局.Mutators_activated ? 240 : 120;
		设置玩家生命值(事件玩家, 0.166 * 最大生命值(事件玩家));
		调用子程序(IV_Defend_Portal);
		等待直到 (生命值(事件玩家) == 1, 99999);
		全局.Upgrade_Counter += 1;
		设置受到治疗(所有玩家(队伍2), (全局.GMut_Blood_Moon_Rising ? 50 : 100) + 2 * 取整(全局.Upgrade_Counter * 7 / 3, 下));
		开始持续治疗(所有玩家(队伍2), 无, 1, 10000);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(红色), 全局.IV_Objective_Position + 1.110 * 上, 10);
		播放效果(所有玩家(所有队伍), 爆炸声音, 颜色(白色), 事件玩家, 200);
		大字体信息(所有玩家(所有队伍), 自定义字符串("传送门正在关闭！已获得额外生命值"));
		设置状态(事件玩家, 无, 相移, 5.500);
		全局.IV_Portal_Status = 2;
		全局.Money += 全局.Mutators_activated ? 240 : 120;
		等待(5, 无视条件);
		设置地形消灭者玩家(事件玩家, 事件玩家);
		停止强制设置玩家位置(事件玩家);
		开启与环境的移动碰撞(事件玩家);
		等待(0.250, 无视条件);
		清除状态(事件玩家, 无法杀死);
		传送(事件玩家, 1000 * 下);
		设置不可见(事件玩家, 无);
	}
}

规则("IV Team 1 Slot 6: Portal Closing (Status 2) -> Portal Closed (Status 3)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		栏位 6;
	}

	条件
	{
		全局.Gamemode == 1;
		全局.IV_Portal_Status == 2;
	}

	动作
	{
		If(全局.Wave >= 10);
			全局.Boss_Spawns_remaining += 1;
		End;
		全局.IV_HVT_Objective_Timer = 100;
		持续追踪全局变量(IV_HVT_Objective_Timer, 0, 10, 终点及持续时间);
		等待(8, 无视条件);
		全局.Spawns_remaining = 真;
		等待(1, 无视条件);
		全局.IV_HVT_Spawn_Slot_Six = 真;
		等待(1, 无视条件);
		停止追踪全局变量(IV_HVT_Objective_Timer);
		大字体信息(所有玩家(所有队伍), 自定义字符串("击杀剩下的敌人！"));
		全局.Spawns_remaining = 假;
		全局.Boss_Spawns_remaining = 0;
		全局.IV_Portal_Status = 3;
	}
}

规则("IV Team 1 Torbjörn: Set Breakpoint Damage Reduction")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		托比昂;
	}

	条件
	{
		(事件玩家.Ab_Var_2 + 10 >= 总计消耗时间 || 全局.Boss_Spawns_remaining) == 真;
	}

	动作
	{
		设置受到伤害(事件玩家, 10);
		等待直到 (!(事件玩家.Ab_Var_2 + 10 >= 总计消耗时间 || 全局.Boss_Spawns_remaining), 99999);
		设置受到伤害(事件玩家, 100);
	}
}

规则("IV Team 1 Torbjörn: Torbjörn is Charged")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		托比昂;
	}

	条件
	{
		全局.IV_Portal_Status == 1;
		具有状态(事件玩家, 击晕) == 真;
		相距距离(事件玩家, 全局.IV_Objective_Position) > 2;
	}

	动作
	{
		传送(事件玩家, 全局.IV_Objective_Position);
	}
}

规则("HVT Team 1 Slot 6: HVT subdued fallback")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		栏位 6;
	}

	条件
	{
		全局.Gamemode == 2;
		全局.IV_Portal_Status == 2;
		具有状态(事件玩家, 击晕) == 假;
	}

	动作
	{
		等待(0.250, 当为“假”时中止);
		如条件为“假”则中止;
		While(全局.IV_Portal_Status == 2 && !具有状态(事件玩家, 击晕));
			清除状态(事件玩家, 相移);
			设置状态(事件玩家, 无, 击倒, 9999);
			等待(0.250, 无视条件);
		End;
		If(全局.IV_Portal_Status == 2);
			设置状态(事件玩家, 无, 相移, 9999);
		End;
		如条件为”真“则循环;
	}
}

规则("HVT Team 1 Slot 6: Subdued, check Player in Radius")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		栏位 6;
	}

	条件
	{
		全局.Gamemode == 2;
		全局.IV_Portal_Status == 2;
	}

	动作
	{
		If(对任意为”真“(全局.Combatants, !当前数组元素.Downed_since && !(当前数组元素.Is_invisible % 3) && 相距距离(事件玩家, 矢量(X方向分量(所选位置(当前数组元素)), Y方向分量(所选位置(
			事件玩家)), Z方向分量(所选位置(当前数组元素)))) <= 10 && 绝对值(Y方向分量(所选位置(事件玩家)) - Y方向分量(所选位置(当前数组元素))) <= 5 && 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线)));
			事件玩家.Downed_since = 2;
			全局.IV_HVT_Objective_Timer += 1;
		Else If(全局.HVT_Times_Subdued >= 3);
			事件玩家.Downed_since = 1;
			全局.IV_HVT_Objective_Timer += 0.500;
		Else If(事件玩家.Downed_since > 0);
			事件玩家.Downed_since -= 0.200;
		Else;
			事件玩家.Revive_Timer += 全局.HVT_Times_Subdued == 1 ? 2 : 1;
		End;
		If(全局.IV_HVT_Objective_Timer >= 150);
			清除状态(事件玩家, 击倒);
			清除状态(事件玩家, 相移);
			清除状态(事件玩家, 无敌);
			播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(黄色), 所选位置(事件玩家), 1);
			播放效果(所有玩家(所有队伍), 爆炸声音, 颜色(白色), 所选位置(事件玩家), 200);
			传送(事件玩家, 1000 * 下);
			大字体信息(所有玩家(所有队伍), 自定义字符串("击杀剩下的敌人！"));
			全局.Spawns_remaining = 假;
			全局.Boss_Spawns_remaining = 0;
			全局.IV_Portal_Status = 3;
			全局.IV_HVT_Objective_Timer = 0;
		Else If(事件玩家.Revive_Timer >= 150);
			全局.IV_Portal_Status = 1;
			全局.IV_HVT_Objective_Timer = 0;
			事件玩家.Perk_Pumping_Iron = 0;
			大字体信息(所有玩家(所有队伍), 自定义字符串("高价值目标已被复活！", 事件玩家));
			清除状态(事件玩家, 击倒);
			清除状态(事件玩家, 相移);
			清除状态(事件玩家, 无敌);
		End;
		等待(0.200, 无视条件);
		如条件为”真“则循环;
	}
}

规则("HVT Team 1 Slot 6: Set / Unset Is Assaulting")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		栏位 6;
	}

	条件
	{
		全局.Gamemode == 2;
		事件玩家.Is_assaulting != 事件玩家.Is_Target_in_LOS;
	}

	动作
	{
		等待(事件玩家.Is_Target_in_LOS ? 4 : 2, 当为“假”时中止);
		如条件为“假”则中止;
		事件玩家.Is_assaulting = !事件玩家.Is_assaulting;
	}
}

规则("HVT Team 1 Slot 6: Call Reinforcements")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		栏位 6;
	}

	条件
	{
		全局.Gamemode == 2;
		全局.IV_Portal_Status == 1;
		标准化生命值(事件玩家) > 0.500;
		生命值(事件玩家) != 0;
	}

	动作
	{
		等待直到 (标准化生命值(事件玩家) <= 0.500 || 全局.IV_Portal_Status == 2, 99999);
		播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(红色), 事件玩家, 1);
		全局.HVT_Call_Reinforcements1 = 总计消耗时间 + 5;
		设置受到伤害(事件玩家, 事件玩家.Is_Living_Boss ? 7.500 : (所用英雄(事件玩家) == 英雄(奥丽莎) || 所用英雄(事件玩家) == 英雄(西格玛) ? 2.500 : 1));
		等待(1, 无视条件);
		全局.Spawns_remaining = 真;
		全局.Boss_Spawns_remaining += 1;
		等待(4, 无视条件);
		设置受到伤害(事件玩家, 事件玩家.Is_Living_Boss ? 75 : (所用英雄(事件玩家) == 英雄(奥丽莎) || 所用英雄(事件玩家) == 英雄(西格玛) ? 25 : 10));
		等待直到 (全局.IV_Portal_Status == 2, 99999);
	}
}

规则("HVT Team 1 Slot 6: Capture Breakpoints")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		栏位 6;
	}

	条件
	{
		全局.Gamemode == 2;
		全局.IV_Portal_Status == 2;
	}

	动作
	{
		全局.Upgrade_Counter += 1;
		设置受到治疗(所有玩家(队伍2), (全局.GMut_Blood_Moon_Rising ? 50 : 100) + 2 * 取整(全局.Upgrade_Counter * 7 / 3, 下));
		开始持续治疗(所有玩家(队伍2), 无, 1, 10000);
		全局.Money += 全局.Mutators_activated ? 240 : 120;
		全局.Boss_Spawns_remaining += 全局.Wave >= 5 ? 2 : 1;
		全局.Spawns_remaining = 真;
		等待直到 (全局.IV_HVT_Objective_Timer >= 75, 99999);
		全局.Money += 全局.Mutators_activated ? 240 : 120;
		全局.Boss_Spawns_remaining += 全局.Wave >= 5 ? 2 : 1;
		全局.Spawns_remaining = 真;
		等待直到 (全局.IV_HVT_Objective_Timer >= 140, 99999);
		全局.Spawns_remaining = 真;
		等待直到 (全局.IV_Portal_Status == 3, 99999);
		全局.Money += 全局.Mutators_activated ? 240 : 120;
	}
}

规则("Rule 212")
{
	事件
	{
		持续 - 全局;
	}
}

规则("Init when spawn")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	动作
	{
		创建HUD文本(已过滤的数组(事件玩家, 当前数组元素.Talent_Active_1 == 真), 事件玩家.Talent_Text123_456[1], 事件玩家.Talent_Text123_456[2],
			事件玩家.Talent_Text123_456[3], 顶部, 全局.Gamemode ? -2 : 150, 颜色(灰绿色), 颜色(橙色), 颜色(黄色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(事件玩家, 当前数组元素.Talent_Active_2 == 真), 事件玩家.Talent_Text123_456[4], 事件玩家.Talent_Text123_456[5],
			事件玩家.Talent_Text123_456[6], 顶部, 全局.Gamemode ? -1.500 : 151, 颜色(灰绿色), 颜色(橙色), 颜色(黄色), 可见和字符串, 默认可见度);
		事件玩家.Hero_Of = 所用英雄(事件玩家);
		事件玩家.Damage_Received = 100;
		事件玩家.Damage_Dealt = 100;
		事件玩家.Move_Speed = 100;
		事件玩家.Max_HP = 100;
		事件玩家.Healing_Dealt = 100;
		事件玩家.Damage_Dealt[真] = 100;
		事件玩家.Damage_Received[真] = 100;
		事件玩家.Move_Speed[真] = 100;
		事件玩家.Healing_Dealt[真] = 100;
		事件玩家.Max_HP[真] = 100;
		事件玩家.RealSpawn = 真;
	}
}

规则("[Hero Swap]")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) != 事件玩家.Hero_Of;
	}

	动作
	{
		事件玩家.RealSpawn = 假;
		事件玩家.Hero_Of = 所用英雄(事件玩家);
		While(事件玩家.Effects != 空数组);
			消除效果(首个(事件玩家.Effects));
			修改玩家变量(事件玩家, Effects, 根据索引从数组中移除, 0);
			等待(0.016, 无视条件);
		End;
		While(事件玩家.HP_Pool != 空数组);
			移除玩家的生命池(首个(事件玩家.HP_Pool));
			修改玩家变量(事件玩家, HP_Pool, 根据索引从数组中移除, 0);
			等待(0.016, 无视条件);
		End;
		While(事件玩家.Modification_Damage != 空数组);
			停止伤害调整(首个(事件玩家.Modification_Damage));
			修改玩家变量(事件玩家, Modification_Damage, 根据索引从数组中移除, 0);
			等待(0.016, 无视条件);
		End;
		停止追踪玩家变量(事件玩家, Gen_Resource);
		调用子程序(After_Buying_Ability);
		停止调整障碍大小(事件玩家);
		事件玩家.RealSpawn = 真;
	}
}

规则("Team 2: Perk - Nimble")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.CPerk_Nimble == 真;
	}

	动作
	{
		事件玩家.Move_Speed *= 1.300;
		开始持续治疗(事件玩家, 事件玩家, 9999, 25);
		事件玩家.HealOvertime_ID[1] = 上一个持续治疗效果ID;
		等待直到 (数量(已过滤的数组(所有存活玩家(对方队伍(所在队伍(事件玩家))), 在视线内(当前数组元素, 事件玩家, 屏障不会阻挡视线))) > 0, 99999);
		停止持续治疗(事件玩家.HealOvertime_ID[1]);
		等待(0.250, 无视条件);
		事件玩家.Move_Speed /= 1.300;
		等待直到 (数量(已过滤的数组(所有存活玩家(对方队伍(所在队伍(事件玩家))), 在视线内(当前数组元素, 事件玩家, 屏障不会阻挡视线))) <= 0, 99999);
		等待(0.250, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Damage Automater")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Damage_Dealt[真] != 事件玩家.Damage_Dealt[假];
	}

	动作
	{
		事件玩家.Damage_Dealt[真] = 事件玩家.Damage_Dealt[假];
		设置造成伤害(事件玩家, 事件玩家.Damage_Dealt[真]);
	}
}

规则("Resistance Automater")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Damage_Received[真] != 事件玩家.Damage_Received[假];
	}

	动作
	{
		事件玩家.Damage_Received[真] = 事件玩家.Damage_Received[假];
		设置受到伤害(事件玩家, 事件玩家.Damage_Received[真]);
	}
}

规则("Speed Automater")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Move_Speed[真] != 事件玩家.Move_Speed[假];
	}

	动作
	{
		事件玩家.Move_Speed[真] = 事件玩家.Move_Speed[假];
		设置移动速度(事件玩家, 事件玩家.Move_Speed[真]);
	}
}

规则("Healing Automater")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Healing_Dealt[真] != 事件玩家.Healing_Dealt[假];
	}

	动作
	{
		事件玩家.Healing_Dealt[真] = 事件玩家.Healing_Dealt[假];
		设置造成治疗(事件玩家, 事件玩家.Healing_Dealt[真]);
	}
}

规则("HP Automater")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Max_HP[真] != 事件玩家.Max_HP[假];
	}

	动作
	{
		事件玩家.Max_HP[真] = 事件玩家.Max_HP[假];
		设置最大生命值(事件玩家, 事件玩家.Max_HP[真]);
	}
}

规则("[Ana]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		安娜;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(安娜), 按钮(技能1));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("魔鬼压床");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("被睡的敌人无法被伤害唤醒");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(安娜), 按钮(技能2));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("多重手雷");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("安娜将投掷出多枚生化手雷");
	}
}

规则("[Ashe]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		艾什;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(艾什), 按钮(技能2));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("火焰之女");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("在燃烧时，获得治疗、更快的移速并造成更多伤害");
		事件玩家.Talent_Text123_456[4] = 图标字符串(骷髅);
		事件玩家.Talent_Text123_456[5] = 自定义字符串("嘲讽");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("伤害一名瞄准你的敌人可额外造成100%的伤害");
	}
}

规则("[Bastion]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		堡垒;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(回声), 按钮(辅助攻击模式));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("爆裂子弹");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("哨卫模式下的子弹具有爆炸效果");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(秩序之光), 按钮(技能1));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("特斯拉");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("时不时的对一名敌人自动发射强大的肩载激光");
	}
}

规则("[Baptiste]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		巴蒂斯特;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 图标字符串(剧毒);
		事件玩家.Talent_Text123_456[2] = 自定义字符串("腐蚀");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("愈合冲击现在也可以毒害并削弱附近的敌人");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(巴蒂斯特), 按钮(技能2));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("突破");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("维生力场可维持的生命值增加至100%，场内的队友将立刻获得大招");
	}
}

规则("[Brigitte]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		布丽吉塔;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(布丽吉塔), 按钮(技能1));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("重铁");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("以飞锤击中的敌人将会被定身于地面");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(布丽吉塔), 按钮(终极技能));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("碎盾之勇");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("当你的屏障碎裂后获得生命、伤害和速度的效果加强");
	}
}

规则("[D.Va]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		D.Va;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(D.Va), 按钮(辅助攻击模式));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("电网");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("防御矩阵将会对覆盖到的敌人造成伤害并定身");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(D.Va), 按钮(技能1));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("火焰流星");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("当推进器结束后，点燃附近的敌人，效果强度取决于使用时长");
	}
}

规则("[Doomfist]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		末日铁拳;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(法老之鹰), 按钮(跳跃));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("相位传动");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("在使用技能时免疫伤害");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(末日铁拳), 按钮(终极技能));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("灼烧");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("裂地猛击将会点燃地面并燃烧位于其上的敌人");
	}
}

规则("[Echo]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		回声;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(回声), 按钮(技能2));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("聚焦镜片");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("聚焦光线的增进伤害从90%生命值开始，取代之前的50%");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(回声), 按钮(辅助攻击模式));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("粘连不息");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("每次发射的粘滞炸​弹数量将会增加");
	}
}

规则("[Genji]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(源氏), 按钮(技能1));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("龙咬");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("“影”将会毒害敌人，并从毒造成的伤害中获得治疗");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(源氏), 按钮(终极技能));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("恶龙之息");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("龙刃将弹射出大型爆炸能量波");
	}
}

规则("[Hanzo]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		半藏;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 图标字符串(箭矢);
		事件玩家.Talent_Text123_456[2] = 自定义字符串("暴风骤雨");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("被半藏消灭的敌人将产生一片雷云");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(半藏), 按钮(技能2));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("飞箭穿心");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("“岚”将造成更多伤害并眩晕和击退敌人");
	}
}

规则("[Junkrat]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		狂鼠;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 图标字符串(火焰);
		事件玩家.Talent_Text123_456[2] = 自定义字符串("纵火犯");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("爆炸攻击将产生燃烧伤害");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(狂鼠), 按钮(技能2));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("超短引线");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("捕兽夹将在触发后产生大型爆炸");
	}
}

规则("[Lucio]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卢西奥;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(卢西奥), 按钮(辅助攻击模式));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("治疗声波");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("音障现在将会恢复所有队友的30%的最大生命值");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(卢西奥), 按钮(技能1));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("反向强音");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("强音将会对敌人造成当前音乐效果的反向效果");
	}
}

规则("[McCree]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卡西迪;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(卡西迪), 按钮(技能2));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("恐慌");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("***将会使敌人进入恐惧状态，并可对处于恐惧状态的敌人造成额外120%的伤害");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(卡西迪), 按钮(终极技能));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("精准计时");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("神射手可造成更多伤害并击倒敌人");
	}
}

规则("[Mei]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		美;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(美), 按钮(终极技能));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("打个寒颤");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("在急冻效果结束后立即冰冻周围的敌人");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(美), 按钮(技能2));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("冰雪能力");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("当使用冰墙后，冰锥将会冻住敌人并造成更多伤害");
	}
}

规则("[Mercy]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		天使;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(天使), 按钮(技能2));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("奇迹现临");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("由友方天使复活的队友可获得无敌和双倍伤害的效果");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(天使), 按钮(终极技能));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("极光飞舞");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("激活女武神后，对敌人隐身并获得各式的增强效果");
	}
}

规则("[Moira]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		莫伊拉;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(莫伊拉), 按钮(辅助攻击模式));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("双重疗效");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("生化之握的治疗将会伤害敌人并推走敌人");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(莫伊拉), 按钮(技能2));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("显著疗效");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("生化之球将获得额外三倍的效果");
	}
}

规则("[Orisa]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		奥丽莎;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(奥丽莎), 按钮(技能1));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("不可撼动");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("在强固防御技能阶段，可免疫伤害并转化50%的伤害至治愈效果");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(奥丽莎), 按钮(辅助攻击模式));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("难阻之力");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("站住别动变得更大并可推走敌人。触发后，会发生爆炸");
	}
}

规则("[Pharah]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		法老之鹰;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(法老之鹰), 按钮(技能2));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("头疼欲裂");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("震荡冲击将眩晕敌人并伤害敌人的25%生命值");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(法老之鹰), 按钮(技能1));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("雷霆之鸟");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("获得150护盾并对屏障和物品造成四倍伤害");
	}
}

规则("[Reaper]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		死神;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(死神), 按钮(技能1));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("护卫克星");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("死神将会对护盾和护甲造成两倍伤害");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(死神), 按钮(终极技能));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("幽影");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("幽灵形态下对面对你的敌人施加恐惧效果");
	}
}

规则("[Reinhardt]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		莱因哈特;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(莱因哈特), 按钮(技能2));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("爆裂火焰");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("烈焰打击将会在命中敌人后爆炸，并使敌人着火");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(莱因哈特), 按钮(终极技能));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("地震中心");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("裂地猛击将向四周散发");
	}
}

规则("[Roadhog]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		路霸;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 图标字符串(剧毒);
		事件玩家.Talent_Text123_456[2] = 自定义字符串("威猛");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("路霸将持续对附近的敌人造成伤害");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(路霸), 按钮(技能1));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("锈锚");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("链钩可造成更多伤害，消灭敌人可重置其冷却");
	}
}

规则("[Sigma]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		西格玛;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(西格玛), 按钮(技能1));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("重力井");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("使用动能俘获技能时获得无敌状态并强迫敌人对动能俘获技能进行射击");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(西格玛), 按钮(终极技能));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("操纵重力");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("引力乱流将造成75%的伤害，取代先前的50%");
	}
}

规则("[Soldier: 76]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		士兵：76;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(法老之鹰), 按钮(终极技能));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("三重威胁");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("发射螺旋飞弹将再次发射两次飞弹");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(士兵：76), 按钮(技能1));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("大力撞肩");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("奔跑至敌人可对其造成伤害并撞倒敌人");
	}
}

规则("[Sombra]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		黑影;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(黑影), 按钮(辅助攻击模式));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("恶意程序");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("被入侵或恐惧中的敌人将额外承受100%的伤害");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(黑影), 按钮(终极技能));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("故̟̦͕̣̳̥̅̇͌̒̆障̬̭̰̜̖̗͈͇̯̪̭͑̂͆͒̋̾̋");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("电磁脉冲将对更大的区域造成效果");
	}
}

规则("[Symmetra]")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		秩序之光;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 图标字符串(箭矢);
		事件玩家.Talent_Text123_456[2] = 自定义字符串("高伏电压");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("被秩序之光消灭的敌人将会爆炸并伤害其他敌人");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(秩序之光), 按钮(终极技能));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("能量源");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("当光子屏障被激活后，所有玩家都将重生生命值并获得大招");
	}
}

规则("[Torbjorn]")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		托比昂;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(托比昂), 按钮(技能2));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("岩浆护甲");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("在过载时对敌人造成伤害可累积增加护甲");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(托比昂), 按钮(终极技能));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("粘滞岩浆");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("踩中熔渣池的敌人无法移动");
	}
}

规则("[Tracer]")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		猎空;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(猎空), 按钮(技能2));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("旋涡");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("闪回将会把敌人拉向至激活的位置并施加定身状态效果");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(猎空), 按钮(终极技能));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("连锁反应");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("脉冲炸弹会对被伤害到的敌人造成连环爆炸的效果");
	}
}

规则("[Widowmaker]")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		黑百合;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(黑百合), 按钮(终极技能));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("死亡之吻");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("开镜暴击低于30%血量的敌人将会使他们爆炸并立即死亡");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(黑百合), 按钮(技能2));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("瘟疫");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("被剧毒**命中的敌人将释放毒性冲击，并将以造成的伤害获得治愈效果");
	}
}

规则("[Winston]")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		温斯顿;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(温斯顿), 按钮(技能2));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("爆炸屏障");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("屏障投射器会对区域内部敌人造成伤害");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(温斯顿), 按钮(终极技能));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("下一迭代");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("在原始暴怒时消灭的敌人将额外增加15%的终极技能充能");
	}
}

规则("[Wrecking Ball]")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		破坏球;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(破坏球), 按钮(终极技能));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("镜像伤害");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("对附近的敌人造成100%的受到伤害");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(破坏球), 按钮(技能2));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("扰乱");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("感应护盾会伤害并入侵附近的敌人");
	}
}

规则("[Zarya]")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		查莉娅;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(查莉娅), 按钮(技能1));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("增进");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("生命和护盾都增加了50%，护盾面积也增加至双倍");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(回声), 按钮(技能2));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("火焰能源");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("主开火将造成燃烧伤害，持续至敌人死亡为止");
	}
}

规则("[Zenyatta]")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		禅雅塔;
	}

	动作
	{
		事件玩家.Talent_Text123_456[1] = 技能图标字符串(英雄(巴蒂斯特), 按钮(技能2));
		事件玩家.Talent_Text123_456[2] = 自定义字符串("活力");
		事件玩家.Talent_Text123_456[3] = 自定义字符串("在“谐”效果下的队友可免疫伤害");
		事件玩家.Talent_Text123_456[4] = 技能图标字符串(英雄(禅雅塔), 按钮(终极技能));
		事件玩家.Talent_Text123_456[5] = 自定义字符串("完美平衡");
		事件玩家.Talent_Text123_456[6] = 自定义字符串("“圣”也将会对大范围内的敌人造成伤害");
	}
}

规则("Damage Dealt normalizer")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Damage_Dealt < 100;
	}

	动作
	{
		事件玩家.Damage_Dealt = 100;
	}
}

规则("Healing Dealt normalizer")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Healing_Dealt < 100;
	}

	动作
	{
		事件玩家.Healing_Dealt = 100;
	}
}

规则("Max Health normalizer")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Max_HP < 100;
	}

	动作
	{
		事件玩家.Max_HP = 100;
	}
}

禁用 规则("Talents")
{
	事件
	{
		持续 - 全局;
	}
}

规则("Team 1: Wrecking Ball explode when in contact")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		破坏球;
	}

	条件
	{
		相距距离(事件玩家, 事件玩家.Target) <= 4;
		在视线内(事件玩家, 事件玩家.Target, 屏障不会阻挡视线) == 真;
		事件玩家.Is_Target_in_LOS == 真;
		具有状态(事件玩家, 被入侵) == 假;
		具有状态(事件玩家, 沉睡) == 假;
		具有状态(事件玩家, 击倒) == 假;
		存活(事件玩家) == 真;
	}

	动作
	{
		设置状态(事件玩家, 无, 定身, 0.500);
		播放效果(所有玩家(所有队伍), 有害选择效果 , 颜色(红色), 事件玩家, 6);
		等待(0.500, 当为“假”时中止);
		伤害(范围内玩家(事件玩家, 6, 对方队伍(所在队伍(事件玩家)), 表面及全部屏障), 事件玩家, 300);
		击杀(事件玩家, 事件玩家);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(红色), 事件玩家, 6);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(红色), 事件玩家, 12);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(红色), 事件玩家, 6);
		播放效果(所有玩家(所有队伍), 爆炸声音, 颜色(红色), 事件玩家, 150);
	}
}

规则("Team 1: Wrecking Ball stay in ball form")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		破坏球;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 假;
	}

	动作
	{
		按下按键(事件玩家, 按钮(技能1));
		等待(0.250, 无视条件);
		如条件为”真“则循环;
	}
}

规则("IV Torbjorn: Using ultimate and shoot")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		托比昂;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		停止朝向(事件玩家);
		While(正在使用终极技能(事件玩家));
			按下按键(事件玩家, 按钮(主要攻击模式));
			设置朝向(事件玩家, 方向(眼睛位置(事件玩家), 矢量(随机整数(-500, 500), 随机整数(-500, 500), 随机整数(-500, 500))), 至地图);
			等待(0.250, 无视条件);
		End;
	}
}

规则("Team 1 Pharah: Shoot")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		法老之鹰;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		绝对值(水平方向夹角(事件玩家, 事件玩家.Target)) <= 5;
	}

	动作
	{
		If(相距距离(事件玩家, 事件玩家.Target) > 5);
			开始按下按钮(事件玩家, 按钮(主要攻击模式));
			等待(随机实数(0.400, 0.600), 无视条件);
			停止按下按钮(事件玩家, 按钮(主要攻击模式));
		Else;
			按下按键(事件玩家, 按钮(技能2));
		End;
		等待(随机实数(0.800, 1.200), 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Pharah: Jet fuel")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		法老之鹰;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
	}

	动作
	{
		按下按键(事件玩家, 按钮(技能1));
		While(事件玩家.Is_Target_in_LOS);
			开始按下按钮(事件玩家, 按钮(跳跃));
			等待(随机实数(0.500, 0.800), 无视条件);
			停止按下按钮(事件玩家, 按钮(跳跃));
			等待(随机实数(0.300, 0.500), 无视条件);
		End;
	}
}

规则("Team 1 Mei: Shoot")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		美;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		绝对值(水平方向夹角(事件玩家, 事件玩家.Target)) <= 5;
		正在使用技能 1(事件玩家) == 假;
		正在使用技能 2(事件玩家) == 假;
	}

	动作
	{
		If(相距距离(事件玩家, 事件玩家.Target) > 8);
			开始按下按钮(事件玩家, 按钮(辅助攻击模式));
			等待(随机实数(0.400, 0.600), 无视条件);
			停止按下按钮(事件玩家, 按钮(辅助攻击模式));
		Else;
			开始按下按钮(事件玩家, 按钮(主要攻击模式));
			等待直到 (相距距离(事件玩家, 事件玩家.Target) > 8, 99999);
			停止按下按钮(事件玩家, 按钮(主要攻击模式));
		End;
		等待(随机实数(0.800, 1.200), 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Mei: Cryo Freeze, Ice Wall if Extended is active")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		美;
	}

	条件
	{
		标准化生命值(事件玩家) <= 0.500;
	}

	动作
	{
		If(随机整数(1, 2) == 1);
			按下按键(事件玩家, 按钮(技能1));
		Else If(事件玩家.Is_Target_in_LOS);
			按下按键(事件玩家, 按钮(技能2));
		End;
	}
}

规则("Team 1 Mei: Ice Wall deploy")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		美;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		设置朝向(事件玩家, 下, 至地图);
		按下按键(事件玩家, 按钮(主要攻击模式));
	}
}

规则("Team 1 Mei: Blizzar d")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		美;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		数量(正在使用终极技能(选择英雄的玩家(英雄(美), 队伍1))) == 假;
		(全局.Wave >= (全局.Gamemode ? 13 : 19) || (全局.Mut_Last_Stand && (全局.Gamemode ? 全局.IV_Portal_Status == 3 : 全局.Spawns_remaining <= 0)))
			== 真;
		正在使用技能 1(事件玩家) == 假;
		正在使用技能 2(事件玩家) == 假;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > 20);
		设置终极技能充能(事件玩家, 100);
		按下按键(事件玩家, 按钮(终极技能));
		等待(全局.Mut_Adrenaline ? 14 : 28, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Bad Mutator 17: Doomfist ultimate mechanics")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		末日铁拳;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 假;
		存活(事件玩家) == 真;
		事件玩家.Is_Target_in_LOS == 假;
	}

	动作
	{
		等待(0.250, 无视条件);
		传送(事件玩家, 矢量(0, 10000, 0));
		设置终极技能充能(事件玩家, 100);
		等待(0.250, 无视条件);
		按下按键(事件玩家, 按钮(终极技能));
		如条件为”真“则循环;
		等待(0.500, 无视条件);
		传送(事件玩家, 事件玩家.Target);
		等待(随机实数(1, 4), 无视条件);
		等待直到 (相距距离(事件玩家, 事件玩家.Target) <= 3, 99999);
		按下按键(事件玩家, 按钮(主要攻击模式));
		等待直到 (终极技能充能百分比(事件玩家) == 0, 99999);
		传送(事件玩家, 矢量(0, -1000, 0));
		如条件为”真“则循环;
	}
}

规则("Doomfist Failsafe 2")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		末日铁拳;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 假;
		存活(事件玩家) == 真;
		事件玩家.Is_Target_in_LOS == 真;
	}

	动作
	{
		等待(2, 当为“假”时中止);
		传送(事件玩家, 矢量(0, -10000, 0));
	}
}

规则("Orisa: Unstoppable Force")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		奥丽莎;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		事件玩家.Gen_Direction = 面朝方向(事件玩家);
		事件玩家.Gen_Active = 真;
		创建效果(所有玩家(所有队伍), 球体, 颜色(绿色), 事件玩家.Gen_Projectile1, 4, 可见，位置和半径);
		事件玩家.Effects[1] = 最后创建的实体;
		事件玩家.Gen_Projectile1 = 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 0.500;
		事件玩家.Gen_End = 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 1000, 无, 所有玩家(所有队伍), 假);
		追踪玩家变量频率(事件玩家, Gen_Projectile1, 事件玩家.Gen_End, 25, 速率及最终值);
		等待(0.250, 无视条件);
		等待直到 ((!事件玩家.Gen_Available && 按钮被按下(事件玩家, 按钮(辅助攻击模式))) || (事件玩家.Gen_Projectile1 == 事件玩家.Gen_End), 99999);
		停止追踪玩家变量(事件玩家, Gen_Projectile1);
		等待(0.500, 无视条件);
		伤害(范围内玩家(事件玩家.Gen_Projectile1, 5, 对方队伍(所在队伍(事件玩家)), 关闭), 事件玩家, 100);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(灰绿色), 事件玩家.Gen_Projectile1, 5);
		消除效果(事件玩家.Effects[1]);
		事件玩家.Gen_Active = 假;
	}
}

规则("Orisa: Availability for Halt!")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		奥丽莎;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		事件玩家.Gen_Available = 真;
		等待直到 (!按钮被按下(事件玩家, 按钮(辅助攻击模式)), 99999);
		事件玩家.Gen_Available = 假;
	}
}

规则("Orisa: Drag effect")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		奥丽莎;
	}

	条件
	{
		事件玩家.Gen_Active == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		施加推力(范围内玩家(事件玩家.Gen_Projectile1, 5, 对方队伍(所在队伍(事件玩家)), 表面), 方向(存活(事件玩家) ? 范围内玩家(事件玩家.Gen_Projectile1, 5, 对方队伍(所在队伍(事件玩家)), 表面)
			: 空数组, 事件玩家.Gen_Projectile1), 8, 至地图, 取消相反运动);
		施加推力(范围内玩家(事件玩家.Gen_Projectile1, 5, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家.Gen_Direction, 15, 至地图, 取消相反运动);
		施加推力(范围内玩家(事件玩家.Gen_Projectile1, 5, 对方队伍(所在队伍(事件玩家)), 表面), 上, 5, 至玩家, 取消相反运动);
		等待(0.200, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Orisa: Immoveable Object - Reduce dmg")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		奥丽莎;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		事件玩家.Damage_Received *= 0.003;
		设置受到伤害(事件玩家, 事件玩家.Damage_Received);
		等待直到 (!正在使用技能 1(事件玩家), 99999);
		事件玩家.Damage_Received /= 0.003;
		设置受到伤害(事件玩家, 事件玩家.Damage_Received);
	}
}

规则("Orisa: Immovable Object - Healing")
{
	事件
	{
		玩家受到伤害;
		队伍2;
		奥丽莎;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		治疗(事件玩家, 无, 事件伤害 * 3);
	}
}

规则("Reaper: Waste Not Want Not")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		死神;
	}

	条件
	{
		事件玩家.Talent_Active_1 == 真;
		事件玩家.RealSpawn == 真;
	}

	动作
	{
		开始伤害调整(已过滤的数组(所有玩家(对方队伍(所在队伍(事件玩家))), 类型的生命值(当前数组元素, 护甲) > 假 || 类型的生命值(当前数组元素, 护盾) > 假), 事件玩家, 200, 受伤害者，伤害者及伤害百分比);
		事件玩家.Modification_Damage[1] = 上一个伤害调整ID;
		等待直到 (!事件玩家.Talent_Active_1 || 所用英雄(事件玩家) != 英雄(死神), 99999);
		停止伤害调整(事件玩家.Modification_Damage[1]);
	}
}

规则("Reaper: Loom")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		死神;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		设置状态(已过滤的数组(视角中的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)), 45), 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线)), 事件玩家, 被入侵, 1.500);
		设置状态(已过滤的数组(视角中的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)), 45), 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线)), 事件玩家, 定身, 1.500);
		伤害(已过滤的数组(视角中的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)), 45), 在视线内(当前数组元素, 事件玩家, 屏障不会阻挡视线)), 事件玩家, 45);
	}
}

规则("Ashe: Firebourne")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		艾什;
	}

	条件
	{
		具有状态(事件玩家, 点燃) == 真;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		事件玩家.Damage_Dealt *= 1.500;
		事件玩家.Move_Speed *= 1.500;
		"eventPlayer.setDamageDealt(eventPlayer.Damage_Dealt)\neventPlayer.setMoveSpeed(eventPlayer.Move_Speed)"
		开始持续治疗(事件玩家, 事件玩家, 5, 40);
		等待直到 (!具有状态(事件玩家, 点燃), 99999);
		事件玩家.Damage_Dealt /= 1.500;
		事件玩家.Move_Speed /= 1.500;
	}
}

规则("Ashe: Taunt")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		艾什;
	}

	条件
	{
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		开始伤害调整(已过滤的数组(所有玩家(对方队伍(所在队伍(事件玩家))), 当前数组元素.Target == 事件玩家), 事件玩家, 200, 受伤害者，伤害者及伤害百分比);
		事件玩家.Modification_Damage[1] = 上一个伤害调整ID;
		等待直到 (!事件玩家.Talent_Active_2, 99999);
		停止伤害调整(事件玩家.Modification_Damage[1]);
	}
}

规则("Tracer: Vortex")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		猎空;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		伤害(范围内玩家(事件玩家, 12, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 10);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(红色), 所选位置(事件玩家), 24);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(黄色), 所选位置(事件玩家), 18);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(绿色), 所选位置(事件玩家), 12);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(水绿色), 所选位置(事件玩家), 6);
		设置地形消灭者玩家(范围内玩家(事件玩家, 8, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家);
	}
}

规则("Tracer: Vortex 2")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(猎空);
		正在使用技能 2(攻击方) == 真;
		事件技能 == 无;
		事件伤害 <= 20;
		攻击方.Talent_Active_1 == 真;
	}

	动作
	{
		施加推力(事件玩家, 上, 5, 至地图, 取消相反运动);
		等待(0.100, 无视条件);
		施加推力(事件玩家, 方向(事件玩家, 攻击方), 相距距离(事件玩家, 攻击方) * 3.500, 至地图, 取消相反运动);
		设置状态(事件玩家, 无, 定身, 1.300);
	}
}

规则("Tracer: Chain Reaction")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对任意为”真“(已过滤的数组(所有玩家(所在队伍(事件玩家)), 当前数组元素.Chain_Reaction_On), 相距距离(事件玩家, 当前数组元素) <= 8 && 真) == 真;
		事件玩家.Chain_Reaction_Immune == 假;
		事件玩家.Chain_Reaction_On == 假;
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(0.250, 无视条件);
		事件玩家.Chain_Reaction_On = 真;
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(天蓝色), 事件玩家, 3);
	}
}

规则("Tracer: Chain Reaction 2")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.Chain_Reaction_On == 真;
	}

	动作
	{
		等待(0.100, 无视条件);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(水绿色), 事件玩家, 3);
		伤害(事件玩家, 选择英雄的玩家(英雄(猎空), 对方队伍(所在队伍(事件玩家))), 200);
		等待(0.500, 无视条件);
		事件玩家.Chain_Reaction_Immune = 真;
		事件玩家.Chain_Reaction_On = 假;
		等待(2, 无视条件);
		事件玩家.Chain_Reaction_Immune = 假;
	}
}

规则("Tracer: Chain Reaction 3")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		猎空;
	}

	条件
	{
		事件技能 == 按钮(终极技能);
		事件伤害 > 20;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		被攻击方.Chain_Reaction_On = 真;
	}
}

规则("Sigma: Gravity Well")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		西格玛;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		伤害(已过滤的数组(视角中的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)), 90), 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线)), 事件玩家, 25);
		设置状态(已过滤的数组(视角中的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)), 90), 在视线内(当前数组元素, 事件玩家, 屏障不会阻挡视线)), 无, 定身, 2);
		已过滤的数组(视角中的玩家(事件玩家, 队伍1, 90), 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线)).Target = 事件玩家;
		设置状态(事件玩家, 无, 无敌, 1);
		播放效果(事件玩家, 环状爆炸, 颜色(蓝色), 眼睛位置(事件玩家), 50);
		等待(0.300, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Sigma: Gravity Channels")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		西格玛;
	}

	条件
	{
		事件玩家.Talent_Active_2 == 真;
		事件玩家.RealSpawn == 真;
	}

	动作
	{
		开始伤害调整(已过滤的数组(所有玩家(所有队伍), 正在使用终极技能(事件玩家)), 事件玩家, 150, 受伤害者，伤害者及伤害百分比);
		事件玩家.Modification_Damage[1] = 上一个伤害调整ID;
		等待直到 (!事件玩家.Talent_Active_2, 99999);
		停止伤害调整(事件玩家.Modification_Damage[1]);
	}
}

规则("Mercy: Aurora")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		天使;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		事件玩家.Is_invisible = 3;
		事件玩家.Damage_Dealt *= 2;
		事件玩家.Healing_Dealt *= 2;
		事件玩家.Move_Speed *= 1.400;
		创建效果(事件玩家, 火花, 颜色(白色), 事件玩家, 1, 可见，位置和半径);
		事件玩家.Effects[1] = 最后创建的实体;
		等待直到 (!正在使用终极技能(事件玩家), 16);
		事件玩家.Is_invisible = 0;
		事件玩家.Damage_Dealt /= 2;
		事件玩家.Healing_Dealt /= 2;
		事件玩家.Move_Speed /= 1.400;
		消除效果(事件玩家.Effects[1]);
	}
}

规则("Echo: Focusing Optics")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		回声;
	}

	条件
	{
		事件技能 == 按钮(技能2);
		事件玩家.Talent_Active_1 == 真;
		标准化生命值(被攻击方) > 0.500;
		标准化生命值(被攻击方) <= 0.900;
		正在人格复制(事件玩家) == 假;
	}

	动作
	{
		伤害(被攻击方, 事件玩家, 事件伤害 * 3);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(紫色), 被攻击方, 0.500);
	}
}

规则("Echo: Streamline")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		回声;
	}

	条件
	{
		事件玩家.Talent_Active_2 == 真;
		正在使用辅助武器(事件玩家) == 真;
		正在人格复制(事件玩家) == 假;
	}

	动作
	{
		等待(0.700, 当为“假”时中止);
		取消主要动作(事件玩家);
	}
}

规则("Echo: Streamline")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		回声;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
		正在人格复制(事件玩家) == 假;
	}

	动作
	{
		设置弹道速度(事件玩家, 100);
		等待(0.150, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Bastion: Bomblets")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		正在使用主要武器(事件玩家) == 真;
		处于非初始状态(事件玩家) == 真;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 有害选择效果 , 颜色(橙色), 无 + 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 60, 所有存活玩家(对方队伍(所在队伍(事件玩家))), 所有玩家(所在队伍(事件玩家)),
			真), 2);
		伤害(范围内玩家(射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 60, 所有存活玩家(对方队伍(所在队伍(事件玩家))), 所有玩家(所在队伍(事件玩家)), 真), 2, 对方队伍(所在队伍(事件玩家)), 表面),
			事件玩家, 12);
		等待(0.100, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Bastion: Taser - Loop damage")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		对任意为”真“(距离最近的玩家(事件玩家, 对方队伍(所在队伍(事件玩家))), 存活(当前数组元素) && 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线) && !具有状态(当前数组元素, 相移) && 相距距离(事件玩家, 当前数组元素)
			<= 25) == 真;
		存活(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 爆炸声音, 颜色(白色), 事件玩家.Gen_Player, 80);
		播放效果(所有玩家(所有队伍), 有害选择效果 , 颜色(水绿色), 事件玩家.Gen_Player, 1);
		事件玩家.Gen_Player = 已过滤的数组(距离最近的玩家(事件玩家, 对方队伍(所在队伍(事件玩家))), 存活(当前数组元素) && 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线) && !具有状态(当前数组元素, 相移) && 相距距离(
			事件玩家, 当前数组元素) <= 25);
		伤害(范围内玩家(事件玩家.Gen_Player, 3, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 30);
		等待(0.450, 无视条件);
		如条件为”真“则循环;
		事件玩家.Gen_Player = 无;
	}
}

规则("Bastion: Taser - Visual beam")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		事件玩家.RealSpawn == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		创建光束效果(所有玩家(所有队伍), 有害光束, 事件玩家 + 矢量(假, 1, 假), 事件玩家.Gen_Player != 无 ? 事件玩家.Gen_Player : 事件玩家, 颜色(水绿色), 可见，位置，半径和颜色);
		事件玩家.Effects[1] = 最后创建的实体;
		等待直到 (!事件玩家.Talent_Active_2, 99999);
		消除效果(事件玩家.Effects[1]);
	}
}

规则("McCree: Panic")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		卡西迪;
	}

	条件
	{
		事件技能 == 按钮(技能2);
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		被攻击方.Feared_until = 总计消耗时间 + 3.500;
	}
}

规则("McCree: Panic - Damage")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		卡西迪;
	}

	条件
	{
		事件玩家.Talent_Active_1 == 真;
		事件玩家.RealSpawn == 真;
	}

	动作
	{
		开始伤害调整(已过滤的数组(所有玩家(对方队伍(所在队伍(事件玩家))), 事件玩家.Feared_until >= 总计消耗时间), 所有玩家(所在队伍(事件玩家)), 220, 受伤害者，伤害者及伤害百分比);
		事件玩家.Modification_Damage[1] = 上一个伤害调整ID;
		等待直到 (!事件玩家.Talent_Active_1, 99999);
		停止伤害调整(事件玩家.Modification_Damage[1]);
	}
}

规则("McCree: Clocked")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		卡西迪;
	}

	条件
	{
		事件技能 == 按钮(终极技能);
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(橙色), 被攻击方, 1);
		伤害(被攻击方, 事件玩家, 事件伤害 * 1.500);
		设置状态(被攻击方, 无, 击倒, 3);
	}
}

规则("Sombra: Malware")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		黑影;
	}

	条件
	{
		事件玩家.Talent_Active_1 == 真;
		事件玩家.RealSpawn == 真;
	}

	动作
	{
		开始伤害调整(已过滤的数组(所有玩家(对方队伍(所在队伍(事件玩家))), 具有状态(当前数组元素, 被入侵) || 当前数组元素.Feared_until >= 总计消耗时间), 所有玩家(所在队伍(事件玩家)), 200, 受伤害者，伤害者及伤害百分比);
		事件玩家.Modification_Damage[1] = 上一个伤害调整ID;
		等待直到 (!事件玩家.Talent_Active_1, 99999);
		停止伤害调整(事件玩家.Modification_Damage[1]);
	}
}

规则("Sombra: Glitch")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		黑影;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		事件玩家.Gen_Active = 真;
		事件玩家.Gen_Position = 所选位置(事件玩家);
		创建效果(所有玩家(所有队伍), 球体, 颜色(亮紫色), 事件玩家.Gen_Position, 15, 可见，位置和半径);
		事件玩家.Effects[1] = 最后创建的实体;
		等待(8, 无视条件);
		消除效果(事件玩家.Effects[1]);
		事件玩家.Gen_Active = 假;
	}
}

规则("Sombra: Glitch - Loop")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		黑影;
	}

	条件
	{
		事件玩家.Gen_Active == 真;
	}

	动作
	{
		设置状态(已过滤的数组(范围内玩家(事件玩家.Gen_Position, 15, 对方队伍(所在队伍(事件玩家)), 表面), !具有状态(当前数组元素, 被入侵)), 无, 被入侵, 0.750);
		等待(0.500, 无视条件);
		如条件为”真“则循环;
	}
}

规则("[Hanzo] Stormbreak (Storm_Effects6)")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		攻击方.Talent_Active_1 == 真;
		所用英雄(攻击方) == 英雄(半藏);
	}

	动作
	{
		事件玩家.Storm_Projectile = 眼睛位置(事件玩家);
		事件玩家.Storm_EndPoint = 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 上 * 12, 无, 所有玩家(所有队伍), 假);
		追踪玩家变量频率(事件玩家, Storm_Projectile, 事件玩家.Storm_EndPoint, 4, 速率及最终值);
		创建效果(所有玩家(所有队伍), 云, 颜色(白色), 矢量(假, -0.500, 假) + 事件玩家.Storm_Projectile, 4, 可见，位置和半径);
		事件玩家.Storm_Effects[3] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 有害光环, 颜色(白色), 事件玩家.Storm_Projectile, 3, 可见，位置和半径);
		事件玩家.Storm_Effects[4] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 云, 颜色(白色), 事件玩家.Storm_Projectile, 3.500, 可见，位置和半径);
		事件玩家.Storm_Effects[5] = 最后创建的实体;
		创建光束效果(所有玩家(所有队伍), 有害光束, 事件玩家.Storm_Projectile, 射线命中位置(事件玩家.Storm_Projectile, 矢量(0.100, 0, 0) + 事件玩家.Storm_Projectile + 下 * 1000,
			无, 所有玩家(所有队伍), 假), 颜色(水绿色), 可见，位置和半径);
		事件玩家.Storm_Effects[6] = 最后创建的实体;
		While(相距距离(事件玩家.Storm_Projectile, 事件玩家.Storm_EndPoint) > 1);
			等待(0.600, 无视条件);
			伤害(范围内玩家(射线命中位置(事件玩家.Storm_Projectile, 事件玩家.Storm_Projectile + 下 * 1000, 无, 所有玩家(所有队伍), 假), 3, 所在队伍(事件玩家), 表面), 攻击方, 50);
			播放效果(所有玩家(所有队伍), 有害选择效果 , 颜色(水绿色), 射线命中位置(事件玩家.Storm_Projectile, 事件玩家.Storm_Projectile + 下 * 1000, 无, 所有玩家(所有队伍), 假), 3);
			播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(蓝色), 射线命中位置(事件玩家.Storm_Projectile, 事件玩家.Storm_Projectile + 下 * 1000, 无, 所有玩家(所有队伍), 假), 3);
		End;
		消除效果(事件玩家.Storm_Effects[3]);
		消除效果(事件玩家.Storm_Effects[4]);
		消除效果(事件玩家.Storm_Effects[5]);
		消除效果(事件玩家.Storm_Effects[6]);
	}
}

规则("Hanzo: Punch II")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		半藏;
	}

	条件
	{
		事件技能 == 按钮(技能2);
		事件玩家.Talent_Active_2 == 真;
		所用英雄(被攻击方) != 英雄(托比昂);
	}

	动作
	{
		伤害(被攻击方, 事件玩家, 事件伤害 * 0.800);
		施加推力(被攻击方, 事件方向, 12, 至地图, 取消相反运动);
		施加推力(被攻击方, 上, 5, 至地图, 取消相反运动);
		设置地形消灭者玩家(被攻击方, 事件玩家);
		设置状态(被攻击方, 无, 击晕, 1);
	}
}

规则("Torbjorn: Lava armour")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		托比昂;
	}

	条件
	{
		事件玩家.RealSpawn == 真;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 护甲, 事件玩家.Gen_Resource, 真, 真);
		事件玩家.HP_Pool[1] = 最后创建的生命池;
		追踪玩家变量频率(事件玩家, Gen_Resource, 50, 21, 速率及最终值);
		等待直到 (!事件玩家.Talent_Active_1, 99999);
		移除玩家的生命池(事件玩家.HP_Pool[1]);
		停止追踪玩家变量(事件玩家, Gen_Resource);
	}
}

规则("Torbjorn: Lava Armour - Gain")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		托比昂;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		事件玩家.Gen_Resource += 事件伤害 * 0.250;
	}
}

规则("Torbjorn: Roots of Magma")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		托比昂;
	}

	条件
	{
		事件技能 == 按钮(终极技能);
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(橙色), 被攻击方, 1);
		设置状态(被攻击方, 无, 定身, 0.600);
		等待(0.600, 无视条件);
	}
}

规则("Mei: Cold Snap")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		美;
	}

	条件
	{
		事件玩家.Talent_Active_1 == 真;
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), 有害光环, 颜色(天蓝色), 事件玩家, 1, 可见，位置和半径);
		事件玩家.Effects[1] = 最后创建的实体;
		等待直到 (!正在使用技能 1(事件玩家), 99999);
		消除效果(事件玩家.Effects[1]);
		伤害(范围内玩家(眼睛位置(事件玩家), 10, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 全局.GMut_Fortified ? 175 : 5);
		设置状态(范围内玩家(眼睛位置(事件玩家), 10, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 冰冻, 2);
		设置状态(范围内玩家(眼睛位置(事件玩家), 10, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 定身, 2);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(白色), 所选位置(事件玩家), 20);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(天蓝色), 所选位置(事件玩家), 20);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(水绿色), 所选位置(事件玩家) + 矢量(0, 1, 0), 20);
	}
}

规则("Mei: Icebound")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		美;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
		正在使用辅助武器(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), 环, 颜色(水绿色), 事件玩家, 0.400, 可见，位置和半径);
		事件玩家.Effects[2] = 最后创建的实体;
		设置弹道速度(事件玩家, 200);
		等待直到 (!正在使用辅助武器(事件玩家), 99999);
		消除效果(事件玩家.Effects[2]);
		设置弹道速度(事件玩家, 100);
	}
}

规则("Mei: Icebound - Icicles hit")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		美;
	}

	条件
	{
		事件技能 == 按钮(辅助攻击模式);
		正在使用技能 2(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		伤害(被攻击方, 事件玩家, 事件伤害 * 1.250);
		设置状态(被攻击方, 无, 冰冻, 1);
		设置状态(被攻击方, 无, 定身, 1);
		播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(白色), 被攻击方, 1);
	}
}

规则("Baptiste: Corrode")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		巴蒂斯特;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(亮紫色), 所选位置(事件玩家), 20);
		伤害(范围内玩家(事件玩家, 10, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 25);
		开始持续伤害(范围内玩家(事件玩家, 10, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 5, 20);
		等待(0.200, 无视条件);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(紫色), 所选位置(事件玩家), 18);
		伤害(范围内玩家(事件玩家, 10, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 25);
		开始持续伤害(范围内玩家(事件玩家, 10, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 5, 12);
		范围内玩家(事件玩家, 10, 所在队伍(事件玩家), 表面).Last_Damage_taken = 0;
	}
}

规则("Baptiste: Breakthrough")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		具有状态(事件玩家, 无法杀死) == 真;
		事件玩家.Downed_since == 假;
		(事件玩家.Talent_Active_2 ? 选择英雄的玩家(英雄(巴蒂斯特), 所在队伍(事件玩家)) : 空数组).Talent_Active_2 == 真;
	}

	动作
	{
		治疗(事件玩家, 事件玩家, 10000);
		设置状态(事件玩家, 无, 无敌, 0.800);
		设置终极技能充能(事件玩家, 终极技能充能百分比(事件玩家) + 2);
		等待(0.750, 无视条件);
		如条件为”真“则循环;
	}
}

规则("[Soldier: 76] Rocket Assault Rifle")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		士兵：76;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		事件玩家.Gen_Projectile2 = 射线命中位置(眼睛位置(事件玩家), 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 60, 无, 无, 假) + 地图矢量(矢量(-2, 0, 0), 事件玩家, 旋转),
			无, 无, 假);
		事件玩家.Gen_Projectile1 = 射线命中位置(眼睛位置(事件玩家), 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 60, 无, 无, 假) + 地图矢量(矢量(2, 0, 0), 事件玩家, 旋转),
			无, 无, 假);
		事件玩家.Gen_Position = 眼睛位置(事件玩家) + 面朝方向(事件玩家) + 地图矢量(矢量(0, -0.250, 0), 事件玩家, 旋转);
		事件玩家.Gen_End = 眼睛位置(事件玩家) + 面朝方向(事件玩家) + 地图矢量(矢量(0, -0.250, 0), 事件玩家, 旋转);
		追踪玩家变量频率(事件玩家, Gen_Position, 事件玩家.Gen_Projectile1, 60, 速率及最终值);
		追踪玩家变量频率(事件玩家, Gen_End, 事件玩家.Gen_Projectile2, 60, 速率及最终值);
		等待直到 (事件玩家.Gen_Position == 0 && 事件玩家.Gen_End == 0, 2.500);
	}
}

规则("[Soldier: 76] First Rocket Effect")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		士兵：76;
	}

	条件
	{
		事件玩家.Gen_Projectile1 != 事件玩家.Gen_Position;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 有益爆炸, 数组随机取值(数组(颜色(天蓝色), 颜色(水绿色))), 事件玩家.Gen_Position, 0.400);
		等待(0.050, 无视条件);
		如条件为”真“则循环;
		播放效果(所有玩家(所有队伍), 爆炸声音, 颜色(橙色), 事件玩家.Gen_Position, 100);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(天蓝色), 事件玩家.Gen_Position, 2.500);
		停止追踪玩家变量(事件玩家, Gen_Position);
		等待(0.016, 无视条件);
		伤害(范围内玩家(事件玩家.Gen_Position, 4, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 80);
		停止追踪玩家变量(事件玩家, Gen_Position);
		事件玩家.Gen_Position = 0;
		事件玩家.Gen_Projectile1 = 0;
		等待(0.016, 无视条件);
	}
}

规则("[Soldier: 76] Second Rocket Effect")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		士兵：76;
	}

	条件
	{
		事件玩家.Gen_Projectile2 != 事件玩家.Gen_End;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 有益爆炸, 数组随机取值(数组(颜色(天蓝色), 颜色(水绿色))), 事件玩家.Gen_End, 0.400);
		等待(0.050, 无视条件);
		如条件为”真“则循环;
		播放效果(所有玩家(所有队伍), 爆炸声音, 颜色(橙色), 事件玩家.Gen_End, 100);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(天蓝色), 事件玩家.Gen_End, 2.500);
		停止追踪玩家变量(事件玩家, Gen_End);
		伤害(范围内玩家(事件玩家.Gen_End, 4, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 80);
		事件玩家.Gen_End = 0;
		事件玩家.Gen_Projectile2 = 0;
	}
}

规则("Soldier: 76 - Init rockets")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		士兵：76;
	}

	条件
	{
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		事件玩家.Gen_Projectile1 = 事件玩家.Gen_Position;
		事件玩家.Gen_Projectile2 = 事件玩家.Gen_End;
	}
}

规则("[Soldier: 76] Shoulder Check")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		士兵：76;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
		相距距离(事件玩家, 距离最近的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)))) <= 3;
		存活(距离最近的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)))) == 真;
	}

	动作
	{
		伤害(距离最近的玩家(事件玩家, 对方队伍(所在队伍(事件玩家))), 事件玩家, 55);
		设置状态(距离最近的玩家(事件玩家, 对方队伍(所在队伍(事件玩家))), 无, 击倒, 1.500);
		施加推力(距离最近的玩家(事件玩家, 对方队伍(所在队伍(事件玩家))), 面朝方向(事件玩家), 15, 至地图, 取消相反运动);
		施加推力(事件玩家, 矢量(0, 8, 15), 15, 至玩家, 取消相反运动);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(白色), 距离最近的玩家(事件玩家, 对方队伍(所在队伍(事件玩家))), 1);
		设置技能冷却(事件玩家, 按钮(近身攻击), 0);
		按下按键(事件玩家, 按钮(近身攻击));
		等待(1, 无视条件);
	}
}

规则("D.Va: Voltage Grid")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		D.Va;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(青绿色), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 2, 0.500);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(青绿色), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 5, 0.500);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(青绿色), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 8, 0.500);
		等待(0.300, 无视条件);
		伤害(范围内玩家(眼睛位置(事件玩家) + 面朝方向(事件玩家) * 2, 2.500, 对方队伍(所在队伍(事件玩家)), 关闭), 事件玩家, 25);
		伤害(范围内玩家(眼睛位置(事件玩家) + 面朝方向(事件玩家) * 5, 2.500, 对方队伍(所在队伍(事件玩家)), 关闭), 事件玩家, 25);
		伤害(范围内玩家(眼睛位置(事件玩家) + 面朝方向(事件玩家) * 8, 2.500, 对方队伍(所在队伍(事件玩家)), 关闭), 事件玩家, 25);
		等待(0.016, 无视条件);
		设置状态(范围内玩家(眼睛位置(事件玩家) + 面朝方向(事件玩家) * 2, 2.500, 对方队伍(所在队伍(事件玩家)), 关闭), 事件玩家, 定身, 0.500);
		设置状态(范围内玩家(眼睛位置(事件玩家) + 面朝方向(事件玩家) * 5, 2.500, 对方队伍(所在队伍(事件玩家)), 关闭), 事件玩家, 定身, 0.500);
		设置状态(范围内玩家(眼睛位置(事件玩家) + 面朝方向(事件玩家) * 8, 2.500, 对方队伍(所在队伍(事件玩家)), 关闭), 事件玩家, 定身, 0.500);
		如条件为”真“则循环;
	}
}

规则("D.Va: Shooting Star")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		D.Va;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), 球体, 颜色(紫色), 事件玩家, 事件玩家.Gen_Resource, 可见，位置和半径);
		事件玩家.Effects[1] = 最后创建的实体;
		事件玩家.Gen_Resource = 0.500;
		持续追踪玩家变量(事件玩家, Gen_Resource, 3, 1.800, 终点及持续时间);
		等待直到 (!正在使用技能 1(事件玩家), 99999);
		消除效果(事件玩家.Effects[1]);
		停止追踪玩家变量(事件玩家, Gen_Resource);
		伤害(范围内玩家(事件玩家, 7, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 事件玩家.Gen_Resource * 35);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(白色), 事件玩家, 事件玩家.Gen_Resource);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(紫色), 所选位置(事件玩家), 12);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(紫色), 事件玩家, 6);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(亮紫色), 事件玩家, 6);
	}
}

规则("Wrecking Ball: Mirror Ball")
{
	事件
	{
		玩家受到伤害;
		队伍2;
		破坏球;
	}

	条件
	{
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		伤害(范围内玩家(事件玩家, 4.500, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 事件伤害);
		等待(0.100, 无视条件);
	}
}

规则("Wrecking Ball: Distort")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		破坏球;
	}

	条件
	{
		事件玩家.Talent_Active_2 == 真;
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(亮紫色), 所选位置(事件玩家), 20);
		伤害(范围内玩家(事件玩家, 8, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 80);
		等待(0.100, 无视条件);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(紫色), 所选位置(事件玩家), 18);
		设置状态(范围内玩家(事件玩家, 8, 对方队伍(所在队伍(事件玩家)), 表面), 无, 被入侵, 数量(范围内玩家(事件玩家, 8, 对方队伍(所在队伍(事件玩家)), 表面)) * 1.500);
		播放效果(所有玩家(所有队伍), 环状爆炸声音, 颜色(紫色), 所选位置(事件玩家), 125);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(亮紫色), 所选位置(事件玩家), 16);
		播放效果(所有玩家(所有队伍), 爆炸声音, 颜色(紫色), 所选位置(事件玩家), 80);
	}
}

规则("Lucio: Healing Wave")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		卢西奥;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(绿色), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 4, 4);
		治疗(范围内玩家(眼睛位置(事件玩家) + 面朝方向(事件玩家) * 4, 4, 所在队伍(事件玩家), 表面), 事件玩家, 最大生命值(已过滤的数组(范围内玩家(眼睛位置(事件玩家) + 面朝方向(事件玩家) * 4, 4, 所在队伍(事件玩家), 表面),
			存活(当前数组元素))) * 0.300);
	}
}

规则("Lucio: Reverse Amp")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		卢西奥;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		If(正在使用技能 1(事件玩家));
			设置状态(范围内玩家(事件玩家, 12, 对方队伍(所在队伍(事件玩家)), 表面), 无, 定身, 4);
		Else;
			伤害(范围内玩家(事件玩家, 12, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 16.250);
		End;
		播放效果(所有玩家(所有队伍), 环状爆炸, 正在使用技能 1(事件玩家) ? 颜色(绿色) : 颜色(黄色), 事件玩家, 1);
		等待(0.400, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Symmetra: High voltage")
{
	事件
	{
		玩家造成最后一击;
		队伍2;
		秩序之光;
	}

	条件
	{
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		等待(0.250, 无视条件);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(蓝色), 被攻击方, 6);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(蓝色), 被攻击方, 12);
		伤害(范围内玩家(被攻击方, 6, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 150);
	}
}

规则("Symmetra: Energy Source")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		对任意为”真“(选择英雄的玩家(英雄(秩序之光), 所在队伍(事件玩家)), 正在使用终极技能(当前数组元素) && 当前数组元素.Talent_Active_2) == 真;
	}

	动作
	{
		开始持续治疗(事件玩家, 事件玩家, 1, 40);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(蓝色), 事件玩家, 0.100);
		设置终极技能充能(事件玩家, 终极技能充能百分比(事件玩家) + 2);
		等待(0.900, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Junkrat: Pyromania")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		狂鼠;
	}

	条件
	{
		事件玩家.Talent_Active_1 == 真;
		事件技能 != 无;
		事件技能 != 按钮(技能2);
		事件技能 != 按钮(近身攻击);
	}

	动作
	{
		开始持续伤害(被攻击方, 事件玩家, 2, 30);
		设置状态(被攻击方, 无, 点燃, 2);
	}
}

规则("Junkrat: Short Fused")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		狂鼠;
	}

	条件
	{
		事件玩家.Talent_Active_2 == 真;
		事件技能 == 按钮(技能2);
	}

	动作
	{
		事件玩家.Gen_Countdown = 4;
		While(事件玩家.Gen_Countdown > 0);
			事件玩家.Gen_Countdown -= 1;
			事件玩家.Gen_Position = 所选位置(被攻击方) + 矢量(随机实数(-2, 2), 随机实数(-2, 2), 随机实数(-2, 2));
			播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(天蓝色), 事件玩家.Gen_Position, 4);
			播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(白色), 事件玩家.Gen_Position, 4);
			伤害(范围内玩家(事件玩家.Gen_Position, 4, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 35);
			设置状态(范围内玩家(事件玩家.Gen_Position, 4, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 击晕, 0.800);
			等待(0.200, 无视条件);
		End;
	}
}

规则("[Moira] Hose")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		莫伊拉;
	}

	条件
	{
		正在使用主要武器(事件玩家) == 真;
		事件玩家.Talent_Active_1 == 真;
		技能资源(事件玩家, 按钮(主要攻击模式)) > 假;
	}

	动作
	{
		施加推力(已过滤的数组(视角中的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)), 25), 相距距离(事件玩家, 当前数组元素) <= 15 && 在视线内(事件玩家, 当前数组元素, 敌方屏障阻挡视线) && !具有状态(当前数组元素, 相移)),
			面朝方向(事件玩家), 8, 至地图, 取消相反运动);
		施加推力(已过滤的数组(视角中的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)), 25), 相距距离(事件玩家, 当前数组元素) <= 15 && !在视线内(当前数组元素, 事件玩家, 敌方屏障阻挡视线) && !具有状态(当前数组元素, 相移)), 上,
			3, 至地图, 取消相反运动);
		开始持续伤害(已过滤的数组(视角中的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)), 25), 相距距离(事件玩家, 当前数组元素) <= 15 && 在视线内(事件玩家, 当前数组元素, 敌方屏障阻挡视线)), 事件玩家, 1, 15);
		等待(0.300, 无视条件);
		如条件为”真“则循环;
	}
}

规则("[Moira] Flourish - Damage")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		莫伊拉;
	}

	条件
	{
		事件技能 == 按钮(技能2);
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		伤害(被攻击方, 事件玩家, 事件伤害 * 2);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(紫色), 被攻击方, 0.100);
		等待(0.250, 无视条件);
	}
}

规则("[Moira] Flourish - Healing")
{
	事件
	{
		玩家造成治疗;
		队伍2;
		莫伊拉;
	}

	条件
	{
		事件技能 == 按钮(技能2);
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		治疗(受治疗者, 事件玩家, 事件治疗 * 2);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(黄色), 受治疗者, 0.100);
		等待(0.250, 无视条件);
	}
}

规则("Ana: Sleep Paralysis")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		安娜;
	}

	条件
	{
		事件技能 == 按钮(技能1);
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(黑色), 被攻击方, 1);
		等待(0.250, 无视条件);
		设置状态(被攻击方, 无, 沉睡, 999);
	}
}

规则("Ana: Multinade")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		安娜;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		事件玩家.Gen_Countdown = 4;
		While(事件玩家.Gen_Countdown > 0);
			等待(0.030, 无视条件);
			设置技能冷却(事件玩家, 按钮(技能2), 0);
			取消主要动作(事件玩家);
			等待(0.050, 无视条件);
			按下按键(事件玩家, 按钮(技能2));
			事件玩家.Gen_Countdown -= 1;
		End;
		等待(2, 无视条件);
	}
}

规则("Zenyatta: Vigor")
{
	事件
	{
		玩家造成治疗;
		队伍2;
		禅雅塔;
	}

	条件
	{
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		设置状态(受治疗者, 无, 相移, 1);
		等待(0.800, 无视条件);
	}
}

规则("Zenyatta: Perfect Balance")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		禅雅塔;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		开始持续伤害(范围内玩家(事件玩家, 12, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 0.750, 200);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(橙色), 事件玩家, 24);
		等待(0.600, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Reinhardt: Fire Blast")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		莱因哈特;
	}

	条件
	{
		事件技能 == 按钮(技能2);
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(橙色), 被攻击方, 5);
		开始持续伤害(范围内玩家(被攻击方, 5, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 5, 20);
		设置状态(范围内玩家(被攻击方, 5, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 点燃, 5);
	}
}

规则("Reinhardt: Epicenter")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		莱因哈特;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
		在地面上(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		设置状态(已过滤的数组(范围内玩家(事件玩家, 20, 对方队伍(所在队伍(事件玩家)), 表面), !具有状态(当前数组元素, 击倒)), 事件玩家, 击倒, 2.500);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(橙色), 所选位置(事件玩家), 10);
		伤害(已过滤的数组(范围内玩家(事件玩家, 20, 对方队伍(所在队伍(事件玩家)), 表面), !具有状态(当前数组元素, 击倒)), 事件玩家, 50);
		等待(0.016, 无视条件);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(橙色), 所选位置(事件玩家), 20);
		等待(0.016, 无视条件);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(橙色), 所选位置(事件玩家), 30);
		等待(0.016, 无视条件);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(橙色), 所选位置(事件玩家), 40);
		等待(5, 无视条件);
	}
}

规则("Widowmaker: Kiss Of Death")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		黑百合;
	}

	条件
	{
		标准化生命值(被攻击方) <= 0.300;
		正在使用辅助武器(事件玩家) == 真;
		事件技能 == 按钮(主要攻击模式);
		事件玩家.Talent_Active_1 == 真;
		事件伤害 >= 40;
		所用英雄(被攻击方) != 英雄(托比昂);
		事件暴击 == 真;
		(全局.Gamemode && 栏位(被攻击方) == 6) == 假;
	}

	动作
	{
		击杀(被攻击方, 事件玩家);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(亮紫色), 被攻击方, 3);
		伤害(范围内玩家(被攻击方, 3, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 事件伤害 * 1.500);
	}
}

规则("Widowmaker: Epidemic")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		黑百合;
	}

	条件
	{
		事件技能 == 按钮(技能2);
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(紫色), 被攻击方, 16);
		播放效果(所有玩家(所有队伍), 爆炸声音, 颜色(白色), 被攻击方, 100);
		开始持续伤害(已过滤的数组(范围内玩家(被攻击方, 8, 对方队伍(所在队伍(事件玩家)), 表面), 当前数组元素 != 被攻击方), 事件玩家, 3, 25);
		开始持续治疗(事件玩家, 事件玩家, 3, 25);
		等待(1.200, 无视条件);
	}
}

规则("Roadhog: Stench")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		路霸;
	}

	条件
	{
		事件玩家.Talent_Active_1 == 真;
		事件玩家.RealSpawn == 真;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), 环, 颜色(紫色), 事件玩家, 8, 可见，位置和半径);
		事件玩家.Effects[1] = 最后创建的实体;
	}
}

规则("Roadhog: Stench effect")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		路霸;
	}

	条件
	{
		相距距离(事件玩家, 距离最近的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)))) <= 8;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		伤害(范围内玩家(事件玩家, 8, 对方队伍(所在队伍(事件玩家)), 关闭), 事件玩家, 9);
		等待(0.250, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Roadhog: Rusted Anchor")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		路霸;
	}

	条件
	{
		事件玩家.Talent_Active_2 == 真;
		事件玩家.RealSpawn == 真;
	}

	动作
	{
		开始伤害调整(已过滤的数组(所有玩家(所有队伍), 正在使用技能 1(事件玩家)), 事件玩家, 400, 受伤害者，伤害者及伤害百分比);
		事件玩家.Modification_Damage[1] = 上一个伤害调整ID;
		等待直到 (!事件玩家.Talent_Active_1 || 所用英雄(事件玩家) != 英雄(路霸), 99999);
		停止伤害调整(事件玩家.Modification_Damage[1]);
	}
}

规则("Roadhog: Rusted Anchor - Reset cooldown")
{
	事件
	{
		玩家参与消灭;
		队伍2;
		路霸;
	}

	条件
	{
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		等待直到 (!正在使用技能 1(事件玩家), 3);
		设置技能冷却(事件玩家, 按钮(技能1), 假);
	}
}

规则("Pharah: Head Trauma")
{
	事件
	{
		玩家造成击退;
		队伍2;
		法老之鹰;
	}

	条件
	{
		事件技能 == 按钮(技能2);
		事件玩家.Talent_Active_1 == 真;
		被攻击方 != 事件玩家;
	}

	动作
	{
		伤害(被攻击方, 事件玩家, 最大生命值(被攻击方) * 0.300);
		设置状态(被攻击方, 事件玩家, 击倒, 1);
		播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(白色), 被攻击方, 1);
	}
}

规则("Pharah: Thunderbird")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Talent_Active_2 == 真;
		所用英雄(事件玩家) == 英雄(法老之鹰);
		事件玩家.RealSpawn == 真;
	}

	动作
	{
		事件玩家.Damage_Dealt *= 4;
		开始伤害调整(所有玩家(所有队伍), 事件玩家, 25, 受伤害者，伤害者及伤害百分比);
		事件玩家.Modification_Damage[1] = 上一个伤害调整ID;
		为玩家添加生命池(事件玩家, 护盾, 150, 真, 真);
		事件玩家.HP_Pool[1] = 最后创建的生命池;
		等待直到 (!事件玩家.Talent_Active_2 || 所用英雄(事件玩家) != 英雄(法老之鹰), 99999);
		事件玩家.Damage_Dealt /= 4;
		停止伤害调整(事件玩家.Modification_Damage[1]);
		移除玩家的生命池(事件玩家.HP_Pool[1]);
	}
}

规则("Zarya: Augment")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.Talent_Active_1 == 真;
		事件玩家.RealSpawn == 真;
	}

	动作
	{
		开始调整障碍大小(事件玩家, 2, 真);
		事件玩家.Max_HP *= 1.500;
		等待直到 (!事件玩家.Talent_Active_1 || 所用英雄(事件玩家) != 英雄(查莉娅), 99999);
		事件玩家.Max_HP /= 1.500;
		停止调整障碍大小(事件玩家);
	}
}

规则("Zarya: Perpetual Energy")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		查莉娅;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
		事件玩家.Talent_Active_2 == 真;
		所用英雄(被攻击方) != 英雄(托比昂);
	}

	动作
	{
		开始持续伤害(被攻击方, 事件玩家, 9999, 12);
		设置状态(被攻击方, 无, 点燃, 9999);
		等待(0.750, 无视条件);
	}
}

规则("Doomfist: Phase Shifter")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		末日铁拳;
	}

	条件
	{
		(正在使用辅助武器(事件玩家) || 正在使用技能 1(事件玩家) || 正在使用技能 2(事件玩家)) == 真;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		设置状态(事件玩家, 无, 相移, 1);
		等待(1, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Doomfist: Fissure")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		末日铁拳;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		等待直到 (!正在使用终极技能(事件玩家), 99999);
		事件玩家.Gen_Position = 所选位置(事件玩家);
		事件玩家.Gen_Active = 真;
		等待直到 (死亡(事件玩家), 8);
		事件玩家.Gen_Active = 假;
	}
}

规则("Doomfist: Fissure")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		末日铁拳;
	}

	条件
	{
		事件玩家.Gen_Active == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), 环, 颜色(橙色), 事件玩家.Gen_Position, 8, 可见，位置和半径);
		事件玩家.Effects[1] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 云, 颜色(橙色), 事件玩家.Gen_Position, 8, 可见，位置和半径);
		事件玩家.Effects[2] = 最后创建的实体;
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(橙色), 事件玩家.Gen_Position, 16);
		While(事件玩家.Gen_Active == 真);
			伤害(范围内玩家(事件玩家.Gen_Position, 8, 对方队伍(所在队伍(事件玩家)), 关闭), 事件玩家, 34);
			等待(0.235, 无视条件);
		End;
		消除效果(事件玩家.Effects[1]);
		消除效果(事件玩家.Effects[2]);
	}
}

规则("[Winston] Electric Field")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		温斯顿;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		伤害(范围内玩家(事件玩家.Gen_Projectile1, 6, 对方队伍(所在队伍(事件玩家)), 关闭), 事件玩家, 65);
		消除效果(事件玩家.Effects[1]);
		事件玩家.Gen_Active = 真;
		创建效果(所有玩家(所有队伍), 球, 颜色(白色), 事件玩家.Gen_Projectile1, 1, 可见，位置和半径);
		事件玩家.Effects[1] = 最后创建的实体;
		停止追踪玩家变量(事件玩家, Gen_Resource);
		事件玩家.Gen_Projectile1 = 眼睛位置(事件玩家);
		事件玩家.Gen_End = 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 下 * 1000, 无, 所有玩家(所有队伍), 假);
		等待(0.100, 无视条件);
		事件玩家.Gen_Resource = 5;
		等待(0.250, 无视条件);
		追踪玩家变量频率(事件玩家, Gen_Resource, 20, 7, 速率及最终值);
		追踪玩家变量频率(事件玩家, Gen_Projectile1, 事件玩家.Gen_End, 事件玩家.Gen_Resource, 速率及最终值);
		等待(8.650, 当为“真”时重新开始);
		事件玩家.Gen_Active = 假;
	}
}

规则("[Winston] Electric Field 2")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		温斯顿;
	}

	条件
	{
		事件玩家.Gen_Active == 真;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(水绿色), 事件玩家.Gen_Projectile1, 5);
		伤害(范围内玩家(事件玩家.Gen_Projectile1, 5, 对方队伍(所在队伍(事件玩家)), 关闭), 事件玩家, 33);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(蓝色), 事件玩家.Gen_Projectile1, 10);
		等待(0.250, 无视条件);
		如条件为”真“则循环;
		伤害(范围内玩家(事件玩家.Gen_Projectile1, 6, 对方队伍(所在队伍(事件玩家)), 关闭), 事件玩家, 80);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(青绿色), 事件玩家.Gen_Projectile1, 12);
		消除效果(事件玩家.Effects[1]);
		播放效果(所有玩家(所有队伍), 环状爆炸声音, 颜色(白色), 事件玩家.Gen_Projectile1, 125);
	}
}

规则("Winston: Next Generation")
{
	事件
	{
		玩家参与消灭;
		队伍2;
		温斯顿;
	}

	条件
	{
		终极技能充能百分比(事件玩家) <= 80;
		正在使用终极技能(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		设置终极技能充能(事件玩家, 终极技能充能百分比(事件玩家) + 15);
	}
}

规则("Brigitte: Heavy Iron")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		布丽吉塔;
	}

	条件
	{
		(事件技能 == 按钮(主要攻击模式) || 事件技能 == 按钮(技能1)) == 真;
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(橙色), 被攻击方, 1.500);
		设置状态(被攻击方, 无, 定身, 0.500);
		设置地形消灭者玩家(被攻击方, 事件玩家);
	}
}

规则("Brigitte: Endeavor")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		布丽吉塔;
	}

	条件
	{
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) >= 0.100;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), 环, 颜色(橙色), 事件玩家, 0.400, 可见，位置和半径);
		事件玩家.Effects[1] = 最后创建的实体;
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(橙色), 眼睛位置(事件玩家), 15);
		治疗(范围内玩家(事件玩家, 15, 所在队伍(事件玩家), 关闭), 事件玩家, 200);
		事件玩家.Damage_Dealt *= 2.500;
		事件玩家.Move_Speed *= 1.750;
		为玩家添加生命池(事件玩家, 护甲, 最大生命值(事件玩家) / 2, 假, 真);
		事件玩家.HP_Pool[1] = 最后创建的生命池;
		等待直到 (死亡(事件玩家), 6);
		事件玩家.Damage_Dealt /= 2.500;
		事件玩家.Move_Speed /= 1.750;
		移除玩家的生命池(事件玩家.HP_Pool[1]);
		消除效果(事件玩家.Effects[1]);
	}
}

规则("Genji: Venomous Strike")
{
	事件
	{
		玩家造成伤害;
		队伍2;
		源氏;
	}

	条件
	{
		事件技能 == 按钮(技能1);
		事件玩家.Talent_Active_1 == 真;
	}

	动作
	{
		开始持续治疗(事件玩家, 事件玩家, 3, 25);
		开始持续伤害(被攻击方, 事件玩家, 3, 25);
		伤害(被攻击方, 事件玩家, 25);
		治疗(事件玩家, 事件玩家, 25);
	}
}

规则("Genji: Dragon's Breath")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		源氏;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
		正在使用主要武器(事件玩家) == 真;
		事件玩家.Talent_Active_2 == 真;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), 有益光环, 颜色(灰绿色), 事件玩家.Gen_Projectile1, 1, 可见，位置和半径);
		事件玩家.Effects[1] = 最后创建的实体;
		事件玩家.Gen_Projectile1 = 眼睛位置(事件玩家);
		追踪玩家变量频率(事件玩家, Gen_Projectile1, 事件玩家.Gen_End, 80, 速率及最终值);
		事件玩家.Gen_End = 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 60, 所有存活玩家(对方队伍(所在队伍(事件玩家))), 所有玩家(所在队伍(事件玩家)), 真);
		等待直到 (事件玩家.Gen_End == 事件玩家.Gen_Projectile1, 1);
		消除效果(事件玩家.Effects[1]);
		播放效果(所有玩家(所有队伍), 环状爆炸声音, 颜色(绿色), 事件玩家.Gen_Projectile1, 100);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(灰绿色), 事件玩家.Gen_Projectile1, 5);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(绿色), 事件玩家.Gen_Projectile1, 5);
		伤害(范围内玩家(事件玩家.Gen_Projectile1, 5, 对方队伍(所在队伍(事件玩家)), 表面), 事件玩家, 100);
	}
}

规则("Team 1: Reset facing")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		(正在使用终极技能(事件玩家) && 所用英雄(事件玩家) == 英雄(托比昂)) == 假;
	}

	动作
	{
		开始朝向(事件玩家, (事件玩家.Is_Target_in_LOS || 事件玩家.Is_Wraith || 所用英雄(事件玩家) == 英雄(半藏) ? 矢量(0, 0, 0) : 1.500 * 方向(事件玩家, 事件玩家.Nav)) + (
			事件玩家.Target.Is_Combatant ? 方向(眼睛位置(事件玩家), 具有状态(事件玩家.Target, 击倒) || 具有状态(事件玩家.Target, 沉睡) || 正在使用表情交流(事件玩家.Target) ? 所选位置(
			事件玩家.Target) + 0.250 * 上 : 眼睛位置(事件玩家.Target) + 全局.Aim_Offset) : 矢量(0, 0, 0)), 具有状态(事件玩家, 击晕) ? 0 : (全局.Mut_Amped ? 600 : 300),
			至地图, 方向及角速率);
	}
}

规则("Team 1 Pharah: Barrage")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		法老之鹰;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		(全局.Wave >= (全局.Gamemode ? 14 : 20) || (全局.Mut_Last_Stand && (全局.Gamemode ? 全局.IV_Portal_Status == 3 : 全局.Spawns_remaining <= 0)))
			== 真;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > 30);
		根据条件循环(相距距离(事件玩家, 事件玩家.Target) >= 25);
		设置终极技能充能(事件玩家, 100);
		按下按键(事件玩家, 按钮(终极技能));
		等待(全局.Mut_Adrenaline ? 14 : 28, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1: Adrenaline - No ammo limit")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		弹药(事件玩家, 0) > 假;
		全局.Mut_Adrenaline == 真;
	}

	动作
	{
		设置弹药(事件玩家, 0, 1000);
	}
}

规则("Team 1 Wrecking Ball: Minefield")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		破坏球;
	}

	条件
	{
		事件玩家.Is_Target_in_LOS == 真;
		(全局.Wave >= (全局.Gamemode ? 15 : 20) || (全局.Mut_Last_Stand && (全局.Gamemode ? 全局.IV_Portal_Status == 3 : 全局.Spawns_remaining <= 0)))
			== 真;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		根据条件循环(随机整数(1, 100) > 30);
		根据条件循环(相距距离(事件玩家, 事件玩家.Target) >= 25);
		设置终极技能充能(事件玩家, 100);
		按下按键(事件玩家, 按钮(终极技能));
		等待(全局.Mut_Adrenaline ? 14 : 28, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1 Symmetra: Start / Stop Shooting")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		秩序之光;
	}

	条件
	{
		相距距离(事件玩家, 事件玩家.Target) <= 9;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(主要攻击模式));
		等待直到 (相距距离(事件玩家, 事件玩家.Target) > 9, 99999);
		停止按下按钮(事件玩家, 按钮(主要攻击模式));
	}
}

规则("MUT Team 1 Symmetra (Mutator): Extended, Sentries")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		秩序之光;
	}

	条件
	{
		全局.Mut_Extended_Arsenal == 真;
		存活(事件玩家) == 真;
		事件玩家.Is_Target_in_LOS == 假;
	}

	动作
	{
		等待(1, 当为“假”时中止);
		按下按键(事件玩家, 按钮(技能1));
		等待(0.400, 当为“假”时中止);
		按下按键(事件玩家, 按钮(技能1));
		等待(0.500, 当为“假”时中止);
		按下按键(事件玩家, 按钮(技能1));
		等待(20, 无视条件);
		如条件为”真“则循环;
	}
}

规则("Team 1: Symmetra - Scaling")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		秩序之光;
	}

	条件
	{
		存活(事件玩家) == 真;
	}

	动作
	{
		开始调整玩家大小(事件玩家, 0.750, 真);
		等待直到 (死亡(事件玩家), 99999);
		停止调整玩家大小(事件玩家);
	}
}

规则("Bad Mutator 19: Start damage modification")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.Mut_Partners_In_Crime == 真;
	}

	动作
	{
		开始伤害调整(全局.Combatants, 事件玩家, 90 + 10 * 已过滤的数组(数量(选择英雄的玩家(所用英雄(事件玩家), 队伍1)), 存活(当前数组元素)), 受伤害者，伤害者及伤害百分比);
	}
}

规则("HR Global (Next Wave): Revive Players, Scale Values, Set Level, Set Mutators")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.Gamemode == 0;
		全局.Wave > 0;
		全局.Spawns_remaining <= 0;
		全局.Boss_Spawns_remaining <= 0;
		存活玩家数量(队伍1) == 0;
	}

	动作
	{
		If(全局.Wave == 1);
			全局.Mutator_Activation_locked = 真;
			消除HUD文本(全局.Mutator_Start_HUD);
		Else If(全局.Wave >= 22);
			开始规则(Declare_Victory, 无动作);
		End;
		已过滤的数组(全局.Combatants, 当前数组元素.Downed_since && 当前数组元素.Downed_since + 0.100 < 总计消耗时间).Downed_since = 0;
		大字体信息(所有玩家(所有队伍), 自定义字符串("幸存本回合！"));
		全局.Money += (全局.Mutators_activated ? 2 : 1) * ((全局.Mut_Reinforcements ? 20 : 35) + 10 * 全局.Wave) * 2;
		调用子程序(Set_Random_Perks);
		If(全局.Mutators_activated && 全局.Wave % 3 == 1);
			调用子程序(MUT_Add_Mutator);
		End;
		关闭游戏预设音乐模式;
		设置比赛时间(全局.Wave >= 10 ? 15 : 10);
		等待(全局.Wave >= 10 ? 15 : 10, 无视条件);
		开启游戏预设音乐模式;
		修改队伍分数(队伍2, 1);
		全局.Wave += 1;
		全局.HR_Wave_Start = 总计消耗时间;
		If(全局.Wave == 5 || (全局.Wave >= 10 && 全局.Wave % 3 == 1));
			大字体信息(所有玩家(所有队伍), 自定义字符串("Boss回合"));
			全局.Spawns_remaining = (全局.Mut_Reinforcements ? 3 : 0) + 较小(25, 2 * 全局.Wave - 10);
			全局.Boss_Spawns_remaining = 全局.Wave == 5 || 全局.Wave == 16 ? 2 : 1;
		Else;
			全局.Spawns_remaining = (全局.Mut_Reinforcements ? 3 : 0) + 较小(35, 2 * 全局.Wave + 10);
		End;
		全局.Called_Incoming = 假;
		全局.Mut_Last_Stand_active = 假;
		调用子程序(Scale_Damage);
		If(全局.Wave == 2);
			此栏位的玩家(3, 队伍1).Level = 2;
			此栏位的玩家(4, 队伍1).Level = 2;
		Else If(全局.Wave == 4);
			此栏位的玩家(5, 队伍1).Level = 3;
		Else If(全局.Wave == 6);
			此栏位的玩家(2, 队伍1).Level = 2;
		Else If(全局.Wave == 8);
			此栏位的玩家(4, 队伍1).Level = 3;
		Else If(全局.Wave == 11);
			此栏位的玩家(1, 队伍1).Level = 2;
		Else If(全局.Wave == 14);
			此栏位的玩家(3, 队伍1).Level = 3;
		Else If(全局.Wave == 17);
			此栏位的玩家(0, 队伍1).Level = 2;
		Else If(全局.Wave == 21);
			此栏位的玩家(3, 队伍1).Level = 4;
		End;
	}
}

规则("IV HVT Global (Next Wave): Revive Players, Scale Values, Set Level, Set Mutators")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.Gamemode == 真;
		全局.IV_Portal_Status == 3;
		存活玩家数量(队伍1) == 0;
	}

	动作
	{
		If(全局.Wave == 1);
			全局.Mutator_Activation_locked = 真;
			消除HUD文本(全局.Mutator_Start_HUD);
		Else If(全局.Wave == 9);
			停止伤害调整(全局.IV_HVT_Damage_Mods[0]);
			停止伤害调整(全局.IV_HVT_Damage_Mods[1]);
		Else If(全局.Wave >= 15);
			开始规则(Declare_Victory, 无动作);
		End;
		全局.IV_Portal_Status = 0;
		已过滤的数组(全局.Combatants, 当前数组元素.Downed_since && 当前数组元素.Downed_since + 0.100 < 总计消耗时间).Downed_since = 0;
		大字体信息(所有玩家(所有队伍), 自定义字符串("幸存本回合！"));
		全局.Money += (全局.Mutators_activated ? 2 : 1) * ((全局.Wave >= 10 ? 30 : 20) + 30 * 全局.Wave) * 2;
		调用子程序(Set_Random_Perks);
		If(全局.Mutators_activated && 全局.Wave % 2 == 1);
			调用子程序(MUT_Add_Mutator);
		End;
		关闭游戏预设音乐模式;
		设置比赛时间(全局.Wave >= 5 ? 15 : 10);
		等待(全局.Wave >= 5 ? 15 : 10, 无视条件);
		开启游戏预设音乐模式;
		修改队伍分数(队伍2, 1);
		全局.Wave += 1;
		全局.Spawns_remaining = 真;
		全局.IV_HVT_Spawn_Slot_Six = 真;
		全局.Called_Incoming = 假;
		全局.Mut_Last_Stand_active = 假;
		调用子程序(Scale_Damage);
		If(全局.Wave == 2);
			此栏位的玩家(3, 队伍1).Level = 2;
			此栏位的玩家(4, 队伍1).Level = 2;
		Else If(全局.Wave == 4);
			此栏位的玩家(5, 队伍1).Level = 3;
		Else If(全局.Wave == 5);
			此栏位的玩家(2, 队伍1).Level = 2;
		Else If(全局.Wave == 7);
			此栏位的玩家(4, 队伍1).Level = 3;
		Else If(全局.Wave == 9);
			此栏位的玩家(1, 队伍1).Level = 2;
		Else If(全局.Wave == 11);
			此栏位的玩家(3, 队伍1).Level = 3;
		Else If(全局.Wave == 13);
			此栏位的玩家(0, 队伍1).Level = 2;
		End;
	}
}