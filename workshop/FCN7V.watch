设置
{
	主程序
	{
		描述: "编辑器代码ZAZBY     2021.08"
		模式名称: "源氏跑酷"
	}

	大厅
	{
		比赛结束后转换队伍: 否
		比赛语音聊天: 启用
		玩家上限 队伍1: 12
		玩家上限 队伍2: 0
		观战者人数上限: 3
		队列中的玩家可以加入: 是
	}

	模式
	{
		禁用 团队死斗
		{
			“天使”重生抵消消灭次数: 关闭
			主动复生: 关闭
			比赛时长（分钟）: 15
		}

		突击模式
		{
			启用地图
			{
				花村
			}
		}

		综合
		{
			允许切换英雄: 关闭
			复生时间: 0%
			急救包刷新: 禁用
			敌方生命条: 关闭
			消灭提示: 关闭
			消灭镜头: 关闭
			游戏模式开始: 手动
			英雄限制: 关闭
		}
	}

	英雄
	{
		综合
		{
			D.Va
			{
				无机甲重生: 开启
				重生时终极技能充能完毕: 开启
			}

			源氏
			{
				影 冷却时间: 0%
				无需装弹: 开启
				终极技能充能速度（斩）: 500%
				终极技能持续时间: 25%
				终极技能自动充能速度 斩: 500%
				重生时终极技能充能完毕: 开启
				闪: 关闭
			}

			启用英雄
			{
				源氏
			}
		}
	}
}

变量
{
	全局:
		3: DVA
		4: dva
		12: Dao
		13: SHIFT
		14: SUPERJUMP
		18: TQ
		19: TQ1
		20: TQ2
		21: TQ3
		22: EditMode
		23: TQ5
		24: TQ6
		25: kz_xs
		26: killballnumber
		27: pinballnumber
		28: deathjump
		30: save
		32: toplistPlayers
		33: toplistTimes
		34: toplistSortedTimes
		35: kaxiaotiao
		38: NANBA

	玩家:
		12: ztjs
		26: TY
		31: quick_restart
}

子程序
{
	3: KILLBALL
	4: pinball
}

禁用 规则("防查看器崩溃（作图时开启，比赛时关闭）")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		禁用查看器录制;
		等待(10, 无视条件);
		启用查看器录制;
		循环;
	}
}

禁用 规则("清爽模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		事件玩家 == 主机玩家;
		事件玩家.E >= 1;
	}

	动作
	{
		等待(0.800, 当为“假”时中止);
		播放效果(主机玩家, 正面状态施加声音, 颜色(白色), 事件玩家, 100);
		If(事件玩家.K == 1);
			事件玩家.K = 2;
			小字体信息(所有玩家(所有队伍), 自定义字符串("指引文本已折叠"));
		Else;
			事件玩家.K = 1;
			小字体信息(所有玩家(所有队伍), 自定义字符串("指引文本已开启"));
		End;
	}
}

禁用 规则("清空多余数据")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		全局.B = 0;
		全局.C = 0;
		全局.DVA = 0;
		全局.dva = 0;
		全局.F = 0;
		全局.G = 0;
		全局.J = 0;
		全局.K = 0;
		全局.L = 0;
		全局.Dao = 0;
		全局.SHIFT = 0;
		全局.SUPERJUMP = 0;
		全局.P = 0;
		全局.Q = 0;
		全局.R = 0;
		全局.TQ1 = 0;
		全局.NANBA = 0;
		全局.TQ2 = 0;
		全局.TQ3 = 0;
		全局.save = 0;
		全局.kz_xs = 0;
		大字体信息(所有玩家(所有队伍), 自定义字符串("已清空数据（点位/球体外）！"));
		大字体信息(所有玩家(所有队伍), 自定义字符串("已清空数据（点位/球体外）！"));
		启用查看器录制;
	}
}

禁用 规则("穿墙")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		事件玩家.E == 1;
	}

	动作
	{
		传送(事件玩家, 所选位置(事件玩家) + 面朝方向(事件玩家) * 3);
	}
}

禁用 规则("修改编辑模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		等待(1, 当为“假”时中止);
		If(事件玩家.E == 1);
			事件玩家.E = 2;
			小字体信息(主机玩家, 自定义字符串("当前编辑模式为：球体"));
		Else If(事件玩家.E == 2);
			事件玩家.E = 3;
			小字体信息(主机玩家, 自定义字符串("当前编辑模式为：弹球"));
		Else If(事件玩家.E == 3);
			事件玩家.E = 1;
			小字体信息(主机玩家, 自定义字符串("当前编辑模式为：点位"));
		End;
	}
}

禁用 规则("修改球体大小/增大")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		事件玩家 == 主机玩家;
		事件玩家.E > 1;
	}

	动作
	{
		If(事件玩家.E == 2);
			If(数量(全局.H) > 0);
				全局.I[全局.J] += 0.100;
				等待(0.100, 无视条件);
				如条件为”真“则循环;
				For 全局变量(NANBA, 0, 数量(全局.H), 1);
					消除效果(全局.K[全局.NANBA]);
				End;
				全局.K = 空数组;
				调用子程序(KILLBALL);
			End;
		Else If(事件玩家.E == 3);
			If(数量(全局.TQ) > 0);
				全局.EditMode[全局.TQ1] += 0.100;
				等待(0.100, 无视条件);
				如条件为”真“则循环;
			End;
		End;
	}
}

禁用 规则("修改球体大小/缩小")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		事件玩家 == 主机玩家;
		事件玩家.E > 1;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
	}

	动作
	{
		If(数量(全局.H) > 0);
			If(事件玩家.E == 2);
				全局.I[全局.J] -= 0.100;
				等待(0.100, 无视条件);
				如条件为”真“则循环;
				For 全局变量(NANBA, 0, 数量(全局.H), 1);
					消除效果(全局.K[全局.NANBA]);
				End;
				全局.K = 空数组;
				调用子程序(KILLBALL);
			End;
		End;
	}
}

禁用 规则("弹球弹力减小")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		事件玩家 == 主机玩家;
		事件玩家.E == 3;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
	}

	动作
	{
		If(数量(全局.TQ) > 0);
			全局.EditMode[全局.TQ1] -= 0.100;
			等待(0.100, 无视条件);
			如条件为”真“则循环;
		End;
	}
}

禁用 规则("移动球体/往面朝方向")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		事件玩家 == 主机玩家;
		事件玩家.E > 1;
	}

	动作
	{
		If(事件玩家.E == 2);
			根据条件跳过(全局.L != 全局.H[全局.J], 1);
			追踪全局变量频率(L, 眼睛位置(事件玩家) + 面朝方向(事件玩家) * (相距距离(所选位置(事件玩家), 全局.H[全局.J]) + 5), 1, 速率及最终值);
			等待(0.250, 无视条件);
			如条件为”真“则循环;
			停止追踪全局变量(L);
			全局.H[全局.J] = 全局.L;
			For 全局变量(NANBA, 0, 数量(全局.H), 1);
				消除效果(全局.K[全局.NANBA]);
			End;
			全局.K = 空数组;
			调用子程序(KILLBALL);
		Else If(事件玩家.E == 3);
			根据条件跳过(全局.TQ3 != 全局.TQ[全局.TQ1], 1);
			追踪全局变量频率(TQ3, 眼睛位置(事件玩家) + 面朝方向(事件玩家) * (相距距离(所选位置(事件玩家), 全局.TQ[全局.TQ1]) + 5), 1, 速率及最终值);
			等待(0.250, 无视条件);
			如条件为”真“则循环;
			停止追踪全局变量(TQ3);
			全局.TQ[全局.TQ1] = 全局.TQ3;
			For 全局变量(NANBA, 0, 数量(全局.TQ), 1);
				消除效果(全局.TQ2[全局.NANBA]);
			End;
			全局.TQ2 = 空数组;
			调用子程序(pinball);
		End;
	}
}

禁用 规则("移动球体/往身后方向")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		事件玩家 == 主机玩家;
		事件玩家.E > 1;
	}

	动作
	{
		If(事件玩家.E == 2);
			根据条件跳过(全局.L != 全局.H[全局.J], 1);
			追踪全局变量频率(L, 眼睛位置(事件玩家) - 面朝方向(事件玩家) * (相距距离(所选位置(事件玩家), 全局.H[全局.J]) + 5), 1, 速率及最终值);
			等待(0.250, 无视条件);
			如条件为”真“则循环;
			停止追踪全局变量(L);
			全局.H[全局.J] = 全局.L;
			For 全局变量(NANBA, 0, 数量(全局.H), 1);
				消除效果(全局.K[全局.NANBA]);
			End;
			全局.K = 空数组;
			调用子程序(KILLBALL);
		Else If(事件玩家.E == 3);
			根据条件跳过(全局.TQ3 != 全局.TQ[全局.TQ1], 1);
			追踪全局变量频率(TQ3, 眼睛位置(事件玩家) - 面朝方向(事件玩家) * (相距距离(所选位置(事件玩家), 全局.TQ[全局.TQ1]) + 5), 1, 速率及最终值);
			等待(0.250, 无视条件);
			如条件为”真“则循环;
			停止追踪全局变量(TQ3);
			全局.TQ[全局.TQ1] = 全局.TQ3;
			For 全局变量(NANBA, 0, 数量(全局.TQ), 1);
				消除效果(全局.TQ2[全局.NANBA]);
			End;
			全局.TQ2 = 空数组;
			调用子程序(pinball);
		End;
	}
}

禁用 规则("编辑模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		"玩家E：编辑模式"
		事件玩家.E = 1;
		事件玩家.K = 1;
	}
}

禁用 规则("创建点位")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		If(事件玩家.E == 1);
			修改全局变量(A, 添加至数组, 所选位置(事件玩家) - 矢量(0, 0, 0));
			全局.B = 数量(全局.A) - 1;
			小字体信息(所有玩家(所有队伍), 自定义字符串("已新建点位"));
		Else If(事件玩家.E == 2);
			If(事件玩家.A == 0);
				大字体信息(所有玩家(所有队伍), 自定义字符串("第0关不可放置击杀球"));
			Else;
				修改全局变量(H, 添加至数组, 所选位置(事件玩家));
				修改全局变量(killballnumber, 添加至数组, 事件玩家.A);
				全局.J = 数量(全局.H) - 1;
				全局.I[全局.J] = 5;
				For 全局变量(NANBA, 0, 数量(全局.H), 1);
					消除效果(全局.K[全局.NANBA]);
				End;
				全局.K = 空数组;
				调用子程序(KILLBALL);
				全局.L = 全局.H[全局.J];
				大字体信息(所有玩家(所有队伍), 自定义字符串("已新建击杀球，该球体仅第{0}关有效！", 事件玩家.A));
			End;
		Else If(事件玩家.E == 3);
			If(事件玩家.A == 0);
				大字体信息(所有玩家(所有队伍), 自定义字符串("第0关不可放置弹球"));
			Else;
				修改全局变量(TQ, 添加至数组, 所选位置(事件玩家));
				全局.TQ1 = 数量(全局.TQ) - 1;
				全局.EditMode[全局.TQ1] = 10;
				全局.TQ5[全局.TQ1] = 假;
				全局.TQ6[全局.TQ1] = 假;
				For 全局变量(NANBA, 0, 数量(全局.TQ), 1);
					消除效果(全局.TQ2[全局.NANBA]);
				End;
				全局.TQ2 = 空数组;
				调用子程序(pinball);
				全局.TQ3 = 全局.TQ[全局.TQ1];
				修改全局变量(pinballnumber, 添加至数组, 事件玩家.A);
				大字体信息(所有玩家(所有队伍), 自定义字符串("已新建弹球，该球仅第{0}关有效！", 事件玩家.A));
			End;
	}
}

禁用 规则("删除点位")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		If(事件玩家.E == 1);
			修改全局变量(A, 根据索引从数组中移除, 全局.B);
			修改全局变量(C, 根据索引从数组中移除, 全局.B);
			根据条件跳过(全局.B <= 0, 1);
			全局.B -= 1;
			小字体信息(所有玩家(所有队伍), 自定义字符串("已删除点位"));
		Else If(事件玩家.E == 2 && 数量(全局.H) != 0);
			修改全局变量(H, 根据索引从数组中移除, 全局.J);
			修改全局变量(I, 根据索引从数组中移除, 全局.J);
			修改全局变量(killballnumber, 根据索引从数组中移除, 全局.J);
			消除效果(全局.K[全局.J]);
			修改全局变量(K, 根据索引从数组中移除, 全局.J);
			根据条件跳过(全局.J <= 0, 1);
			全局.J -= 1;
			全局.L = 全局.H[全局.J];
		Else If(事件玩家.E == 3 && 数量(全局.TQ) != 0);
			修改全局变量(TQ, 根据索引从数组中移除, 全局.TQ1);
			修改全局变量(EditMode, 根据索引从数组中移除, 全局.TQ1);
			修改全局变量(TQ5, 根据索引从数组中移除, 全局.TQ1);
			修改全局变量(TQ6, 根据索引从数组中移除, 全局.TQ1);
			消除效果(全局.TQ2[全局.TQ1]);
			修改全局变量(TQ2, 根据索引从数组中移除, 全局.TQ1);
			修改全局变量(pinballnumber, 根据索引从数组中移除, 全局.TQ1);
			根据条件跳过(全局.TQ1 <= 0, 1);
			全局.TQ1 -= 1;
			全局.TQ3 = 全局.TQ[全局.TQ1];
		End;
	}
}

禁用 规则("修改点位")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		小字体信息(所有玩家(所有队伍), 数量(全局.A[全局.B]) != 0 ? 自定义字符串("点{0}传送点已删除", 全局.B) : 自定义字符串(""));
		全局.A[全局.B] = 所选位置(事件玩家) - 矢量(0, 0, 0);
		小字体信息(所有玩家(所有队伍), 自定义字符串("已移动点位"));
	}
}

禁用 规则("添加传送点")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(按钮被按下(主机玩家, 按钮(互动)) && 按钮被按下(主机玩家, 按钮(装填))) == 真;
		数量(全局.A) > 1;
		主机玩家.E == 1;
		全局.B > 0;
		按钮被按下(主机玩家, 按钮(近身攻击)) == 假;
	}

	动作
	{
		根据条件中止(按钮被按下(主机玩家, 按钮(近身攻击)) == 真);
		全局.A[全局.B] = 数组(数量(全局.A[全局.B]) != 0 ? 全局.A[全局.B][0] : 全局.A[全局.B], 所选位置(主机玩家));
		小字体信息(所有玩家(所有队伍), 自定义字符串("已为点{0}添加传送点", 全局.B));
	}
}

禁用 规则("移动选中点位")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		If(事件玩家.E == 1);
			根据条件跳过(全局.B <= 0, 1);
			全局.B -= 1;
		Else If(事件玩家.E == 2);
			根据条件跳过(全局.J <= 0, 2);
			全局.J -= 1;
			全局.L = 全局.H[全局.J];
		Else If(事件玩家.E == 3);
			根据条件跳过(全局.TQ1 <= 0, 2);
			全局.TQ1 -= 1;
			全局.TQ3 = 全局.TQ[全局.TQ1];
		End;
	}
}

禁用 规则("移动选中点位")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		If(事件玩家.E == 1);
			根据条件跳过(全局.B == 数量(全局.A) - 1, 1);
			全局.B += 1;
		Else If(事件玩家.E == 2);
			根据条件跳过(全局.J == 数量(全局.H) - 1, 2);
			全局.J += 1;
			全局.L = 全局.H[全局.J];
		Else If(事件玩家.E == 3);
			根据条件跳过(全局.TQ1 == 数量(全局.TQ) - 1, 2);
			全局.TQ1 += 1;
			全局.TQ3 = 全局.TQ[全局.TQ1];
	}
}

禁用 规则("弹球启用关闭终极技能")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(按钮被按下(事件玩家, 按钮(终极技能)) && 按钮被按下(事件玩家, 按钮(主要攻击模式))) == 真;
		事件玩家 == 主机玩家;
		事件玩家.E == 3;
		数量(全局.TQ) != 0;
	}

	动作
	{
		等待(1, 无视条件);
		If(全局.TQ5[全局.TQ1] == 假);
			全局.TQ5[全局.TQ1] = 真;
		Else If(全局.TQ5[全局.TQ1] == 真);
			全局.TQ5[全局.TQ1] = 假;
		End;
	}
}

禁用 规则("弹球启用关闭技能1")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(按钮被按下(事件玩家, 按钮(辅助攻击模式)) && 按钮被按下(事件玩家, 按钮(终极技能))) == 真;
		事件玩家 == 主机玩家;
		事件玩家.E == 3;
		数量(全局.TQ) != 0;
	}

	动作
	{
		等待(1, 无视条件);
		If(全局.TQ6[全局.TQ1] == 假);
			全局.TQ6[全局.TQ1] = 真;
		Else If(全局.TQ6[全局.TQ1] == 真);
			全局.TQ6[全局.TQ1] = 假;
		End;
	}
}

禁用 规则("指引类文本【操作指引】")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("{{0}}", 主机玩家.K, 添加至数组(添加至数组(添加至数组(添加至数组(空数组, 0), 自定义字符串(
			"互动+鼠标左键=在玩家位置新建点位\r\n互动+鼠标右键=删除选中点位\r\n互动+R=为当前点位添加传送点\r\n互动+Q=修改选中点位至玩家位置（不打乱点位顺序）\r\n互动+蹲=向后（0后1前）移动选中点位\r\n互动+跳跃=向前移动选中点位")),
			自定义字符串(
			"互动+鼠标左键=新建球体\r\n互动+鼠标右键=删除球体\r\n互动+蹲下=向后选择球体\r\n互动+跳跃=向前选择球体\r\nE+跳跃=放大球体\r\nE+蹲下=缩小球体\r\nE+左键=前移球体（位置）\r\nE+右键=后移球体（位置）\r\n选中的球体为粉红色")),
			自定义字符串(
			"互动+鼠标左键=新建弹球\r\n互动+鼠标右键=删除弹球\r\n互动+蹲下=向后选择弹球\r\n互动+跳跃=向前选择弹球\r\nE+跳跃=放大弹球弹力\r\nE+蹲下=缩小弹球弹力\r\nE+左键=前移弹球（位置）\r\nE+右键=后移弹球（位置）\r\n选中的弹球为紫色"))
			[主机玩家.E], 自定义字符串("长按近战打开指引文本")), 右边, -3, 颜色(白色), 颜色(白色), 颜色(黄色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("{{0}}", 主机玩家.K, 自定义字符串(
			"以下为所有玩家可进行的操作：                                 \r\n（点位编辑模式）长按E穿墙\r\n蹲+鼠标左=跳关，蹲+右键=退关\r\n"), 自定义字符串("")), 右边, -2, 颜色(白色), 颜色(
			白色), 颜色(绿色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("{{0}}", 主机玩家.K, 自定义字符串(
			"房主长按“近战”可关闭操作指引文本\r\n此制作器由易忘#51876设计制作\r\n后续更新：五里雾中#51574\r\n近期更新：2022/5/21即时存档(易忘)\r\n"), 自定义字符串("")), 右边, -1, 颜色(白色), 颜色(
			白色), 颜色(红色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("{{0}}", 主机玩家.K, 自定义字符串(
			"①将点位设置确认完毕后，按“互动+近战+换弹”清除多余数据\r\n②ESC打开“工坊查看器”，将右下角的变量目标改成第一个“全局”\r\n③点击（X）符号的按钮复制数据，再ESC打开“工坊编辑器”，在规则32处录入数据\r\n④将规则1-26关闭"),
			自定义字符串("")), 顶部, -3, 颜色(白色), 颜色(白色), 颜色(黄色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 自定义字符串("{{0}}", 主机玩家.K, 添加至数组(添加至数组(添加至数组(添加至数组(空数组, 0), 自定义字符串("长按SHIFT修改编辑模式\r\n当前编辑模式为：点位")), 自定义字符串(
			"长按SHIFT修改编辑模式\r\n当前编辑模式为：击杀球")), 自定义字符串("长按SHIFT修改编辑模式\r\n当前编辑模式为：弹球"))[主机玩家.E], 自定义字符串("操作指引已关闭")), 无, 添加至数组(添加至数组(添加至数组(
			添加至数组(空数组, 自定义字符串("")), 自定义字符串("")), 自定义字符串("")), 自定义字符串("长按Q+左设置终极技能开启关闭\r\n长按Q+右键设置技能1开启关闭。"))[主机玩家.E], 左边, -6, 颜色(红色), 颜色(
			白色), 颜色(橙色), 可见和字符串, 默认可见度);
	}
}

禁用 规则("指引类文本、效果【包含点位显示】")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		创建图标(所有玩家(所有队伍), 全局.A[全局.B] + 矢量(0, 0.600, 0), 箭头：向下, 可见和位置, 颜色(红色), 真);
		创建地图文本(所有玩家(所有队伍), 自定义字符串("已选中该点"), 全局.A[全局.B] + 矢量(0, 0.500, 0), 1.600, 不要截取, 可见，位置和字符串, 颜色(红色), 默认可见度);
		禁用 创建效果(所有玩家(所有队伍), 球体, 颜色(红色), 全局.H[全局.J], 全局.I[全局.J], 可见，位置和半径);
		创建效果(所有玩家(所有队伍), 有益光环, 颜色(亮紫色), 全局.TQ[全局.TQ1], 1, 可见，位置和半径);
		"轻易别打开，动作太长会"
		创建HUD文本(所有玩家(所有队伍), 添加至数组(添加至数组(添加至数组(添加至数组(空数组, 0), 自定义字符串("当前选中点位序号:{0}", 全局.B)), 自定义字符串("当前球体半径:{0}", 全局.I[全局.J])), 自定义字符串(
			"当前弹球弹力:{0}", 全局.EditMode[全局.TQ1]))[主机玩家.E], 无, 添加至数组(添加至数组(添加至数组(添加至数组(空数组, 自定义字符串("")), 自定义字符串("")), 自定义字符串("")), 自定义字符串(
			"若无弹球无需理会\r\n当前弹球是否开启终极技能:{0}\r\n当前弹球是否开启技能1:{1}", 全局.TQ5[全局.TQ1], 全局.TQ6[全局.TQ1]))[主机玩家.E], 顶部, -6, 颜色(红色), 颜色(白色), 颜色(橙色),
			可见和字符串, 默认可见度);
		创建地图文本(所有玩家(所有队伍), 自定义字符串("已选中该击杀球"), 全局.H[全局.J], 1.600, 不要截取, 可见，位置和字符串, 颜色(天蓝色), 默认可见度);
		创建效果(所有玩家(所有队伍), 球, 颜色(红色), 全局.L, 1, 可见，位置和半径);
		创建地图文本(主机玩家, 字符串("{0} 米", 相距距离(主机玩家, 全局.L)), 全局.L - 矢量(0, 1.500, 0), 1.500, 不要截取, 可见，位置和字符串, 颜色(红色), 默认可见度);
		创建图标(所有玩家(所有队伍), 全局.H[全局.J] + 矢量(0, 0.600, 0), 箭头：向下, 可见和位置, 颜色(红色), 真);
	}
}

禁用 规则("清除所有点位显示")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		For 全局变量(B, 数量(全局.C) - 1, 0, -1);
			消除效果(全局.C[全局.B]);
			修改全局变量(C, 根据索引从数组中移除, 全局.B);
		End;
		全局.B = -2;
	}
}

禁用 规则("显示所有点位")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.B == -2;
	}

	动作
	{
		For 全局变量(B, 0, 数量(全局.A), 1);
			创建效果(所有玩家(所有队伍), 环, 颜色(红色), 全局.A[全局.B], 1, 可见);
			修改全局变量(C, 添加至数组, 最后创建的实体);
		End;
	}
}

禁用 规则("跳关")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		事件玩家.A < 数量(全局.A) - 1;
	}

	动作
	{
		事件玩家.A += 1;
		传送(事件玩家, 全局.A[事件玩家.A]);
		在索引处修改全局变量(P, 事件玩家.A, 添加至数组, 事件玩家);
		在索引处修改全局变量(P, 事件玩家.A - 1, 根据值从数组中移除, 事件玩家);
	}
}

禁用 规则("退关")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		事件玩家.A != 0;
	}

	动作
	{
		传送(事件玩家, 全局.A[事件玩家.A - 1]);
		事件玩家.A -= 1;
		在索引处修改全局变量(P, 事件玩家.A, 添加至数组, 事件玩家);
		在索引处修改全局变量(P, 事件玩家.A + 1, 根据值从数组中移除, 事件玩家);
	}
}

禁用 规则("------------------------------------------------------以上规则正式比赛时关闭------------------------------------------------------")
{
	事件
	{
		持续 - 全局;
	}
}

规则("全局设置")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		禁用查看器录制;
		关闭游戏预设复生模式(所有玩家(所有队伍));
		关闭游戏预设完成条件;
		关闭游戏预设计分模式;
		关闭游戏预设音乐模式;
		比赛时间暂停;
		全局.Dao = 空数组;
		全局.SHIFT = 空数组;
		全局.pinballnumber = 空数组;
		全局.killballnumber = 空数组;
		全局.A = 空数组;
		全局.F = 空数组;
		全局.G = 空数组;
		全局.H = 空数组;
		全局.I = 空数组;
		全局.K = 空数组;
		全局.J = 0;
		全局.Q = 空数组;
		全局.TQ = 空数组;
		全局.TQ2 = 空数组;
		全局.EditMode = 空数组;
		全局.TQ1 = 0;
		全局.TQ5 = 空数组;
		全局.TQ6 = 空数组;
		等待(1, 无视条件);
		全局.B = 数量(全局.A) - 1;
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串(
			"\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"),
			顶部, -1, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		调用子程序(KILLBALL);
		等待(2, 无视条件);
		调用子程序(pinball);
		If(当前游戏模式 == 游戏模式(突击模式));
			创建HUD文本(所有玩家(所有队伍), 自定义字符串(""), 无, 字符串("{0} {1} {2}", 自定义字符串("距离炸房还剩"), 270 - 取整(总计消耗时间 / 60, 下), 自定义字符串("分钟")), 右边, -11, 颜色(白色),
				颜色(白色), 颜色(红色), 可见和字符串, 默认可见度);
		Else;
			创建HUD文本(所有玩家(所有队伍), 自定义字符串(""), 无, 字符串("{0} {1} {2}", 自定义字符串("距离炸房还剩"), 90 - 取整(总计消耗时间 / 60, 下), 自定义字符串("分钟")), 右边, -11, 颜色(白色),
				颜色(白色), 颜色(红色), 可见和字符串, 默认可见度);
		End;
		全局.save = 空数组;
		"Top 5 best times hud text"
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("Top 5 "), 右边, -8, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		"1th Place"
		创建HUD文本(全局.toplistSortedTimes[1] != 无 ? 所有玩家(所有队伍) : 无, 英雄图标字符串(英雄(源氏)), 全局.toplistPlayers[数组值的索引(全局.toplistTimes,
			全局.toplistSortedTimes[1])], 自定义字符串("{0} 秒", 全局.toplistSortedTimes[1]), 右边, -7, 自定义颜色(158, 255, 187, 255), 自定义颜色(158, 255, 187,
			255), 自定义颜色(158, 255, 187, 255), 可见和字符串, 默认可见度);
		"2nd Place"
		创建HUD文本(全局.toplistSortedTimes[2] != 无 ? 所有玩家(所有队伍) : 无, 英雄图标字符串(英雄(源氏)), 全局.toplistPlayers[数组值的索引(全局.toplistTimes,
			全局.toplistSortedTimes[2])], 自定义字符串("{0} 秒", 全局.toplistSortedTimes[2]), 右边, -6, 自定义颜色(158, 255, 187, 255), 自定义颜色(158, 255, 187,
			255), 自定义颜色(158, 255, 187, 255), 可见和字符串, 默认可见度);
		"3rd Place"
		创建HUD文本(全局.toplistSortedTimes[3] != 无 ? 所有玩家(所有队伍) : 无, 英雄图标字符串(英雄(源氏)), 全局.toplistPlayers[数组值的索引(全局.toplistTimes,
			全局.toplistSortedTimes[3])], 自定义字符串("{0} 秒", 全局.toplistSortedTimes[3]), 右边, -5, 自定义颜色(158, 255, 187, 255), 自定义颜色(158, 255, 187,
			255), 自定义颜色(158, 255, 187, 255), 可见和字符串, 默认可见度);
		"4th Place"
		创建HUD文本(全局.toplistSortedTimes[4] != 无 ? 所有玩家(所有队伍) : 无, 英雄图标字符串(英雄(源氏)), 全局.toplistPlayers[数组值的索引(全局.toplistTimes,
			全局.toplistSortedTimes[4])], 自定义字符串("{0} 秒", 全局.toplistSortedTimes[4]), 右边, -4, 自定义颜色(158, 255, 187, 255), 自定义颜色(158, 255, 187,
			255), 自定义颜色(158, 255, 187, 255), 可见和字符串, 默认可见度);
		"5th Place"
		创建HUD文本(全局.toplistSortedTimes[5] != 无 ? 所有玩家(所有队伍) : 无, 英雄图标字符串(英雄(源氏)), 全局.toplistPlayers[数组值的索引(全局.toplistTimes,
			全局.toplistSortedTimes[5])], 自定义字符串("{0} 秒", 全局.toplistSortedTimes[5]), 右边, -3, 自定义颜色(158, 255, 187, 255), 自定义颜色(158, 255, 187,
			255), 自定义颜色(158, 255, 187, 255), 可见和字符串, 默认可见度);
		"Other player best times hud text"
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("Other"), 右边, -2, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		禁用 创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"), 左边, -2, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串,
			默认可见度);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串(
			"       无敌探点｜Ｒ+V \r\n       重新开始｜F+蹲+E\r\n       死亡观战｜长按F \r\n开关快速回城｜长按R \r\n       快速回城｜单击R\r\n"), 右边, -10, 颜色(白色), 颜色(白色),
			颜色(白色), 可见, 默认可见度);
		全局.kz_xs = 地图工坊设置开关(自定义字符串("扩展功能"), 自定义字符串("限时通关  by：易忘"), 假, 0);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串(
			"\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n代码分享交流网站:genjiparkour.cn\r\n源氏跑酷交流群：608291499\r\n作图交流兼SHE的粉丝群:711065881 "),
			左边, 0, 颜色(白色), 颜色(白色), 颜色(黄色), 可见和字符串, 默认可见度);
	}
}

规则("【子程序】-【点位效果】")
{
	事件
	{
		子程序;
		Sub0;
	}

	动作
	{
		创建效果(事件玩家, 环, 颜色(天蓝色), 数量(全局.A[事件玩家.A]) != 0 ? 全局.A[事件玩家.A][1] : 全局.A[事件玩家.A], 1, 可见，位置和半径);
		事件玩家.B[0] = 最后创建的实体;
		创建效果(事件玩家, 环, 颜色(灰绿色), 全局.A[事件玩家.A + 1], 1, 可见，位置和半径);
		事件玩家.B[1] = 最后创建的实体;
		创建效果(事件玩家, 光柱, 颜色(白色), 全局.A[事件玩家.A + 1], 1, 可见，位置和半径);
		事件玩家.B[2] = 最后创建的实体;
		创建图标(事件玩家, 全局.A[事件玩家.A + 1] + 矢量(0, 1, 0), 箭头：向下, 可见和位置, 颜色(天蓝色), 真);
		事件玩家.B[3] = 最后创建的实体;
		创建地图文本(事件玩家, 自定义字符串("{0}到这里来", 全局.kz_xs ? 自定义字符串("{0}S内 ", 5 - 事件玩家.L) : 自定义字符串("")), 全局.A[事件玩家.A + 1], 1.500, 不要截取, 可见，位置和字符串, 颜色(
			白色), 默认可见度);
		事件玩家.B[4] = 上一个文本ID;
	}
}

规则("【子程序】-【开始游戏】")
{
	事件
	{
		子程序;
		Sub1;
	}

	动作
	{
		If(数量(全局.A) != 0);
			If((数组包含(全局.save, 自定义字符串("{0}", 事件玩家)) && 全局.kz_xs == 假) == 真);
				禁用 If(数组包含(全局.save, 自定义字符串("{0}", 事件玩家)) == 真);
				事件玩家.A = 全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1];
				事件玩家.D = 全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 2];
				全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 3] = 事件玩家;
				全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 4] = 总计消耗时间;
				全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 5] = 0;
				全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 6] = 0;
				传送(事件玩家, 全局.A[全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1]] + 矢量(0, 1, 0));
			Else;
				传送(事件玩家, 全局.A[0] + 矢量(0, 1, 0));
				事件玩家.A = 0;
				事件玩家.D = 0;
				停止追踪玩家变量(事件玩家, ztjs);
				事件玩家.ztjs = 0;
				修改全局变量(save, 添加至数组, 数组(自定义字符串("{0}", 事件玩家), 事件玩家.A, 事件玩家.D, 事件玩家, 总计消耗时间, 0, 0));
			End;
		End;
		追踪玩家变量频率(事件玩家, D, 绝对值(9999999.000), 1, 速率及最终值);
		事件玩家.G = 0;
		事件玩家.H = 空数组;
		If(事件玩家.E < 1);
			设置启用技能 1(事件玩家, 假);
			设置启用终极技能(事件玩家, 假);
		Else;
			设置启用技能 1(事件玩家, 真);
			设置启用终极技能(事件玩家, 真);
			设置终极技能充能(事件玩家, 100);
		End;
		设置状态(事件玩家, 无, 相移, 9999);
		设置状态(事件玩家, 无, 无敌, 9999);
		在索引处修改全局变量(P, 事件玩家.A, 添加至数组, 事件玩家);
		事件玩家.C = 0;
	}
}

规则("【子程序】-【击杀球效果显示】")
{
	事件
	{
		子程序;
		KILLBALL;
	}

	动作
	{
		根据条件中止(全局.H == 空数组);
		全局.NANBA = 0;
		创建效果(已排序的数组(全局.P[全局.killballnumber[0]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 1;
		创建效果(已排序的数组(全局.P[全局.killballnumber[1]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 2;
		创建效果(已排序的数组(全局.P[全局.killballnumber[2]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 3;
		创建效果(已排序的数组(全局.P[全局.killballnumber[3]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 4;
		创建效果(已排序的数组(全局.P[全局.killballnumber[4]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 5;
		创建效果(已排序的数组(全局.P[全局.killballnumber[5]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 6;
		创建效果(已排序的数组(全局.P[全局.killballnumber[6]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 7;
		创建效果(已排序的数组(全局.P[全局.killballnumber[7]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 8;
		创建效果(已排序的数组(全局.P[全局.killballnumber[8]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 9;
		创建效果(已排序的数组(全局.P[全局.killballnumber[9]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 10;
		创建效果(已排序的数组(全局.P[全局.killballnumber[10]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 11;
		创建效果(已排序的数组(全局.P[全局.killballnumber[11]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 12;
		创建效果(已排序的数组(全局.P[全局.killballnumber[12]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 13;
		创建效果(已排序的数组(全局.P[全局.killballnumber[13]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 14;
		创建效果(已排序的数组(全局.P[全局.killballnumber[14]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 15;
		创建效果(已排序的数组(全局.P[全局.killballnumber[15]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 16;
		创建效果(已排序的数组(全局.P[全局.killballnumber[16]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 17;
		创建效果(已排序的数组(全局.P[全局.killballnumber[17]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 18;
		创建效果(已排序的数组(全局.P[全局.killballnumber[18]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 19;
		创建效果(已排序的数组(全局.P[全局.killballnumber[19]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 20;
		创建效果(已排序的数组(全局.P[全局.killballnumber[20]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 21;
		创建效果(已排序的数组(全局.P[全局.killballnumber[21]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 22;
		创建效果(已排序的数组(全局.P[全局.killballnumber[22]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 23;
		创建效果(已排序的数组(全局.P[全局.killballnumber[23]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 24;
		创建效果(已排序的数组(全局.P[全局.killballnumber[24]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 25;
		创建效果(已排序的数组(全局.P[全局.killballnumber[25]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 26;
		创建效果(已排序的数组(全局.P[全局.killballnumber[26]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 27;
		创建效果(已排序的数组(全局.P[全局.killballnumber[27]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 28;
		创建效果(已排序的数组(全局.P[全局.killballnumber[28]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 29;
		创建效果(已排序的数组(全局.P[全局.killballnumber[29]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 30;
		创建效果(已排序的数组(全局.P[全局.killballnumber[30]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 31;
		创建效果(已排序的数组(全局.P[全局.killballnumber[31]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 32;
		创建效果(已排序的数组(全局.P[全局.killballnumber[32]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 33;
		创建效果(已排序的数组(全局.P[全局.killballnumber[33]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 34;
		创建效果(已排序的数组(全局.P[全局.killballnumber[34]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 35;
		创建效果(已排序的数组(全局.P[全局.killballnumber[35]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 36;
		创建效果(已排序的数组(全局.P[全局.killballnumber[36]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 37;
		创建效果(已排序的数组(全局.P[全局.killballnumber[37]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 38;
		创建效果(已排序的数组(全局.P[全局.killballnumber[38]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 39;
		创建效果(已排序的数组(全局.P[全局.killballnumber[39]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 40;
		创建效果(已排序的数组(全局.P[全局.killballnumber[40]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 41;
		创建效果(已排序的数组(全局.P[全局.killballnumber[41]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 42;
		创建效果(已排序的数组(全局.P[全局.killballnumber[42]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 43;
		创建效果(已排序的数组(全局.P[全局.killballnumber[43]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 44;
		创建效果(已排序的数组(全局.P[全局.killballnumber[44]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 45;
		创建效果(已排序的数组(全局.P[全局.killballnumber[45]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 46;
		创建效果(已排序的数组(全局.P[全局.killballnumber[46]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 47;
		创建效果(已排序的数组(全局.P[全局.killballnumber[47]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 48;
		创建效果(已排序的数组(全局.P[全局.killballnumber[48]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 49;
		创建效果(已排序的数组(全局.P[全局.killballnumber[49]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
		全局.NANBA = 50;
		创建效果(已排序的数组(全局.P[全局.killballnumber[50]], 当前数组元素), 球体, 颜色(蓝色), 全局.H[全局.NANBA], 全局.I[全局.NANBA], 可见);
		修改全局变量(K, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.H) - 1);
	}
}

规则("【子程序】-【弹球效果显示】")
{
	事件
	{
		子程序;
		pinball;
	}

	动作
	{
		根据条件中止(全局.TQ == 空数组);
		全局.NANBA = 0;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[0]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 1;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[1]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 2;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[2]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 3;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[3]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 4;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[4]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 5;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[5]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 6;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[6]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 7;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[7]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 8;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[8]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 9;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[9]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 10;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[10]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 11;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[11]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 12;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[12]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 13;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[13]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 14;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[14]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 15;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[15]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 16;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[16]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 17;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[17]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 18;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[18]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 19;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[19]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 20;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[20]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 21;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[21]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 22;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[22]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 23;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[23]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 24;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[24]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 25;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[25]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 26;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[26]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 27;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[27]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 28;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[28]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 29;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[29]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 30;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[30]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 31;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[31]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 32;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[32]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 33;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[33]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 34;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[34]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 35;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[35]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 36;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[36]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 37;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[37]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 38;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[38]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 39;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[39]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 40;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[40]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 41;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[41]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 42;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[42]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 43;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[43]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 44;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[44]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 45;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[45]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 46;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[46]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 47;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[47]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 48;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[48]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 49;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[49]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 50;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[50]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 51;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[51]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 52;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[52]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 53;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[53]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 54;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[54]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 55;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[55]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 56;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[56]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 57;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[57]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 58;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[58]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 59;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[59]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 60;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[60]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 61;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[61]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 62;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[62]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 63;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[63]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 64;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[64]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 65;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[65]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 66;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[66]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 67;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[67]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 68;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[68]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 69;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[69]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 70;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[70]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 71;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[71]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 72;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[72]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 73;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[73]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 74;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[74]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
		全局.NANBA = 75;
		创建效果(已排序的数组(全局.P[全局.pinballnumber[75]], 当前数组元素), 球, 颜色(绿色), 全局.TQ[全局.NANBA], 1, 可见);
		修改全局变量(TQ2, 添加至数组, 最后创建的实体);
		根据条件中止(全局.NANBA == 数量(全局.TQ) - 1);
	}
}

规则("数据录入---------------------------------------------------录入前先按 填装+互动+近战 清空多余数据再复制粘贴")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.A = 数组(矢量(-17.001, 9.173, -90.515), 矢量(-17.001, 9.173, -90.515), 矢量(-16.050, 9, -72.942), 矢量(-2.581, 2.525, -82.048), 矢量(15.246,
			4, -73.361), 矢量(25.951, 1.915, -60.467), 矢量(11.627, 3.394, -54.618), 矢量(-1.838, 4, -62.834), 矢量(7.919, -1.904, -78.652), 矢量(
			17.519, 0.836, -72.014), 矢量(31.945, 1.794, -60.392), 矢量(41.761, 1.666, -58.036), 矢量(39.129, 2, -34.213), 矢量(23.953, 0.615,
			-30.619), 矢量(7.367, 0, -30.651), 矢量(1.568, 5, -41.219), 矢量(-7.962, 5, -35.295), 矢量(-6.370, 7, -22.077), 矢量(-0.457, 7.947,
			-9.976), 矢量(12.497, 0, -26.570), 矢量(7.759, 0.266, -12.339), 矢量(4.819, 7.727, -1.828), 矢量(18.296, 4.086, 8.843), 矢量(11.637,
			11.223, 20.466), 矢量(2.760, 2.415, 37.551), 矢量(-4.062, 3.975, 20.771), 矢量(-15.756, 3.954, 11.315), 矢量(-14.379, -0.106, -5.500),
			矢量(-5.479, 7.979, -10.325), 矢量(-13.409, 1, -26.978), 矢量(-8.971, 5, -37.112), 矢量(1.785, 5, -41.175), 矢量(13.291, 7.071, -48.816),
			矢量(13.123, 6.739, -20.028), 矢量(13.776, 0.956, -4.247), 矢量(29.361, 10.451, -3.300), 矢量(48.035, 5.999, -12.767), 矢量(66.717,
			-0.310, -8.568), 矢量(63.129, 0.615, 6.173), 矢量(50.069, 6, 10.286), 矢量(62.101, -2.003, 26.919), 矢量(56.438, 4.306, 14.197), 矢量(
			40.694, 0.316, 24.889), 矢量(34.527, 13.953, 22.321), 矢量(28.889, 10.435, 3.693), 矢量(40.179, 6, -5.517), 矢量(48.303, 6, 6.037), 矢量(
			47.908, 4.999, -17.308), 矢量(53.595, 4.398, -29.901), 矢量(39.109, -0.012, -20.006), 矢量(30.607, 2.524, -13.246), 矢量(28.344,
			10.438, 3.848), 矢量(9.374, 4.032, 7.534), 矢量(3.563, 8.002, -10.988), 矢量(3.115, 1, -29.938), 矢量(-10.071, 5, -36.595), 矢量(-7.201,
			3.573, -51.909), 矢量(-20.571, 4, -57.515), 矢量(-36.188, 1, -63.877), 矢量(-23.021, -0.366, -72.917), 矢量(-15.056, 9, -70.805), 矢量(
			3.357, 5, -70.872), 矢量(-16.550, 9.173, -90.809));
		全局.H = 数组(矢量(44.196, 6, 0.015), 矢量(-10.073, 4.071, -16.123), 矢量(40.185, -2.199, -41.328), 矢量(39.054, 0.756, -42.784));
		全局.I = 数组(2.600, 5, 5, 5);
		全局.TQ = 数组();
		全局.EditMode = 数组();
		全局.TQ5 = 数组();
		全局.TQ6 = 数组();
		全局.killballnumber = 数组(45, 53, 11, 11);
		全局.pinballnumber = 数组();
		全局.save = 数组(0, 122.233, 0, 128.735, 10.016, 0);
	}
}

规则("开局设置")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		设置造成伤害(事件玩家, 0);
		If(数组包含(全局.Q, 事件玩家) == 假);
			创建HUD文本(事件玩家, 事件玩家.J == 1 ? 自定义字符串("爬墙已用") : 自定义字符串("爬墙未用"), 无, 无, 左边, -1, 事件玩家.J == 1 ? 颜色(红色) : 颜色(橙色), 颜色(白色), 颜色(白色),
				可见，字符串和颜色, 默认可见度);
			创建HUD文本(事件玩家, 无, 无, 字符串("{0} {1}", 自定义字符串("当前关卡"), 字符串("{0} / {1}", 事件玩家.A, 数量(全局.A) - 1)), 顶部, -4, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串,
				默认可见度);
			创建HUD文本(事件玩家, 无, 无, 字符串("{0} {1} {2}", 自定义字符串("时间"), 字符串("{0}秒", 事件玩家.D), 全局.kz_xs ? 自定义字符串(" | 限时:{0}", 事件玩家.L) : 自定义字符串("")), 左边,
				-2, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		End;
		修改全局变量(Q, 添加至数组, 事件玩家);
		"子程序1为游戏的初始化设置"
		调用子程序(Sub1);
		对所有玩家启用死亡回放(事件玩家);
		启用死亡回放时目标的HUD(事件玩家);
		"玩家F：自杀防止复活"
		事件玩家.F = 0;
		"玩家I：教程HUD"
		事件玩家.I = 2;
		"玩家J：爬墙提示HUD"
		事件玩家.J = 2;
		"子程序0为检查点效果显示"
		调用子程序(Sub0);
		"空白处填写您好友的名字"
		If(自定义字符串("请打我队友") == 自定义字符串("{0}", 事件玩家));
			移除玩家(事件玩家);
		End;
	}
}

规则("抵达检查点")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		相距距离(事件玩家, 全局.A[事件玩家.A + 1]) <= 1.400;
		事件玩家.A < 数量(全局.A) - 1;
		在地面上(事件玩家) == 真;
		(事件玩家.E >= 1 || 事件玩家.C == 0) == 真;
	}

	动作
	{
		事件玩家.A += 1;
		If(全局.kz_xs);
			小字体信息(事件玩家, 自定义字符串("已抵达{0}/{1}", 事件玩家.A, 数量(全局.A) - 1));
		Else;
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
			修改全局变量(save, 根据值从数组中移除, 自定义字符串("{0}", 事件玩家));
			修改全局变量(save, 添加至数组, 数组(自定义字符串("{0}", 事件玩家), 事件玩家.A, 事件玩家.D, 事件玩家, 总计消耗时间, 0, 0));
			播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 100);
			播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(天蓝色), 全局.A[事件玩家.A] + 矢量(0, 1.500, 0), 4);
			大字体信息(事件玩家, 字符串("{0} {1}", 自定义字符串("已抵达"), 字符串("{0} / {1}", 事件玩家.A, 数量(全局.A) - 1)));
		End;
		在索引处修改全局变量(P, 事件玩家.A, 添加至数组, 事件玩家);
		在索引处修改全局变量(P, 事件玩家.A - 1, 根据值从数组中移除, 事件玩家);
		If(事件玩家.E < 1);
			设置启用终极技能(事件玩家, 假);
			设置启用技能 1(事件玩家, 假);
		End;
		根据条件中止(事件玩家.E >= 1);
		If(事件玩家.A >= 数量(全局.A) - 1);
			设置启用技能 1(事件玩家, 真);
			设置启用终极技能(事件玩家, 真);
			设置终极技能充能(事件玩家, 100);
			停止追踪玩家变量(事件玩家, D);
			大字体信息(所有玩家(所有队伍), 字符串("{0} {1} {2}", 事件玩家, 自定义字符串("已通关！所用时间"), 字符串("{0}秒", 事件玩家.D)));
			消除效果(事件玩家.B[0]);
			消除效果(事件玩家.B[1]);
			消除效果(事件玩家.B[2]);
			消除图标(事件玩家.B[3]);
			消除地图文本(事件玩家.B[4]);
			"F传送门开关"
			修改全局变量(F, 添加至数组, 事件玩家);
			"G传送门开关"
			修改全局变量(G, 添加至数组, 事件玩家);
			"H传送门字符串"
			事件玩家.H = 2;
		End;
		If(全局.kz_xs == 真);
			事件玩家.L = 0;
			追踪玩家变量频率(事件玩家, L, 10, 1, 速率及最终值);
		End;
	}
}

规则("显示")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		"空白处填写您好友的名字"
		If(自定义字符串("五里雾中") == 自定义字符串("{0}", 事件玩家));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("萌新"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		Else If(自定义字符串("Crazydouzi") == 自定义字符串("{0}", 事件玩家));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("猛 男豆子"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		Else If(自定义字符串("淡风盈晓") == 自定义字符串("{0}", 事件玩家));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("摆烂金"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		Else If(自定义字符串("南烟吹北枳") == 自定义字符串("{0}", 事件玩家));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("北 老婆"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		Else If(自定义字符串("柠萌") == 自定义字符串("{0}", 事件玩家));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("柠萌好猛"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		Else If(自定义字符串("太阳的黑子") == 自定义字符串("{0}", 事件玩家));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("小 菜 鸡"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		Else If(自定义字符串("翎马") == 自定义字符串("{0}", 事件玩家));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("宝马"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		Else If(自定义字符串("喵喵酱") == 自定义字符串("{0}", 事件玩家));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("网恋教母"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(玫红), 默认可见度);
		Else If(自定义字符串("火锅") == 自定义字符串("{0}", 事件玩家));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("重庆火锅"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		Else If(自定义字符串("She") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("陈少来了！"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("まだまだ"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		Else If(自定义字符串("淮北也生橘") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("那个小可爱来了！"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("SHE的父皇"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		Else If(自定义字符串("Tea") == 自定义字符串("{0}", 事件玩家));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("战地记者"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		Else If(自定义字符串("小樱") == 自定义字符串("{0}", 事件玩家));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("淮北的爹"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
			大字体信息(所有玩家(所有队伍), 自定义字符串("那个小可爱的爹来了！"));
		Else If(自定义字符串("橡皮") == 自定义字符串("{0}", 事件玩家));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("思秋"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		Else If(自定义字符串("小向") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("RGB少年来了"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("ラストドール・エクスターミネーター"), 事件玩家, 1.300, 根据表面截取, 可见，位置和字符串, 颜色(灰色), 默认可见度);
		Else If(自定义字符串("从未手软") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("小甜兔来了~"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("小甜兔"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		Else If(自定义字符串("小小柚子") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("可爱的柚子来啦~"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("炒鸡无敌可爱的柚子吖~"), 事件玩家, 1.800, 根据表面截取, 可见，位置和字符串, 颜色(玫红), 默认可见度);
		Else If(自定义字符串("雪夜月音") == 自定义字符串("{0}", 事件玩家));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("Hanser小天使"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		Else If(自定义字符串("雾月屿枝") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("阴阳人来了"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("温两碗酒，要一碗茴香豆"), 事件玩家, 1.300, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		Else If(自定义字符串("冰霜之脚") == 自定义字符串("{0}", 事件玩家));
			移除玩家(事件玩家);
		Else If(自定义字符串("猫汐") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("无敌可爱的猫汐来啦~"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("炒鸡无敌可爱的猫汐吖~"), 事件玩家, 1.800, 根据表面截取, 可见，位置和字符串, 颜色(玫红), 默认可见度);
		Else If(自定义字符串("羽然") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("睡宝的爸爸来了！"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("睡宝之爹"), 事件玩家, 1.800, 根据表面截取, 可见，位置和字符串, 颜色(玫红), 默认可见度);
		Else If(自定义字符串("想被你睡") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("500强枪男来了~"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("500强枪男妹妹加我♥"), 事件玩家, 1.800, 根据表面截取, 可见，位置和字符串, 颜色(玫红), 默认可见度);
		Else If(自定义字符串("麦月十四") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("有人进来坐牢啦！"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("（⊙﹏⊙）"), 事件玩家, 1.800, 根据表面截取, 可见，位置和字符串, 颜色(黄色), 默认可见度);
		Else If(自定义字符串("Sienna") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("亚洲天团C位出道的S佬来了！！"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("超　　　　　　"), 事件玩家, 2, 根据表面截取, 可见，位置和字符串, 颜色(红色), 默认可见度);
			创建地图文本(所有玩家(所有队伍), 自定义字符串("可　　　　"), 事件玩家, 2, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
			创建地图文本(所有玩家(所有队伍), 自定义字符串("爱　　"), 事件玩家, 2, 根据表面截取, 可见，位置和字符串, 颜色(黄色), 默认可见度);
			创建地图文本(所有玩家(所有队伍), 自定义字符串("的"), 事件玩家, 2, 根据表面截取, 可见，位置和字符串, 颜色(绿色), 默认可见度);
			创建地图文本(所有玩家(所有队伍), 自定义字符串("　　S"), 事件玩家, 2, 根据表面截取, 可见，位置和字符串, 颜色(青绿色), 默认可见度);
			创建地图文本(所有玩家(所有队伍), 自定义字符串("　　　　 佬 "), 事件玩家, 2, 根据表面截取, 可见，位置和字符串, 颜色(蓝色), 默认可见度);
			创建地图文本(所有玩家(所有队伍), 自定义字符串("　　　　　　呀"), 事件玩家, 2, 根据表面截取, 可见，位置和字符串, 颜色(亮紫色), 默认可见度);
		End;
	}
}

规则("球体伤害")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		(全局.killballnumber[数组值的索引(全局.H, 已过滤的数组(全局.H, 相距距离(事件玩家, 当前数组元素) <= 全局.I[数组值的索引(全局.H, 当前数组元素)])[0])
			] == 事件玩家.A || 全局.killballnumber[数组值的索引(全局.H, 已过滤的数组(全局.H, 相距距离(事件玩家, 当前数组元素) <= 全局.I[数组值的索引(全局.H, 当前数组元素)])[1])
			] == 事件玩家.A || 全局.killballnumber[数组值的索引(全局.H, 已过滤的数组(全局.H, 相距距离(事件玩家, 当前数组元素) <= 全局.I[数组值的索引(全局.H, 当前数组元素)])[2])
			] == 事件玩家.A || 全局.killballnumber[数组值的索引(全局.H, 已过滤的数组(全局.H, 相距距离(事件玩家, 当前数组元素) <= 全局.I[数组值的索引(全局.H, 当前数组元素)])[3])] == 事件玩家.A)
			== 真;
		事件玩家.A != 0;
		事件玩家.A < 数量(全局.A) - 1;
		事件玩家.C == 0;
	}

	动作
	{
		击杀(事件玩家, 无);
	}
}

规则("弹球")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		(全局.pinballnumber[数组值的索引(全局.TQ, 已过滤的数组(全局.TQ, 相距距离(事件玩家, 当前数组元素) <= 1.200))] == 事件玩家.A) == 真;
		事件玩家.A != 0;
	}

	动作
	{
		施加推力(事件玩家, 上, 全局.EditMode[数组值的索引(全局.TQ, 已过滤的数组(全局.TQ, 相距距离(所选位置(事件玩家), 当前数组元素) <= 2))], 至地图, 取消相反运动);
		禁用 设置启用技能 1(事件玩家, 全局.TQ6[数组值的索引(全局.TQ, 已过滤的数组(全局.TQ, 相距距离(所选位置(事件玩家), 当前数组元素) <= 2))]);
		禁用 设置启用终极技能(事件玩家, 全局.TQ5[数组值的索引(全局.TQ, 已过滤的数组(全局.TQ, 相距距离(所选位置(事件玩家), 当前数组元素) <= 2))]);
		If(全局.TQ6[数组值的索引(全局.TQ, 已过滤的数组(全局.TQ, 相距距离(所选位置(事件玩家), 当前数组元素) <= 2))] == 真);
			设置启用技能 1(事件玩家, 真);
			小字体信息(事件玩家, 自定义字符串("SHIFT技能已开启"));
		End;
		If(全局.TQ5[数组值的索引(全局.TQ, 已过滤的数组(全局.TQ, 相距距离(所选位置(事件玩家), 当前数组元素) <= 2))] == 真);
			设置启用终极技能(事件玩家, 真);
			设置终极技能充能(事件玩家, 100);
			小字体信息(事件玩家, 自定义字符串("终极技能已开启"));
		End;
	}
}

规则("通关成绩显示")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		事件玩家.A == 数量(全局.A) - 1;
		事件玩家.E < 1;
	}

	动作
	{
		修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
		修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
		修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
		修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
		修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
		修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
		修改全局变量(save, 根据值从数组中移除, 自定义字符串("{0}", 事件玩家));
		If(事件玩家.B[7] == 无);
			事件玩家.T = 事件玩家.D;
			创建HUD文本(数组包含(全局.toplistSortedTimes, 全局.toplistTimes[数组值的索引(全局.toplistPlayers, 自定义字符串("{0}", 事件玩家))]) == 真 ? 无 : 所有玩家(所有队伍),
				英雄图标字符串(英雄(源氏)), 事件玩家, 自定义字符串("{0} 秒", 事件玩家.T), 右边, 事件玩家.T, 自定义颜色(158, 255, 187, 255), 自定义颜色(158, 255, 187, 255), 自定义颜色(158,
				255, 187, 255), 可见性，排序规则和字符串, 默认可见度);
			事件玩家.B[7] = 上一个文本ID;
		Else;
			根据条件跳过(事件玩家.D > 事件玩家.T, 1);
			事件玩家.T = 事件玩家.D;
		End;
		"Save data for the Top 5 list"
		If(数组包含(全局.toplistPlayers, 自定义字符串("{0}", 事件玩家)) == 真);
			根据条件跳过(事件玩家.D >= 全局.toplistTimes[数组值的索引(全局.toplistPlayers, 自定义字符串("{0}", 事件玩家))], 1);
			全局.toplistTimes[数组值的索引(全局.toplistPlayers, 自定义字符串("{0}", 事件玩家))] = 事件玩家.D;
		Else;
			修改全局变量(toplistPlayers, 添加至数组, 自定义字符串("{0}", 事件玩家));
			全局.toplistTimes[数组值的索引(全局.toplistPlayers, 自定义字符串("{0}", 事件玩家))] = 事件玩家.D;
		End;
		"Reload the Sorted Array Times"
		全局.toplistSortedTimes = 数组分割(已排序的数组(全局.toplistTimes, 当前数组元素), 0, 6);
		停止追踪玩家变量(事件玩家, ztjs);
		事件玩家.ztjs = 0;
	}
}

规则("通关波浪特效")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.A == 数量(全局.A) - 1;
		事件玩家.E < 1;
		正在移动(事件玩家) == 真;
		禁用 (正在移动(事件玩家) == 真 || 按钮被按下(事件玩家, 按钮(跳跃)) == 真) == 真;
	}

	动作
	{
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(黄色), 所选位置(事件玩家), 1.600);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(绿色), 所选位置(事件玩家), 1.400);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(亮紫色), 所选位置(事件玩家), 1.200);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(红色), 所选位置(事件玩家), 1);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(蓝色), 所选位置(事件玩家), 0.800);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(水绿色), 所选位置(事件玩家), 0.600);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(橙色), 所选位置(事件玩家), 0.400);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(天蓝色), 所选位置(事件玩家), 0.200);
		等待(0.350, 无视条件);
		如条件为”真“则循环;
	}
}

规则("死亡传送")
{
	事件
	{
		玩家阵亡;
		双方;
		全部;
	}

	条件
	{
		事件玩家.F != 1;
		数量(全局.A) >= 2;
	}

	动作
	{
		清除状态(事件玩家, 相移);
		复活(事件玩家);
		If(全局.kz_xs == 真);
			事件玩家.L = 0;
			停止追踪玩家变量(事件玩家, L);
			事件玩家.A = 事件玩家.E > 0 ? 事件玩家.A : 0;
		End;
		传送(事件玩家, 数量(全局.A[事件玩家.A]) != 0 ? 全局.A[事件玩家.A][1] : 全局.A[事件玩家.A]);
	}
}

规则("落地传送——————————— 制作球型跑酷图时，关闭此条规则，需要融合球型、点型二者的则不用 ————————————")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		(相距距离(事件玩家, 数量(全局.A[事件玩家.A]) != 0 ? 全局.A[事件玩家.A][1] : 全局.A[事件玩家.A]) > 1.400 || 假) == 真;
		(在地面上(事件玩家) == 真 || 假) == 真;
		事件玩家.A < 数量(全局.A) - 1;
		数量(全局.A) >= 2;
		事件玩家.C != 1;
		事件玩家.F != 1;
		"做特定关卡开启落地死亡再打开"
		禁用 (事件玩家.A == -1 || 事件玩家.A == -1 || 事件玩家.A == -1 || 假) == 真;
	}

	动作
	{
		If(事件玩家.E < 1);
			设置启用技能 1(事件玩家, 假);
			设置启用终极技能(事件玩家, 假);
		End;
		施加推力(事件玩家, 下, 速度(事件玩家), 至玩家, 取消相反运动);
		设置状态(事件玩家, 无, 定身, 0.100);
		If(全局.kz_xs == 真);
			事件玩家.L = 0;
			停止追踪玩家变量(事件玩家, L);
			事件玩家.A = 事件玩家.E > 0 ? 事件玩家.A : 0;
		End;
		传送(事件玩家, 数量(全局.A[事件玩家.A]) != 0 ? 全局.A[事件玩家.A][1] : 全局.A[事件玩家.A]);
		If(全局.deathjump == 真);
			禁用按钮(事件玩家, 按钮(跳跃));
			等待(0.100, 无视条件);
			可用按钮(事件玩家, 按钮(跳跃));
		End;
		If(事件玩家.A == 0);
			事件玩家.D = 0;
		End;
		If(正在使用终极技能(事件玩家) == 真);
			击杀(事件玩家, 无);
		End;
	}
}

规则("消散")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
		具有状态(事件玩家, 相移) == 假;
	}

	动作
	{
		设置状态(事件玩家, 无, 相移, 9999);
		设置状态(事件玩家, 无, 无敌, 9999);
	}
}

规则("重跑")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
	}

	动作
	{
		If(数组包含(全局.save, 自定义字符串("{0}", 事件玩家)) == 真);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 1);
			修改全局变量(save, 根据值从数组中移除, 自定义字符串("{0}", 事件玩家));
		End;
		在索引处修改全局变量(P, 事件玩家.A, 根据值从数组中移除, 事件玩家);
		If(事件玩家.A >= 数量(全局.A) - 1);
			调用子程序(Sub0);
			"这条动作为“消除玩家通关成绩显示”"
			消除HUD文本(事件玩家.B[7]);
			"效果B5.B6代表的是光环通关特效，需保持和规则“通关特效”同步开启/关闭"
			禁用 消除效果(事件玩家.B[5]);
			禁用 消除效果(事件玩家.B[6]);
		End;
		调用子程序(Sub1);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 100);
		修改全局变量(F, 根据值从数组中移除, 事件玩家);
		修改全局变量(G, 根据值从数组中移除, 事件玩家);
	}
}

规则("自杀观战")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		事件玩家.E < 1;
	}

	动作
	{
		等待(1, 当为“假”时中止);
		小字体信息(事件玩家, 自定义字符串("长按互动1秒开启/关闭观战"));
		If(存活(事件玩家) == 真);
			If(事件玩家.A < 数量(全局.A) - 1);
				追踪玩家变量频率(事件玩家, ztjs, 绝对值(999999), 1, 速率及最终值);
				全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 2] = 事件玩家.D;
				全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 4] = 总计消耗时间;
				全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 6] = 1;
			End;
			设置最大复生时间(事件玩家, 9999);
			事件玩家.F = 1;
			停止追踪玩家变量(事件玩家, D);
			等待(0.200, 无视条件);
			击杀(事件玩家, 无);
			传送(事件玩家, 数量(全局.A[事件玩家.A]) != 0 ? 全局.A[事件玩家.A][1] : 全局.A[事件玩家.A]);
		Else;
			根据条件跳过(事件玩家.E >= 1, 2);
			复生(事件玩家);
			事件玩家.F = 0;
			传送(事件玩家, 数量(全局.A[事件玩家.A]) != 0 ? 全局.A[事件玩家.A][1] : 全局.A[事件玩家.A]);
			根据条件跳过(事件玩家.A >= 数量(全局.A) - 1, 3);
			设置启用终极技能(事件玩家, 假);
			设置启用技能 1(事件玩家, 假);
			追踪玩家变量频率(事件玩家, D, 10000, 1, 速率及最终值);
			设置最大复生时间(事件玩家, 0);
			事件玩家.C = 0;
			If(事件玩家.A < 数量(全局.A) - 1);
				停止追踪玩家变量(事件玩家, ztjs);
				全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 5] = 事件玩家.ztjs;
				事件玩家.ztjs = 0;
				全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 6] = 0;
			End;
		End;
		根据条件跳过(全局.kz_xs == 假, 1);
		事件玩家.A = 0;
	}
}

规则("二段跳，小跳初始化")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		在地面上(事件玩家) == 真;
		"变量A后的数字“-1”为关卡数，具体操作参考“给刀”。此条规则开启效果为“特定关卡开启三段”，关闭则为“所有关卡封禁三段”"
		禁用 (事件玩家.A != -1 || 事件玩家.A != -1 || 假) == 真;
		"注释一定要看！此条条件开启的效果为“通关后自动开启三段”，关闭则通关后仍封禁三段"
		禁用 事件玩家.A < 数量(全局.A) - 1;
	}

	动作
	{
		事件玩家.TY = 0;
		事件玩家.J = 2;
		等待(0, 无视条件);
		根据条件循环((事件玩家.TY != 0 || 事件玩家.J != 2) && 在地面上(事件玩家) == 真);
		事件玩家.O = 1;
	}
}

规则("跳跃判定")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		事件玩家.TY != 2;
		"变量A后的数字“-1”为关卡数，具体操作参考“给刀”。此条规则开启效果为“特定关卡开启三段”，关闭则为“所有关卡封禁三段"
		禁用 (事件玩家.A != -1 || 事件玩家.A != -1 || 假) == 真;
		"注释一定要看！此条条件开启的效果为“通关后自动开启三段”，关闭则通关后仍封禁三"
		禁用 事件玩家.A < 数量(全局.A) - 1;
	}

	动作
	{
		事件玩家.TY += 1;
	}
}

规则("踏空小跳判定")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.TY == 0;
		正在空中(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
	}

	动作
	{
		事件玩家.O = 0;
	}
}

规则("踏空")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		事件玩家.TY == 0;
		正在空中(事件玩家) == 真;
		"变量A后的数字“-1”为关卡数，具体操作参考“给刀”。此条规则开启效果为“特定关卡开启三段”，关闭则为“所有关卡封禁三段"
		禁用 (事件玩家.A != -1 || 事件玩家.A != -1 || 假) == 真;
		"注释一定要看！此条条件开启的效果为“通关后自动开启三段”，关闭则通关后仍封禁三"
		禁用 事件玩家.A < 数量(全局.A) - 1;
	}

	动作
	{
		事件玩家.TY = 1;
	}
}

规则("三段精准判定")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.TY == 1;
	}

	动作
	{
		等待(0.100, 当为“假”时中止);
		事件玩家.TY = 2;
	}
}

规则("玩家在墙上")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"此条规则同时与爬墙判定挂钩，请勿关闭/删除"
		在墙上(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
	}

	动作
	{
		事件玩家.TY = 2;
		事件玩家.J = 1;
	}
}

规则("探点")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		正在使用技能 1(事件玩家) == 假;
		事件玩家.A < 数量(全局.A) - 1;
		存活(事件玩家) == 真;
		正在使用终极技能(事件玩家) == 假;
	}

	动作
	{
		开始强制设置玩家位置(事件玩家, 数量(全局.A[事件玩家.A]) != 0 ? 全局.A[事件玩家.A][1] : 全局.A[事件玩家.A], 真);
		If(事件玩家.C == 0);
			追踪玩家变量频率(事件玩家, ztjs, 绝对值(999999), 1, 速率及最终值);
			全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 2] = 事件玩家.D;
			全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 4] = 总计消耗时间;
			全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 6] = 1;
			根据条件跳过(全局.kz_xs == 假, 2);
			小字体信息(事件玩家, 自定义字符串("按下 ctrl + 鼠标 跳关"));
			停止追踪玩家变量(事件玩家, L);
			停止追踪玩家变量(事件玩家, D);
			大字体信息(事件玩家, 自定义字符串("已解除地面限制"));
			停止强制设置玩家位置(事件玩家);
			设置启用终极技能(事件玩家, 真);
			设置终极技能充能(事件玩家, 100);
			设置启用技能 1(事件玩家, 真);
			等待(0.200, 无视条件);
			事件玩家.C = 1;
		Else;
			根据条件跳过(事件玩家.E >= 1, 2);
			设置启用终极技能(事件玩家, 假);
			设置启用技能 1(事件玩家, 假);
			根据条件跳过(全局.kz_xs == 假, 1);
			事件玩家.A = 0;
			传送(事件玩家, 数量(全局.A[事件玩家.A]) != 0 ? 全局.A[事件玩家.A][1] : 全局.A[事件玩家.A]);
			等待(0.100, 无视条件);
			事件玩家.C = 0;
			大字体信息(事件玩家, 自定义字符串("已开启地面限制"));
			追踪玩家变量频率(事件玩家, D, 绝对值(9999999.000), 1, 速率及最终值);
			停止强制设置玩家位置(事件玩家);
			停止追踪玩家变量(事件玩家, ztjs);
			全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 5] = 事件玩家.ztjs;
			事件玩家.ztjs = 0;
			全局.save[数组值的索引(全局.save, 自定义字符串("{0}", 事件玩家)) + 6] = 0;
		End;
	}
}

规则("刀充能")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		终极技能充能百分比(事件玩家) < 100;
	}

	动作
	{
		设置终极技能充能(事件玩家, 100);
	}
}

规则("表情小跳判定")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在使用表情交流(事件玩家) == 真;
	}

	动作
	{
		事件玩家.O = 0;
	}
}

规则("小跳使用判定")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.O == 0;
		正在跳跃(事件玩家) == 真;
	}

	动作
	{
		事件玩家.O = 1;
		小字体信息(事件玩家, 自定义字符串("小跳已用"));
	}
}

规则("玩家离开比赛")
{
	事件
	{
		玩家离开比赛;
		双方;
		全部;
	}

	动作
	{
		修改全局变量(Q, 根据值从数组中移除, 事件玩家);
		If(全局.save[数组值的索引(全局.save, 事件玩家) - 2] == 0);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 事件玩家) + 1);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 事件玩家) + 1);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 事件玩家) + 1);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 事件玩家) - 1);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 事件玩家) - 1);
			修改全局变量(save, 根据索引从数组中移除, 数组值的索引(全局.save, 事件玩家) - 1);
			修改全局变量(save, 根据值从数组中移除, 事件玩家);
		Else;
			根据条件跳过(全局.save[数组值的索引(全局.save, 事件玩家) - 2] >= 数量(全局.A) - 1, 2);
			根据条件跳过(全局.save[数组值的索引(全局.save, 事件玩家) + 3] == 1, 1);
			全局.save[数组值的索引(全局.save, 事件玩家) - 1] = 总计消耗时间 - 全局.save[数组值的索引(全局.save, 事件玩家) + 1] - 全局.save[数组值的索引(全局.save, 事件玩家)
				+ 2] + 全局.save[数组值的索引(全局.save, 事件玩家) - 1];
			全局.save[数组值的索引(全局.save, 事件玩家) + 2] = 0;
			全局.save[数组值的索引(全局.save, 事件玩家) + 3] = 0;
		End;
	}
}

规则("卡小跳判定 感谢Githuboy#5249")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		在墙上(事件玩家) == 假;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		在地面上(事件玩家) == 假;
		正在空中(事件玩家) == 真;
		正在跳跃(事件玩家) == 假;
		正在蹲下(事件玩家) == 真;
	}

	动作
	{
		小字体信息(事件玩家, 自定义字符串("Success"));
		事件玩家.O = 0;
		If(全局.kaxiaotiao == 真);
			击杀(事件玩家, 无);
			小字体信息(事件玩家, 字符串("{0} {1}", 英雄图标字符串(英雄(源氏)), 自定义字符串("：卡小跳已禁用")));
		End;
	}
}

规则("快速回城")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		事件玩家.E < 1;
	}

	动作
	{
		根据条件中止(按钮被按下(事件玩家, 按钮(近身攻击)) == 真);
		If(事件玩家.quick_restart == 真);
			开始强制设置玩家位置(事件玩家, 数量(全局.A[事件玩家.A]) != 0 ? 全局.A[事件玩家.A][1] : 全局.A[事件玩家.A], 真);
			根据条件跳过(事件玩家.E >= 1 || 事件玩家.C == 1, 2);
			设置启用终极技能(事件玩家, 假);
			设置启用技能 1(事件玩家, 假);
			传送(事件玩家, 数量(全局.A[事件玩家.A]) != 0 ? 全局.A[事件玩家.A][1] : 全局.A[事件玩家.A]);
			等待(0.100, 无视条件);
			停止强制设置玩家位置(事件玩家);
		End;
		等待(1, 当为“假”时中止);
		If(事件玩家.quick_restart == 假);
			事件玩家.quick_restart = 真;
			大字体信息(事件玩家, 自定义字符串("快速回城已开启"));
			播放效果(事件玩家, 正面状态施加声音, 颜色(白色), 事件玩家, 100);
		Else If(事件玩家.quick_restart == 真);
			播放效果(事件玩家, 正面状态施加声音, 颜色(白色), 事件玩家, 100);
			事件玩家.quick_restart = 假;
			大字体信息(事件玩家, 自定义字符串("快速回城已关闭"));
		End;
	}
}

规则("限制刀———— 无须更改 ———————————————")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		"此条规则作用为：在跑图时令SHIFT只能使用一次"
		正在使用终极技能(事件玩家) == 真;
		事件玩家.A < 数量(全局.A) - 1;
		事件玩家.E < 1;
		事件玩家.C == 0;
	}

	动作
	{
		设置启用终极技能(事件玩家, 假);
	}
}

规则("限制shift———无须更改 ————————————————")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"此条规则作用为：在跑图时令SHIFT只能使用一次"
		正在使用技能 1(事件玩家) == 真;
		事件玩家.A < 数量(全局.A) - 1;
		事件玩家.E < 1;
		事件玩家.C == 0;
	}

	动作
	{
		设置启用技能 1(事件玩家, 假);
	}
}

规则("给刀—————无须更改 —————————")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		在地面上(事件玩家) == 真;
		事件玩家.A < 数量(全局.A) - 1;
		相距距离(事件玩家, 数量(全局.A[事件玩家.A]) > 1 ? 最后(全局.A[事件玩家.A]) : 全局.A[事件玩家.A]) <= 1.400;
		数组包含(全局.Dao, 事件玩家.A) == 真;
		正在使用终极技能(事件玩家) == 假;
	}

	动作
	{
		等待(0.100, 无视条件);
		根据条件中止(正在使用终极技能(事件玩家) == 真);
		设置启用终极技能(事件玩家, 真);
		设置终极技能充能(事件玩家, 100);
		小字体信息(事件玩家, 自定义字符串("终极技能已开启"));
	}
}

规则("给shift————无须更改 —————————")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		在地面上(事件玩家) == 真;
		事件玩家.A < 数量(全局.A) - 1;
		禁用 相距距离(事件玩家, 全局.A[事件玩家.A]) <= 1.400;
		相距距离(事件玩家, 数量(全局.A[事件玩家.A]) > 1 ? 最后(全局.A[事件玩家.A]) : 全局.A[事件玩家.A]) <= 1.400;
		数组包含(全局.SHIFT, 事件玩家.A) == 真;
		正在使用技能 1(事件玩家) == 假;
	}

	动作
	{
		设置启用技能 1(事件玩家, 真);
		小字体信息(事件玩家, 自定义字符串("SHIFT技能已开启"));
	}
}

规则("———————————————— 以下灰色的功能，需要用时再另行设置 ————————————————")
{
	事件
	{
		持续 - 全局;
	}
}

规则("刀关卡设置——————————— 将“-1”修改为给刀关卡数即可 ——————————")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"需要添加关卡将“-1”修改为关卡数即可"
		全局.Dao = 数组(空数组, 42, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
	}
}

规则("SHIFT关卡设置————————— 将“-1”修改为给shift关卡数即可 ——————————")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"需要添加关卡将“-1”修改为关卡数即可"
		全局.SHIFT = 数组(空数组, 32, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
	}
}

禁用 规则("传送门1-2")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"将矢量（0，0，0）修改为开始的传送位置"
		相距距离(事件玩家, 矢量(0, 0, 0)) <= 1.400;
		"将“-1”修改为传送门关卡的关卡数"
		(事件玩家.A == -1 || 事件玩家.A >= 数量(全局.A) - 1) == 真;
	}

	动作
	{
		"将矢量（0，0，0）修改为传送结束的位置"
		禁用 传送(事件玩家, 矢量(0, 0, 0));
		"不想找坐标的，直接传送到关卡0"
		禁用 传送(事件玩家, 全局.A[0]);
	}
}

禁用 规则("传送门2-3")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"将矢量（0，0，0）修改为开始的传送位置"
		相距距离(事件玩家, 矢量(0, 0, 0)) <= 1.400;
		"将“-1”修改为传送门关卡的关卡数"
		(事件玩家.A == -1 || 事件玩家.A >= 数量(全局.A) - 1) == 真;
	}

	动作
	{
		"将矢量（0，0，0）修改为传送结束的位置"
		禁用 传送(事件玩家, 矢量(0, 0, 0));
		"不想找坐标的，直接传送到关卡0"
		禁用 传送(事件玩家, 全局.A[0]);
	}
}

禁用 规则("传送门3-1")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"将矢量（0，0，0）修改为开始的传送位置"
		相距距离(事件玩家, 矢量(0, 0, 0)) <= 1.400;
		"将“-1”修改为传送门关卡的关卡数"
		(事件玩家.A == -1 || 事件玩家.A >= 数量(全局.A) - 1) == 真;
	}

	动作
	{
		"将矢量（0，0，0）修改为传送结束的位置"
		禁用 传送(事件玩家, 矢量(0, 0, 0));
		"不想找坐标的，直接传送到关卡0"
		禁用 传送(事件玩家, 全局.A[0]);
	}
}

禁用 规则("特定关卡可见的地图文本")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		禁用 创建地图文本(已排序的数组(全局.P[0], 当前数组元素), 自定义字符串("我是0关的文本"), 矢量(0, 0, 0), 1.200, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		禁用 创建地图文本(已排序的数组(全局.P[1], 当前数组元素), 自定义字符串("我是01关的文本"), 矢量(0, 0, 0), 1.200, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		禁用 创建地图文本(已排序的数组(全局.P[2], 当前数组元素), 自定义字符串("我是02关的文本"), 矢量(0, 0, 0), 3, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
	}
}

禁用 规则("指定关卡可见HUD文本")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		禁用 创建HUD文本(已排序的数组(全局.P[0], 当前数组元素), 自定义字符串("我是第0关文本"), 无, 无, 顶部, -4, 颜色(红色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		禁用 创建HUD文本(已排序的数组(全局.P[1], 当前数组元素), 自定义字符串("我是第1关文本"), 无, 无, 顶部, -4, 颜色(红色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		禁用 创建HUD文本(已排序的数组(全局.P[2], 当前数组元素), 自定义字符串("我是第2关文本"), 无, 无, 顶部, -4, 颜色(红色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
	}
}

禁用 规则("地图文本")
{
	事件
	{
		持续 - 全局;
	}
}

禁用 规则("DVA点位——————DVA炸栏杆请手动添加坐标点位")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.DVA = 空数组;
		全局.dva = 0;
		"点击这个摄像头就能录入玩家当前的位置"
		禁用 修改全局变量(DVA, 添加至数组, 矢量(-78.678, 15.092, -97.781));
		禁用 修改全局变量(DVA, 添加至数组, 矢量(-68.359, 16.199, -89.387));
		禁用 修改全局变量(DVA, 添加至数组, 矢量(-79.100, 16.199, -88.100));
	}
}

禁用 规则("召唤DVA")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.dva == 0;
		数量(所有玩家(队伍2)) < 6;
	}

	动作
	{
		生成机器人(英雄(D.Va), 队伍2, 5, 全局.DVA[全局.dva], 上);
		全局.dva += 1;
		开始按下按钮(选择英雄的玩家(英雄(D.Va), 所有队伍), 按钮(终极技能));
		等待(6.500, 无视条件);
		根据条件循环(全局.dva < 数量(全局.DVA));
		停止按下按钮(选择英雄的玩家(英雄(D.Va), 所有队伍), 按钮(终极技能));
		移除机器人(队伍2, 5);
	}
}

禁用 规则("传送门显示——可变字体")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		"将矢量（0，0，0）修改为传送门1-2入口的坐标"
		创建地图文本(事件玩家, 自定义字符串("{{0}}", 事件玩家.H, 自定义字符串("传送至下一目标"), 自定义字符串("至图二")), 矢量(276.288, -17.222, -74.522), 1.500, 根据表面截取, 可见，位置和字符串,
			颜色(黄色), 默认可见度);
		"将矢量（1，1，1）修改为2-3传送门的入口位置"
		创建地图文本(事件玩家, 自定义字符串("{{0}}", 事件玩家.H, 自定义字符串("传送至下一目标"), 自定义字符串("至图三")), 矢量(1, 1, 1), 1.500, 根据表面截取, 可见，位置和字符串, 颜色(黄色), 默认可见度);
	}
}

禁用 规则("传送门显示——光环及光柱及不可变“至图一”字体")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"传送门1-2的显示效果"
		创建效果(全局.F, 环, 颜色(灰绿色), 矢量(0, 0, 0), 1, 可见，位置和半径);
		"传送门1-2的显示效果"
		创建效果(全局.F, 光柱, 颜色(红色), 矢量(276.288, -17.222, -74.522), 1, 可见，位置和半径);
		"传送门2-3的显示效果"
		创建效果(全局.G, 环, 颜色(灰绿色), 矢量(1, 1, 1), 1, 可见，位置和半径);
		"传送门2-3的显示效果"
		创建效果(全局.G, 光柱, 颜色(红色), 矢量(1, 1, 1), 1, 可见，位置和半径);
		"传送门3-1的显示效果"
		创建效果(全局.F, 环, 颜色(灰绿色), 矢量(2, 2, 2), 1, 可见，位置和半径);
		"传送门3-1的显示效果"
		创建效果(全局.F, 光柱, 颜色(红色), 矢量(2, 2, 2), 1, 可见，位置和半径);
		"将矢量（0，0，0）修改为传送门3-1的入口坐标"
		创建地图文本(全局.F, 自定义字符串("至图一"), 矢量(0, 0, 0), 1.500, 根据表面截取, 可见，位置和字符串, 颜色(黄色), 默认可见度);
	}
}

禁用 规则("开启传送门视野—————————— 特定关卡时开启 ————————————")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"将“-1”分别改为两个传送门所在关卡的关卡数"
		(事件玩家.A == -1 || 事件玩家.A == -1 || 事件玩家.A >= 数量(全局.A) - 1) == 真;
	}

	动作
	{
		事件玩家.H = 1;
		"将“-1”修改为第一个传送门所在的关卡数"
		If(事件玩家.A == -1);
			修改全局变量(F, 添加至数组, 事件玩家);
		"将“-2”修改为第二个传送门所在的关卡数"
		Else If(事件玩家.A == -2);
			修改全局变量(G, 添加至数组, 事件玩家);
		"无需更改"
		Else If(事件玩家.A >= 数量(全局.A) - 1);
			修改全局变量(G, 添加至数组, 事件玩家);
			修改全局变量(F, 添加至数组, 事件玩家);
			事件玩家.H = 2;
		End;
	}
}

禁用 规则("关闭传送门视野—————————— 特定关卡时关闭 ————————————")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"将“-2”分别修改为两个传送门传送过去后的关卡数"
		(事件玩家.A == -2 || 事件玩家.A == -2 || 假) == 真;
	}

	动作
	{
		事件玩家.H = 0;
		"将此处的“-2”修改为第一个传送门传送过去之后的关卡数"
		If(事件玩家.A == -2);
			修改全局变量(F, 根据值从数组中移除, 事件玩家);
		"将此处的“-2”修改为第二个传送门传送过去之后的关卡数"
		Else If(事件玩家.A == -2);
			修改全局变量(G, 根据值从数组中移除, 事件玩家);
		End;
	}
}

规则("作者名字在这输入")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("就叫古董吧"), 顶部, -3, 颜色(水绿色), 颜色(水绿色), 颜色(水绿色), 可见和字符串, 默认可见度);
	}
}

规则("好友称号")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		"空白处填写您好友的名字"
		If(自定义字符串("【在这里填好友的名字】") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("【在这里填进场文字】"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("【在这里填称号】"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		End;
		"空白处填写您好友的名字"
		If(自定义字符串("【在这里填好友的名字】") == 自定义字符串("{0}", 事件玩家));
			大字体信息(所有玩家(所有队伍), 自定义字符串("【在这里填进场文字】"));
			创建地图文本(所有玩家(所有队伍), 自定义字符串("【在这里填称号】"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		End;
	}
}

规则("------------------------------------开启/关闭扩展功能请前往地图工坊设置，以下规则请勿关闭------------------------------------------")
{
	事件
	{
		持续 - 全局;
	}
}

规则("三段封禁")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		垂直速度(事件玩家) >= 5.800;
		事件玩家.TY == 1;
		正在使用技能 1(事件玩家) == 假;
		地图工坊设置开关(自定义字符串("封禁开关"), 自定义字符串("封禁三段"), 假, 0) == 真;
	}

	动作
	{
		根据条件中止(在墙上(事件玩家) == 真);
		施加推力(事件玩家, 下, 速度(事件玩家), 至玩家, 取消相反运动);
	}
}

规则("封蹭墙")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		在墙上(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		事件玩家.J == 2;
		地图工坊设置开关(自定义字符串("封禁开关"), 自定义字符串("封禁蹭墙"), 假, 1) == 真;
	}

	动作
	{
		施加推力(事件玩家, 下, 速度(事件玩家), 至玩家, 取消相反运动);
		小字体信息(事件玩家, 字符串("{0} {1}", 英雄图标字符串(英雄(源氏)), 自定义字符串("：蹭墙已禁用")));
	}
}

规则("封卡小跳")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		地图工坊设置开关(自定义字符串("封禁开关"), 自定义字符串("封禁卡小"), 假, 2) == 真;
	}

	动作
	{
		全局.kaxiaotiao = 真;
	}
}

规则("封表情小跳")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在使用表情交流(事件玩家) == 真;
		事件玩家.A < 数量(全局.A) - 1;
		地图工坊设置开关(自定义字符串("封禁开关"), 自定义字符串("封禁表情跳"), 假, 3) == 真;
	}

	动作
	{
		击杀(事件玩家, 无);
		小字体信息(事件玩家, 字符串("{0} {1}", 英雄图标字符串(英雄(源氏)), 自定义字符串("：表情已禁用")));
	}
}

规则("封死亡小跳")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		地图工坊设置开关(自定义字符串("封禁开关"), 自定义字符串("封禁死亡小跳"), 假, 4) == 真;
	}

	动作
	{
		全局.deathjump = 真;
	}
}

规则("扩展: 系統跳強化（原作：家里有妖怪#5202）  效果：增强系統跳的判定（更容易卡出系統跳了）以及力度（跳得更远）")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		(垂直速度(事件玩家) >= -0.200 && 垂直速度(事件玩家) <= 0.050) == 真;
		水平速度(事件玩家) <= 1.300;
		正在空中(事件玩家) == 真;
		在墙上(事件玩家) == 假;
		在地面上(事件玩家) == 假;
		地图工坊设置开关(自定义字符串("扩展功能"), 自定义字符串("系统跳强化  by：家里有妖怪#5202"), 假, 0) == 真;
	}

	动作
	{
		等待(0.250, 当为“假”时中止);
		开始强制设置玩家位置(事件玩家, 所选位置(事件玩家), 假);
		等待直到 (正在移动(事件玩家) == 假, 10);
		停止强制设置玩家位置(事件玩家);
		设置移动速度(事件玩家, 0);
		设置引力(事件玩家, 0);
		等待(3, 无视条件);
		设置引力(事件玩家, 100);
		设置移动速度(事件玩家, 100);
		施加推力(事件玩家, 上, 10, 至地图, 取消相反运动);
		如条件为”真“则循环;
	}
}

规则("扩展：爬墙刷新二段（喵喵酱#51379）效果：玩家在爬墙后刷新二段跳（扒墙蹭墙都不会刷新）")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		在墙上(事件玩家) == 真;
		地图工坊设置开关(自定义字符串("扩展功能"), 自定义字符串("爬墙刷新二段  by：喵喵酱#51379"), 假, 1) == 真;
	}

	动作
	{
		等待(0.250, 当为“假”时中止);
		等待直到 (在墙上(事件玩家) == 假, 1);
		设置状态(事件玩家, 无, 被入侵, 0.100);
		等待(0.100, 无视条件);
		清除状态(事件玩家, 被入侵);
	}
}

规则("扩展：留爬进点(TITANXPASCAL#5554)*记得创建文本提示玩家")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		相距距离(事件玩家, 全局.A[事件玩家.A + 1]) <= 2;
		地图工坊设置开关(自定义字符串("扩展功能"), 自定义字符串("留爬进点 by：TITANXPASCAL#5554"), 假, 2) == 真;
		"将\"-1\"修改为需要留爬进点的关卡数"
		数组包含(数组(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), 事件玩家.A) == 真;
		"如要所有关卡留爬，开启此规则，关闭\"数组包含\"的规则"
		禁用 事件玩家.A < 数量(全局.A) - 1;
	}

	动作
	{
		If(事件玩家.J == 1);
			击杀(事件玩家, 无);
			小字体信息(事件玩家, 自定义字符串("未达成通关条件：留爬"));
		End;
	}
}

规则("扩展：留小跳进点(TITANXPASCAL#5554)*记得创建文本提示玩家")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		相距距离(事件玩家, 全局.A[事件玩家.A + 1]) <= 2;
		地图工坊设置开关(自定义字符串("扩展功能"), 自定义字符串("留小跳进点 by：TITANXPASCAL#5554"), 假, 3) == 真;
		"将\"-1\"修改为需要留小跳进点的关卡数"
		数组包含(数组(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), 事件玩家.A) == 真;
		"如要所有关卡留小跳，开启此规则，关闭\"数组包含\"的规则"
		禁用 事件玩家.A < 数量(全局.A) - 1;
	}

	动作
	{
		If(事件玩家.O == 1);
			击杀(事件玩家, 无);
			小字体信息(事件玩家, 自定义字符串("未达成通关条件：留小跳"));
		End;
	}
}

规则("规则 91")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		相距距离(事件玩家, 全局.A[事件玩家.E > 0 ? 事件玩家.A : 0]) > 1.400;
		全局.kz_xs == 真;
		(事件玩家.E > 0 ? 0 : 事件玩家.C) != 1;
		(事件玩家.E > 0 ? 0 : 事件玩家.A) == 0;
		禁用 事件玩家.A == 0;
		禁用 事件玩家.C != 1;
	}

	动作
	{
		事件玩家.L = 0;
		追踪玩家变量频率(事件玩家, L, 10, 1, 速率及最终值);
		事件玩家.D = 0;
	}
}

规则("规则 92")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.kz_xs == 真;
		事件玩家.L >= 5;
		事件玩家.A < 数量(全局.A) - 1;
	}

	动作
	{
		事件玩家.A = 事件玩家.E > 0 ? 事件玩家.A : 0;
		根据条件跳过(事件玩家.C == 1, 2);
		根据条件跳过(事件玩家.E > 0 && 在地面上(事件玩家), 2);
		传送(事件玩家, 全局.A[事件玩家.E < 1 ? 0 : 事件玩家.A]);
		小字体信息(事件玩家, 自定义字符串("已超时！"));
		停止追踪玩家变量(事件玩家, L);
	}
}

规则("规则 93")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		相距距离(事件玩家, 全局.A[0]) < 1;
		事件玩家.A == 0;
		全局.kz_xs == 真;
	}

	动作
	{
		停止追踪玩家变量(事件玩家, L);
		事件玩家.L = 0;
		事件玩家.D = 0;
	}
}

规则("规则 94")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.C == 1;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		全局.kz_xs == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
	}

	动作
	{
		事件玩家.A += 事件玩家.A < 数量(全局.A) - 2 ? 1 : 0;
		传送(事件玩家, 全局.A[事件玩家.A]);
	}
}

规则("规则 94")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.C == 1;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		全局.kz_xs == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		事件玩家.A -= 事件玩家.A > 0 ? 1 : 0;
		传送(事件玩家, 全局.A[事件玩家.A]);
	}
}