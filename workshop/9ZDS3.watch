设置
{
	主程序
	{
		描述: "仓鼠跑酷开拓者, by喜欢跑酷的小伙伴们. (代码:9ZDS3,会不定期更新,保存代码,不要保存预设),ver 2.43加入超级跳模式 ! ver2.50加入传送点 ver3.0加入拿小球模式  直接更换地图即可游玩不同点位 更多跑酷点位和教学前往熔火工坊查看  其他合集代码:G7V27 | 13GT0R  通关教学:b站up:Stan_sin"
		模式名称: "仓鼠跑酷"
	}

	大厅
	{
		比赛语音聊天: 启用
		玩家上限 队伍1: 9
		玩家上限 队伍2: 0
		观战者人数上限: 6
		返回大厅: 从不
		队列中的玩家可以加入: 是
	}

	模式
	{
		团队死斗
		{
			启用地图
			{
				马莱温多
			}
		}

		突击模式
		{
			启用地图
			{
				66号公路
				伊利奥斯
				圣诞节国王大道
				好莱坞
				沃斯卡娅工业区
				监测站：直布罗陀
				花村
				多拉多
			}
		}

		综合
		{
			允许切换英雄: 关闭
			复生时间: 5%
			急救包刷新: 禁用
			消灭提示: 关闭
			消灭镜头: 关闭
			游戏模式开始: 即时
			英雄限制: 关闭
			随机英雄复生: 开启
		}
	}

	英雄
	{
		队伍1
		{
			破坏球
			{
				终极技能（地雷禁区）: 关闭
				重力坠击 冷却时间: 0%
			}
		}

		队伍2
		{
			破坏球
			{
				动力铁球始终激活: 开启
				终极技能（地雷禁区）: 关闭
				重力坠击 冷却时间: 0%
			}
		}

		综合
		{
			无需装弹: 开启
			终极技能充能速度: 10%
			终极技能自动充能速度: 0%
			重生时终极技能充能完毕: 开启

			启用英雄
			{
				破坏球
			}

			秩序之光
			{
				传送面板: 关闭
			}
		}
	}

	地图工坊
	{
		X-position: -1.400
		Y-position: -0.300
		小球不透明度: 109
		小球判定大小: 2.200
		小球显示大小: 2.500
		小球红: 255
		小球绿: 105
		小球蓝: 180
		是否允许开拓: 开启
		是否开启机器人: 开启
		目标点圈不透明度: 161
		目标点圈大小: 1.800
		起飞点圈不透明度: 94
		跳关提醒: 关闭
	}

	扩展
	{
		增益状态效果
		爆炸声音
		播放更多效果
		生成更多机器人
	}
}

变量
{
	全局:
		0: CheckpointPosition
		1: Ability1State
		2: Ability2State
		3: SecondaryFireState
		4: UltimateState
		5: Creator
		6: RingRadius
		7: JudgeWhenLanding
		8: DefaultAliblty1Enabled
		9: DefaultAliblty2Enabled
		10: DefaultSecondaryEnabled
		11: DefaultUltimateEnabled
        12: Description
		13: OneTimeAbility
		14: DisableContinuousCreation
		15: PioneerModeEnabled
		16: Pioneer
		17: PioneerStarted
		18: PioneerLandingPosition
		19: PioneerSpherePosition
		20: BestScore
        21: MapHint
		22: SmallHint
        23: ShortKeyHint
		24: HiddenHint
        25: cheat_log
		26: RGB
		27: JumpState
		28: CheatRecord
		29: PlayersData
		30: RoomAliveHoursLeft
		31: SpherePosition
		32: SphereRadius
		33: SphereJudgeRadius
		34: Tips
        35: CurrentMap
		36: action_type
		37: actions
		38: bot_start_position
		39: bot_start_direction
        40: bot_position
        41: bot_owner
		42: Bot
		43: bot_direction
		44: action_value
		45: ActionEditModeEnabled
		46: bot_name
		47: bot_num
		48: bot_idx
		49: bot_action
		50: bot_max_action_time
		51: Chase
		52: bot_tips
		53: Idx
		54: BotEnabled
		55: Vips
		98: xPos
		99: yPos
		100: textX
		101: textY
		102: scale
		104: button
		105: text
		106: textSize

	玩家:
		0: Level
		1: BestScore
		2: LastScore
		3: ScoreOfThisRound
		4: GameComplete
		5: IsReady
		6: Invisible
		7: FreeMode
		8: InteractPressState
		9: FacingDirection
		10: UltimateCharge
		11: Ability1Used
		12: Ability2Used
		13: SecondaryFireUsed
		14: UltimateUsed
		15: IsSpectating
		16: ultimate_worked
		17: ultimate_log
		18: ultimate_info
		19: ultimate_outline_countdown
		20: pioneer_outline_countdown
		21: cheat
		22: mistake
		23: dataIndex
		25: sphere_state
		26: pioneer_mode
		27: HintFreq
		28: Entity
		29: actions
		30: action_idx
		31: action_type
		32: current_action_type
		33: current_action
        34: Bot
		35: bot_position
		37: bot_state
		38: bot_start_direction
		39: bot_direction
		41: bot_trans_direction
		43: action_s_idx
		44: edit_mode
		45: SpectatingState
		46: chooseHero
		47: movementCollision
		48: HUDEntity
		49: MapEntity
		50: EffectEntity
		51: IconEntity
		52: JumpingCheckpoint
		53: JumpingCheckpointHUD
		54: ShowHotKey
		55: playerTittle
		56: playerNickname
		57: playerColor
		80: action_time
		81: owner
		82: bot_action
		83: i
		84: bot_tips
		100: keyboard_enabled
		101: keyboard_status_space
		102: keyboard_status_ctrl
		103: keyboard_status_right
		104: keyboard_status_left
}

子程序
{
	0: SetAbility
	1: Reset
	2: ResetBot
	3: ReleaseBot
	4: ResetBall
	5: EditPlayerData
	6: ValidationPlayerData
    7: CreateHUDText
    8: CreatePlayerHUDText
    9: CreatePlayerEffect
    10: CreateTips
	11: ReleaseBot2
	12: PlayDestroyMapEffect
	13: CreateBot
}

规则("禁用查看器")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		禁用查看器录制;
	}
}

规则("房主发感谢即可更新导出数据,随后在查看器导出全局数据")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在交流(主机玩家, 感谢) == 真;
	}

	动作
	{
		全局.CurrentMap = 当前地图;
		启用查看器录制;
		禁用查看器录制;
		小字体信息(主机玩家, 自定义字符串("点位数据已导出,请打开查看器复制"));
		小字体信息(主机玩家, 自定义字符串("别忘了选择当前地图和当前比赛模式哦！"));
	}
}

规则("头衔(勿删除, 自行添加)")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"此条规则为自定义头衔"
		禁用 继续;
		全局.Vips = 数组(数组(自定义字符串("明天又是新的一天"), 自定义字符串("{0} Tomorrow is another day", 技能图标字符串(英雄(天使), 按钮(技能1))), 颜色(白色)), 数组(自定义字符串("朝如青丝暮成雪"),
			自定义字符串("朝朝暮暮"), 颜色(白色)), 数组(自定义字符串("长相思兮长相忆"), 自定义字符串("朝朝暮暮"), 颜色(白色)));
		"[0] 填写玩家昵称; \n[1] 填写显示文字, 如不填写, 默认为玩家昵称; \n[2] 填写文字颜色, 白色为随机颜色 "
		全局.Vips[数量(全局.Vips)] = 数组(自定义字符串(""), 自定义字符串(""), 颜色(白色));
		全局.Vips[数量(全局.Vips)] = 数组(自定义字符串(""), 自定义字符串(""), 颜色(白色));
		全局.Vips[数量(全局.Vips)] = 数组(自定义字符串(""), 自定义字符串(""), 颜色(白色));
	}
}

//工坊设置
规则("[自定义]地图工坊设置")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.PioneerModeEnabled = 地图工坊设置开关(自定义字符串("模式设置开关"), 自定义字符串("是否允许开拓"), 假, 0);
		全局.DisableContinuousCreation = 地图工坊设置开关(自定义字符串("模式设置开关"), 自定义字符串("连续开拓"), 假, 1);
		全局.JudgeWhenLanding = 地图工坊设置开关(自定义字符串("模式设置开关"), 自定义字符串("落地进点"), 真, 2);
		全局.OneTimeAbility = 地图工坊设置开关(自定义字符串("模式设置开关"), 自定义字符串("一次性技能"), 真, 3);
		全局.CheatRecord = 地图工坊设置开关(自定义字符串("模式设置开关"), 自定义字符串("跳关提醒"), 真, 4);
		"机器人设置"
		全局.BotEnabled = 地图工坊设置开关(自定义字符串("机器人设置"), 自定义字符串("是否开启机器人"), 假, 0);
		全局.ActionEditModeEnabled = 地图工坊设置开关(自定义字符串("机器人设置"), 自定义字符串("是否编辑机器人动作"), 假, 1);
		全局.bot_max_action_time = 地图工坊设置整数(自定义字符串("机器人设置"), 自定义字符串("最大教学时间"), 60, 30, 120, 2);
		全局.bot_num = 地图工坊设置整数(自定义字符串("机器人设置"), 自定义字符串("机器人数量"), 2, 1, 4, 3);
		"目标点颜色"
		全局.RGB[0] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("目标点圈红"), 255, 0, 255, 0);
		全局.RGB[1] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("目标点圈绿"), 255, 0, 255, 1);
		全局.RGB[2] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("目标点圈蓝"), 0, 0, 255, 2);
		全局.RGB[3] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("目标点圈不透明度"), 255, 0, 255, 3);
		"超级跳起飞点颜色"
		全局.RGB[4] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("起飞点圈红"), 208, 0, 255, 4);
		全局.RGB[5] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("起飞点圈绿"), 68, 0, 255, 5);
		全局.RGB[6] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("起飞点圈蓝"), 180, 0, 255, 6);
		全局.RGB[7] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("起飞点圈不透明度"), 255, 0, 255, 7);
		"小球颜色"
		全局.RGB[8] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("小球红"), 154, 0, 255, 8);
		全局.RGB[9] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("小球绿"), 110, 0, 255, 9);
		全局.RGB[10] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("小球蓝"), 147, 0, 255, 10);
		全局.RGB[11] = 地图工坊设置整数(自定义字符串("颜色"), 自定义字符串("小球不透明度"), 255, 0, 255, 11);
		"判定圈大小"
		全局.RingRadius[0] = 地图工坊设置实数(自定义字符串("参数"), 自定义字符串("目标点圈大小"), 1.500, 0.500, 4, 0);
		全局.RingRadius[1] = 地图工坊设置实数(自定义字符串("参数"), 自定义字符串(" 起始点圈大小"), 2, 0.200, 5, 1);
		全局.RingRadius[2] = 地图工坊设置实数(自定义字符串("参数"), 自定义字符串("起飞点圈大小"), 2, 0.200, 4, 2);
		全局.SphereRadius = 地图工坊设置实数(自定义字符串("参数"), 自定义字符串("小球显示大小"), 2, 0.200, 5, 3);
		全局.SphereJudgeRadius = 地图工坊设置实数(自定义字符串("参数"), 自定义字符串("小球判定大小"), 1.800, 0.200, 5, 4);
	}
}

规则("[自定义]哪些技能可以使用(如果要开启大招,请关掉 英雄-设置-大招自动充能 )")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"技能1(S)"
		全局.DefaultAliblty1Enabled = 真;
		"技能2(E)"
		全局.DefaultAliblty2Enabled = 真;
		"辅助攻击模式(右键)"
		全局.DefaultSecondaryEnabled = 真;
		"终极技能"
		全局.DefaultUltimateEnabled = 真;
		全局.bot_position = 矢量(0, 0, 0);
		全局.bot_direction = 矢量(0, 0, 0);
	}
}

//点位数据
规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 花村124 m酱 柠檬")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(花村);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("通关教学: b站up:Stancossin\r\nBV1ii4y1M7dq(部分关卡有改动)"), 左边, 1, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		全局.CheckpointPosition = 数组(矢量(-7.970, 5, -36.646), 矢量(-17.827, -1.249, -34.834), 矢量(-23.522, -1, -46.785), 矢量(-16.423, 3.010,
			-44.076), 矢量(-10.224, 7, -27.020), 矢量(-5.472, 5, -35.787), 矢量(12.879, 7.071, -49.094), 矢量(-0.059, 4, -58.664), 矢量(15.211, 4,
			-73.960), 矢量(6.704, 7.010, -83.536), 矢量(-8.287, 2.540, -76.757), 矢量(13.113, 7.071, -48.991), 矢量(0.974, 5, -40.761), 矢量(13.647,
			6.748, -21.739), 矢量(12.188, 11.229, 18.132), 矢量(-8.885, 3.939, 21.055), 矢量(-14.029, -0.985, -23.838), 矢量(-13.728, 1, -34.073),
			矢量(-38.340, 1, -61.726), 矢量(-8.717, 5, -36.720), 矢量(-15.095, -1.175, -18.227), 矢量(-5.603, 1, -14.827), 矢量(-6.218, 7.983,
			-10.297), 矢量(29.771, 10.463, -4.001), 矢量(4.936, 7.724, -0.271), 矢量(1.896, 1, 0.963), 矢量(24.571, 6, 10.505), 矢量(17.430, 9.582,
			17.291), 矢量(5.330, 7.965, 11.858), 矢量(5.295, 3.989, 26.929), 矢量(10.419, -0.645, 27.035), 矢量(7.024, 4, 27.758), 矢量(2.948, 2.374,
			37.042), 矢量(-2.681, 3.982, 28.844), 矢量(-12.652, -0.984, -10.839), 矢量(-8.332, 1, -10.371), 矢量(-23.014, -1.243, -14.536), 矢量(
			-22.956, -1, -47.039), 矢量(-29.779, 1, -53.810), 矢量(-19.537, 3, -49.068), 矢量(-13.374, 1, -34.237), 矢量(-11.655, 0.642, -18.095),
			矢量(-13.320, 1, -34.261), 矢量(-36.209, 1, -64.290), 矢量(-18.766, -0.925, -75.163), 矢量(-3.726, 4, -64.767), 矢量(0.946, 7.010,
			-91.455), 矢量(-25.943, 1, -85.285), 矢量(9.497, 7.010, -82.154), 矢量(-8.531, 9, -64.271), 矢量(5.126, -1.607, -52.860), 矢量(0.351,
			4.088, -58.982), 矢量(13.241, 7.071, -49.116), 矢量(29.992, 2, -31.590), 矢量(12.438, 6.757, -20.841), 矢量(-3.948, 7, -20.986), 矢量(
			-13.961, 1, 26.522), 矢量(-16.520, 3.943, 22.322), 矢量(-14.176, 1, 4.222), 矢量(-15.317, 3.892, 12.866), 矢量(-3.169, 7.982, 12.512),
			矢量(6.516, 9.334, 20.821), 矢量(11.427, 4.202, 11.429), 矢量(25.791, 6.010, 10.251), 矢量(48.748, 6, 6.422), 矢量(60.938, 6, -12.800),
			矢量(28.952, 10.464, -4.147), 矢量(27.492, 2, -28.421), 矢量(-15.738, -0.406, -32.690), 矢量(-17.715, 1, -60.746), 矢量(-20.186, 4,
			-57.163), 矢量(-9.210, 5, -36.549), 矢量(5.020, 7.884, -7.887), 矢量(13.404, 6.744, -21.422), 矢量(40.462, 6, -2.899), 矢量(13.628,
			11.233, 19.394), 矢量(9.034, 6.919, -20.135), 矢量(-13.474, 1, -26.738), 矢量(-4.469, 7.090, -19.937), 矢量(25.397, 6, 10.209), 矢量(
			6.158, 4, 27.519), 矢量(12.716, 11.217, 20.770), 矢量(23.933, 6, 10.061), 矢量(13.552, 0.983, -4.316), 矢量(13.762, 6.750, -20.753),
			矢量(-0.391, 4, -59.629), 矢量(-8.845, 9, -65.598), 矢量(-2.122, 2.416, -82.034), 矢量(7.332, -1.895, -79.102), 矢量(7.717, 4, -76.548),
			矢量(-3.670, -1.903, -68.131), 矢量(-1.876, 4, -66.865), 矢量(-9.314, 9, -64.665), 矢量(-21.257, 4, -57.560), 矢量(-31.961, 1, -69.186),
			矢量(-22.199, 2.996, -66.619), 矢量(-20.988, 4, -57.246), 矢量(-9.924, 7, -27.601), 矢量(13.045, 6.737, -20.514), 矢量(47.025, 6, 8.256),
			矢量(26.100, 6, 10.437), 矢量(28.869, 10.445, -3.015), 矢量(14.358, 4, -73.837), 矢量(29.467, 1.838, -42.993), 矢量(24.394, 0.839,
			-30.361), 矢量(12.704, 6.747, -20.655), 矢量(44.129, 6, -6.246), 矢量(49.006, 6, 5.169), 矢量(33.297, 0.046, -4.333), 矢量(27.619, 2,
			-28.483), 矢量(35.114, 2, -25.698), 矢量(35.610, 3, -21.791), 矢量(26.390, 0, 7.177), 矢量(26.657, 6, 9.987), 矢量(36.443, 0.133,
			-1.137), 矢量(5.383, 7.769, -4.487));
		全局.SecondaryFireState = 数组(假, 假, 假, 真, 假, 真, 假, 真, 假, 假, 真, 假, 真, 真, 假, 真, 假, 真, 真, 真, 假, 真, 真, 真, 假, 真, 假, 假, 假, 假, 假, 假, 假, 真, 假,
			假, 真, 假, 假, 假, 真, 真, 真, 真, 真, 真, 真, 真, 真, 假, 真, 真, 真, 真, 真, 真, 假, 真, 假, 真, 假, 假, 真, 真, 真, 真, 真, 真, 真, 假, 真, 真, 真, 真, 真, 真, 真,
			真, 真, 真, 真, 假, 假, 真, 真, 假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 真, 真, 真, 真, 假, 真, 假, 假, 真, 真, 假, 假, 真, 假, 假, 假, 假, 假, 真);
		全局.UltimateState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 矢量(15.024,
			-0.911, -4.082));
		全局.JumpState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 真, 假, 假, 假);
		全局.SpherePosition = 数组(0, 矢量(-11.048, 5.598, -32.761), 0, 矢量(-19.507, -0.247, -42.163), 0, 0, 矢量(-3.085, 1.617, -33.065), 0, 矢量(
			18.559, 5.917, -69.785), 0, 矢量(-2.064, 2.678, -82.603), 0, 0, 0, 0, 矢量(0.416, 7.013, 19.112), 0, 矢量(-13.780, 2.695, -29.762),
			0, 0, 0, 0, 0, 0, 0, 0, 矢量(-5.793, 7.070, -2.611), 0, 0, 0, 0, 0, 0, 0, 0, 0, 矢量(-17.098, 1.657, -11.920), 矢量(-29.580, -1.630,
			-7.877), 0, 矢量(-22.127, 5.275, -50.465), 0, 0, 0, 矢量(-39.208, 3.390, -60.093), 矢量(-29.840, 1.075, -67.855), 0, 0, 0, 0, 0, 矢量(
			-0.903, 4.113, -60.533), 0, 0, 矢量(26.134, -0.268, -45.243), 0, 0, 矢量(-14.359, 13.862, 13.720), 0, 0, 0, 0, 0, 0, 矢量(-2.184,
			3.334, -1.169), 矢量(42.960, 13.118, 5.203), 矢量(61.950, 9.838, -14.693), 矢量(43.149, 14.333, -8.723), 矢量(19.237, 14.474, -24.546),
			矢量(-7.453, 10.411, -34.170), 矢量(-13.542, 3.231, -52.611), 0, 0, 矢量(1.527, 13.585, -10.271), 矢量(13.876, 5.424, -30.545), 0, 0,
			矢量(18.810, 14.292, -11.433), 矢量(-13.348, 12.362, -23.474), 0, 0, 0, 矢量(23.367, 8.930, 26.959), 0, 矢量(18.741, 4.176, 6.909), 0,
			矢量(4.704, 9.416, -37.319), 矢量(-2.915, 7.011, -61.600), 矢量(0.990, -0.199, -79.566), 0, 0, 矢量(0.737, 0.056, -73.709), 0, 矢量(
			-1.398, 6.799, -68.631), 0, 矢量(-27.110, 1.012, -62.866), 0, 矢量(-21.002, 1.070, -61.693), 矢量(-13.731, 9.033, -43.396), 0, 矢量(
			27.505, 10.161, 1.814), 矢量(60.896, 6.212, 9.726), 0, 0, 矢量(21.044, 6.061, -68.303), 0, 0, 0, 0, 0, 矢量(18.937, 14.313, -25.205),
			矢量(33.993, 9.128, -25.726), 0, 0, 0, 0, 0);
		"小字消息；索引 填写关卡;    \n字符串 填写文本 (一关可以多个文本) "
		全局.Tips[2] = 自定义字符串("关键词: 下压;\n全力向前跳出，快到达点位时按下压(Ctrl)");
		全局.Tips[3] = 自定义字符串("关键词: 下压;\n向外跳出，与墙空出一定距离，视角正对目标点按下压(Ctrl)");
		全局.Tips[4] = 自定义字符串("抓钩直接到达，无需下压");
		全局.Tips[8] = 自定义字符串("跳出后钩上方房檐，到达糖果所在房檐后滚落进点");
		全局.Tips[9] = 自定义字符串("全力向前跳出，快到达点位时略向右转视角正对点位按下压(Ctrl)");
		全局.Tips[10] = 自定义字符串("关键词：偷步;\n向前走出点位(不要按空格)，落地前按住空格(糖果处)");
		全局.Tips[17] = 自定义字符串("关键词：蹭墙;\n面向目标点,按住W,在快撞墙的瞬间按空格,可以跳得很高");
		全局.Tips[21] = 自定义字符串("关键词：蹭墙;\n面向墙面,按住W,在快撞墙的瞬间按空格,转视角面对目标点下压");
		全局.Tips[31] = 自定义字符串("关键词：蹭墙;\n按住W,在快撞墙的瞬间按空格,转视角面对目标点下压");
		全局.Tips[86] = 自定义字符串("关键词：蹭墙;\n按住W,在快撞墙的瞬间按空格,蹭起来后按D移动到目标点附近下压");
		全局.Tips[89] = 自定义字符串("关键词：蹭墙;\n蹭墙之后要按S后退一个球的距离再按下压(CTRL)");
	}
}

规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 暴雪世界")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(暴雪世界);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		全局.CheckpointPosition = 数组(矢量(3.515, -1.800, -7.452), 矢量(-1.460, 2.468, 0.429), 矢量(8.051, 2.471, 0.706), 矢量(12.471, 2.516, 4.298),
			矢量(7.743, 2.221, 13.559), 矢量(-1.579, 2.469, 14.477), 矢量(-10.617, -4.100, -8.067), 矢量(-13.774, -0.819, -7.161), 矢量(10.846,
			0.204, 22.795), 矢量(-14.010, 6.067, 50.696), 矢量(-12.024, 0.004, 40.135), 矢量(-9.713, 7.014, 45.985), 矢量(30.199, 7.206, 68.450),
			矢量(10.340, 3.240, 68.694), 矢量(28.729, 2.001, 83.060), 矢量(29.160, 5.673, 76.635), 矢量(29.206, 6.034, 72.284), 矢量(-5.464, 3.992,
			58.421), 矢量(-3.149, 1.424, 62.569), 矢量(-3.597, 6.065, 54.400), 矢量(3.555, -0.090, 46.260), 矢量(-3.560, 6.075, 51.141), 矢量(5.213,
			-0.972, 109.498), 矢量(16.575, -0.967, 98.677), 矢量(12.009, 6.493, 93.409), 矢量(30.237, 2.236, 90.396), 矢量(11.280, -0.961, 98.423),
			矢量(12.583, 6.493, 92.255), 矢量(-0.354, 2.438, 91.760), 矢量(-41.931, -0.117, 131.523), 矢量(-26.595, 6, 86.547), 矢量(-45.570, 7.278,
			86.044), 矢量(-39.457, 5.108, 91.451), 矢量(-41.674, 9.105, 101.823), 矢量(-57.421, -0.205, 128.491), 矢量(-59.800, 0.753, 124.784),
			矢量(-76.930, 1.797, 112.412), 矢量(-74.620, 6.772, 110.153), 矢量(-67.993, 6.792, 109.646), 矢量(-61.991, 0.747, 137.639), 矢量(-71.101,
			6.580, 110.012), 矢量(-80.037, 6.773, 94.913), 矢量(-63.060, 6.357, 84.116), 矢量(-10.234, 2, 77), 矢量(-2.026, 6.501, 84.594), 矢量(
			-18.431, 1.928, 83.322), 矢量(-1.776, -0.090, 41.532), 矢量(-19.081, 6.377, 64.979), 矢量(-34.730, 6.120, 44.632), 矢量(-13.784, 1,
			34.336), 矢量(-27.723, -2, 13.681), 矢量(7.227, -5.100, 17.030), 矢量(10.604, -3.984, -1.296), 矢量(8.983, 2.464, 0.008), 矢量(4.015, 0,
			10.055), 矢量(-4.150, 6.065, 53.029), 矢量(-2.139, 3.852, 64.989), 矢量(-38.173, -0.205, 67.612), 矢量(-38.282, -0.205, 96.405), 矢量(
			-79.332, 0.728, 128.594), 矢量(-77.160, 0.897, 140.050), 矢量(-113.368, -3.296, 101.859), 矢量(-114.674, 4.902, 101.114), 矢量(-98.692,
			-1.253, 116.372), 矢量(-63.499, 6.622, 82.170), 矢量(-61.938, -0.069, 79.891), 矢量(-61.973, 5.824, 85.930), 矢量(2.200, 3.600,
			43.708), 矢量(-7.493, 1.478, 61.972), 矢量(22.501, 6, 62.902));
		全局.SecondaryFireState = 数组(假, 假, 假, 假, 假, 真, 假, 真, 真, 假, 假, 真, 假, 真, 假, 假, 真, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 真, 真, 假, 假, 假, 真, 假,
			真, 假, 假, 假, 真, 真, 假, 真, 假, 假, 真, 真, 真, 真, 真, 真, 真, 假, 假, 真, 假, 真, 真, 真, 假, 真, 假, 假, 真, 假, 真, 真, 假, 假);
		全局.UltimateState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 矢量(
			-35.653, 11.886, 106.123), 假, 矢量(-62.851, 0.335, 111.684), 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 矢量(5.477,
			0.089, 38.579), 假, 假, 矢量(-34.769, -0.223, 77.240), 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假);
		全局.Creator = 数组(自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串(
			"亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串(
			"亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串(
			"亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串(
			"亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串(
			"亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串(
			"亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("关上九楼"), 自定义字符串("关上九楼"), 自定义字符串("关上九楼"), 自定义字符串("关上九楼"), 自定义字符串("关上九楼"), 自定义字符串("关上九楼"),
			自定义字符串("关上九楼"), 自定义字符串("关上九楼"), 自定义字符串("关上九楼"), 自定义字符串("关上九楼"), 自定义字符串("大飞鱼"), 自定义字符串("大飞鱼"), 自定义字符串("大飞鱼"), 自定义字符串("大飞鱼"),
			自定义字符串("大飞鱼"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"),
			自定义字符串("源氏"), 自定义字符串("源氏"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"));
		全局.JumpState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假);
		全局.SpherePosition = 数组(0, 0, 0, 0, 0, 0, 矢量(-17.337, 10.825, 1.064), 0, 0, 0, 0, 0, 矢量(19.476, 15.235, 53.716), 0, 0, 0, 矢量(29.160,
			1.914, 74.216), 0, 0, 0, 0, 0, 矢量(0.190, 7.837, 61.665), 0, 0, 0, 0, 0, 矢量(6.323, -0.417, 97.489), 0, 0, 0, 矢量(-39.396, 0.260,
			84.823), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 矢量(0.417, 2.220, 61.384), 0, 0, 0, 0, 0, 0, 0,
			矢量(-80.540, 6.833, 94.777), 0, 矢量(-66.669, 0.656, 85.933), 0, 0, 0);
	}
}

规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 巴黎")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(巴黎);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		全局.CheckpointPosition = 数组(矢量(14.599, 11.681, -47.508), 矢量(-15.592, 10.023, -54.900), 矢量(-15.081, 16, -56.004), 矢量(-16.154, 14,
			-47.786), 矢量(-25.440, 12.740, -8.877), 矢量(-33.668, 15.979, -12.146), 矢量(-40.560, 13.990, -11.998), 矢量(-43.095, 19.465,
			-10.611), 矢量(-54.071, 11.990, 2.126), 矢量(-49.920, 11.583, 5.408), 矢量(-60.096, 14.677, -19.717), 矢量(-54.899, 15.018, -8.359));
		全局.SecondaryFireState = 数组(真, 假, 假, 真, 假, 假, 假, 假, 假, 真, 假);
		全局.UltimateState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假);
		全局.Creator = 数组(自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串(
			"亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"), 自定义字符串("亦是此间少年"));
		全局.JumpState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假);
		全局.SpherePosition = 数组(0, 矢量(-6.104, 24.452, -63.163), 0, 0, 0, 矢量(-31.406, 10.572, -10.542), 0, 0, 0, 矢量(-52.198, 16.344, 3.083),
			矢量(-77.772, 24.339, 14.544), 0);
	}
}

规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 马莱温多")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(马莱温多);
		当前游戏模式 == 游戏模式(团队死斗);
	}

	动作
	{
		全局.CheckpointPosition = 数组(矢量(16.671, 0.981, -26.167), 矢量(16.556, 3, -19.696), 矢量(8.527, -1, -22.178), 矢量(7.228, 4.652, -19.076),
			矢量(-0.814, -3.500, -34.108), 矢量(-14.248, -2.990, -30.901), 矢量(-33.766, -2, 6.872), 矢量(-33.911, 4, 5.544), 矢量(-33.521, -2,
			10.577), 矢量(-34.833, 0.010, 19.375), 矢量(-19.744, 0, 11.620), 矢量(-12.911, 4.103, 13.443), 矢量(-0.027, 10.096, 0.739), 矢量(-5.195,
			5.037, 13.689), 矢量(-0.262, 10.103, 25.955), 矢量(0.169, 1.750, 34.510), 矢量(2.900, 2.282, 10.224), 矢量(31.990, 5.117, 31.136), 矢量(
			21.840, 8.314, 34.156), 矢量(31.538, 3.155, 26.356), 矢量(24.234, 8.713, 21.428), 矢量(32.704, 7.492, 23.932), 矢量(21.763, 9.046,
			35.607), 矢量(25.336, 8.822, 21.704), 矢量(17.680, 6.523, 6.135), 矢量(1.446, -1, -8.110), 矢量(-1.970, -1, -17.884), 矢量(-8.827, 5.114,
			-21.205), 矢量(-28.450, -2.041, -16.828), 矢量(-27.884, 3.010, -0.475), 矢量(-25.980, -2.070, -21.695), 矢量(-20.008, 2.004, -17.528),
			矢量(-7.754, 5.120, -19.574), 矢量(9.506, 3.095, -8.672), 矢量(-1.744, 5.125, -18.637), 矢量(-0.571, 2.673, 42.960), 矢量(-30.556, 4.750,
			20.132), 矢量(-33.340, 4, 9.512), 矢量(7.661, -2.046, -32.677), 矢量(8.150, -1, -27.877), 矢量(0.360, -3.478, -37.379), 矢量(-16.445, -3,
			-28.918), 矢量(22.512, 2.573, -17.646), 矢量(-19.053, -3, -31.734), 矢量(25.211, 8.828, 21.859), 矢量(16.766, 9, 31.436), 矢量(0.708,
			10.288, 0.880), 矢量(0.864, 1.751, 33.339), 矢量(-15.550, -2.692, -26.547), 矢量(-34.439, -6.063, 41.478));
		全局.SecondaryFireState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 真, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真,
			真, 假, 真, 假, 假, 真, 假, 真, 真, 假, 假, 真, 假, 假);
		全局.UltimateState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 矢量(-14.678, 0.187, -26.220), 假, 假, 假, 假, 假);
		全局.Creator = 数组(自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"),
			自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"),
			自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"),
			自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"),
			自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("十元"), 自定义字符串("冰泽"), 自定义字符串("冰泽"), 自定义字符串("冰泽"), 自定义字符串("Exit"), 自定义字符串(
			"Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"));
		全局.CurrentMap = 地图(马莱温多);
		全局.JumpState = 数组(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假);
	}
}

规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 66号公路")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(66号公路);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		全局.CheckpointPosition = 数组(矢量(-101.870, 16.188, -7.856), 矢量(-95.753, 12.632, -3.193), 矢量(-78.701, 10.867, -14.920), 矢量(-77.152,
			12.500, -0.719), 矢量(-58.663, 11.751, 21.533), 矢量(-78.994, 13.361, 12.514), 矢量(-78.445, 12.500, -1.532), 矢量(-106.843, 12.498,
			-21.750), 矢量(-83.475, 12.901, -28.662), 矢量(-95.753, 12.632, -3.193), 矢量(-77.585, 13.361, 13.251), 矢量(-54.676, 12.639, 15.244),
			矢量(-63.213, 10.867, 7.334), 矢量(-94.616, 14.301, 5.276), 矢量(-81.386, 12.843, -28.555), 矢量(-77.695, 13.361, 12.985), 矢量(-63.199,
			10.867, 7.490), 矢量(-45.271, 3.402, 8.547), 矢量(-42.127, 3.393, 4.095), 矢量(-37.314, 8.601, -10.975), 矢量(-33.873, 12.762,
			-12.425), 矢量(-27.075, 8.748, 1.281), 矢量(-20.946, 12.408, -15.101), 矢量(14.005, 8.532, -22.285), 矢量(24.602, 8.039, -12.530), 矢量(
			15.189, 7.771, 8.061), 矢量(46.720, 7.787, -0.588), 矢量(33.017, 5.651, 47.713), 矢量(20.768, 6.802, 17.449), 矢量(52.679, 10.913,
			45.607), 矢量(54.190, 0.223, 54.062), 矢量(43.960, 2.384, 56), 矢量(37.277, 0.226, 44.041), 矢量(52.854, 7.034, 20.646), 矢量(67.353,
			-0.043, 28.541), 矢量(64.567, 3.462, 26.769), 矢量(70.815, -0.024, 13.553), 矢量(65.629, 4.823, 14.794), 矢量(63.306, 9.264, 12.772),
			矢量(50.472, 2.368, 8.411), 矢量(50.950, 7.582, 11.044), 矢量(54.290, 12.828, 10.727), 矢量(62.885, 2.459, 15.798), 矢量(63.731, 9.275,
			12.097), 矢量(52.320, 7.770, -0.468), 矢量(46.641, 2.174, 0.812), 矢量(38.891, 6.978, 2.357), 矢量(32.989, 7.930, 1.952), 矢量(20.218,
			2.086, 12.656), 矢量(12.991, 7.678, 2.574), 矢量(20.438, 2.093, -10.370), 矢量(19.064, 8.006, -20.089), 矢量(15.809, 2.418, -15.876),
			矢量(30.792, 7.005, 8.196), 矢量(41.531, 2.094, 7.646), 矢量(14.029, 7.621, 2.572), 矢量(12.220, 2.252, -0.177), 矢量(36.898, 6.742,
			-10.907), 矢量(23.698, 2.094, -9.393), 矢量(48.486, 7.395, -0.793), 矢量(58.390, 2.156, 15.066), 矢量(50.586, 11.259, 44.158), 矢量(
			54.716, 0.545, 49.524), 矢量(50.188, 7.010, 48.617), 矢量(56.172, 9.022, 41.987), 矢量(72.126, 0.240, 42.513), 矢量(61.809, 9.224,
			12.917), 矢量(33.478, 2.095, 15.844), 矢量(24.551, 7.509, -12.364), 矢量(-26.697, 8.739, 0.266), 矢量(-18.127, 3.104, -5.492), 矢量(
			-18.485, 8.763, -15.114), 矢量(-17.634, 3.308, -33.227), 矢量(-24.060, 9.847, -34.578), 矢量(-29.027, 12.762, -27.139), 矢量(-39.582,
			3.504, -37.708), 矢量(-34.687, 12.598, -15.079), 矢量(0.126, 7.227, -20.109), 矢量(-10.471, 8.132, -9.527), 矢量(-49.583, 3.308,
			-12.280), 矢量(-49.682, 8.881, -16.343), 矢量(-42.115, 3.347, -0.062), 矢量(-35.746, 10.601, 3.870), 矢量(-34.191, 12.752, -11.601),
			矢量(-42.106, 3.347, 4.141), 矢量(-59.214, 11.751, 22.188), 矢量(-52.208, 6.500, 22.029), 矢量(-77.857, 13.128, 10.090), 矢量(-76.846,
			6.500, 10.874), 矢量(-79.634, 13.419, 11.470), 矢量(-76.911, 6.500, -0.744), 矢量(-77.326, 12.500, -0.621), 矢量(-77.262, 6.500,
			-1.427), 矢量(-108.313, 13.084, -21.332), 矢量(-97.450, 6.500, -31.707), 矢量(-103.393, 12.500, -25.263), 矢量(-102.920, 6.500,
			-21.568), 矢量(-83.464, 13.420, 9.494), 矢量(-88.580, 6.500, -27.985), 矢量(-80.271, 12.843, -28.530), 矢量(-83.416, 18.650, -22.219));
		全局.SecondaryFireState = 数组(假, 真, 真, 真, 真, 假, 真, 真, 真, 真, 真, 假, 真, 真, 真, 假, 真, 假, 真, 假, 假, 真, 真, 假, 真, 真, 真, 真, 真, 假, 假, 假, 真, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 真, 假, 真, 假, 真, 假, 真, 假, 假, 假, 假, 真, 真, 真, 真, 假, 假, 假, 假, 假, 假, 真, 真,
			假, 真, 假, 假, 假, 假, 假, 真, 假, 真, 假, 假, 假, 假, 假, 真, 假, 假, 假, 真, 真, 假, 假);
		全局.UltimateState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 0, 假, 矢量(20.645, 2.171, -7.310), 假, 矢量(24.621, 2.186, 13.944), 假, 矢量(19.136,
			2.188, -9.265), 假, 矢量(37.218, 2.124, -14.471), 假, 矢量(54.788, 0.699, 28.936), 假, 假, 假, 假, 矢量(66.537, 0.066, 31.912), 假, 矢量(
			26.901, 2.081, 5.468), 假, 假, 假, 假, 假, 假, 假, 矢量(-36.315, 3.397, -29.852), 矢量(-24.843, 12.689, -16.292), 假, 假, 假, 假, 假, 假, 假, 矢量(
			-51.679, 6.592, 23.286), 假, 矢量(-62.660, 6.592, 10.421), 假, 假, 假, 假, 假, 矢量(-93.347, 6.592, -9.616), 假, 假, 假, 矢量(-83.757, 6.592,
			-11.520), 假, 假, 假);
		全局.JumpState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假);
	}
}

规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 沃斯卡亚工业区")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(沃斯卡娅工业区);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		全局.CheckpointPosition = 数组(矢量(-7.718, 9.015, 38.725), 矢量(-13.974, 4.838, 46.089), 矢量(-19.066, 0.297, 43.138), 矢量(-28.550, 2.011,
			36.672), 矢量(-32.298, 1.944, 25.423), 矢量(-26.881, -1.318, 9.117), 矢量(-18.455, -6.979, -1.958), 矢量(-25.990, -4.438, 4.398), 矢量(
			-29.758, -0.381, 10.657), 矢量(-35.649, 2.796, 13.854), 矢量(-43.853, 4.592, 14.152), 矢量(-9.153, 9.005, 35.087), 矢量(-28.551, 2.785,
			41.085), 矢量(-18.003, 2.961, 54.234), 矢量(19.500, 4.243, 46.929), 矢量(31.542, -4.046, 72.066), 矢量(25.180, 1.020, 89.595), 矢量(
			-1.728, 1.920, 97.232), 矢量(-17.625, 2.952, 56.644), 矢量(-14.191, 4.836, 46.026), 矢量(22.166, -3.654, 41.449), 矢量(11.412, -1.980,
			76.513), 矢量(-30.441, 2.020, 73.943), 矢量(-29.667, 2.020, 108.528), 矢量(-64.943, 2.020, 96.583), 矢量(-99.742, 2.020, 76.147), 矢量(
			-84.450, 2.020, 48.578), 矢量(-78.521, 2.020, 75.100), 矢量(-67.448, 2.020, 81.713), 矢量(-73.123, 2.020, 69.082), 矢量(-84.102, 2.024,
			37.749), 矢量(-77.960, 0.020, 21.107), 矢量(-65.232, -0.609, 35.339), 矢量(-94.241, -0.725, 49.021), 矢量(-96.270, 2.513, 54.571), 矢量(
			-102.974, 2.020, 47.055), 矢量(-109.573, -2.073, 68.872), 矢量(-101.384, 2.020, 73.695), 矢量(-66.618, 2.020, 81.553), 矢量(-80.315,
			-0.073, 58.568), 矢量(-46.182, -0.054, 73.871), 矢量(-7.306, 3.096, 77.659), 矢量(-25.186, 0.383, 73.109), 矢量(-0.936, 5.281, 45.132),
			矢量(-29.638, 2.097, 69.758), 矢量(-21.672, -2.971, 118.573), 矢量(25.617, -4.046, 90.632), 矢量(25.817, 1.020, 89.765), 矢量(-29.658,
			2.097, 76.590), 矢量(-29.842, 2.106, 69.770), 矢量(0.084, 2.020, 103.680), 矢量(-47.214, 2.100, 89.700), 矢量(-60.517, 0.815, 59.714),
			矢量(-102.532, 2.020, 44.291), 矢量(-65.788, -0.609, 35.188), 矢量(-63.991, -0.406, 77.714), 矢量(-24.896, 0.383, 73.339), 矢量(-1.063,
			5.281, 44.932), 矢量(-14.016, 4.844, 45.677), 矢量(-18.253, -3.321, 51.870), 矢量(-17.753, 2.955, 54.888), 矢量(-21.438, -3.593,
			42.954), 矢量(-17.297, 2.946, 53.617), 矢量(-20.020, -3.290, 67.727), 矢量(-30.170, 2.020, 74.084), 矢量(-4.126, -3.920, 92.120), 矢量(
			-2.360, 1.920, 96.775), 矢量(-47.490, 2.104, 89.741), 矢量(-61.989, -3.980, 66.657), 矢量(-66.475, -2.980, 66.570), 矢量(-62.056,
			-2.480, 44.083), 矢量(-67.141, 2.520, 43.798), 矢量(-92.973, 6.020, 39.529), 矢量(-90.421, 2.020, 37.342), 矢量(-100.028, 2.020,
			40.007), 矢量(-93.171, 6.020, 39.313), 矢量(-60.556, 0.832, 59.848), 矢量(-47.655, -0.053, 74.131), 矢量(-55.790, 2.575, 80.341), 矢量(
			-55.790, -3.980, 80.341), 矢量(-65.747, 2.529, 52.303), 矢量(-62.675, -4.161, 73.074), 矢量(-49.301, 2.020, 89.054), 矢量(-13.797,
			-4.046, 113.369), 矢量(-16.968, 1.943, 79.383), 矢量(-3.401, -4.217, 82.955), 矢量(-2.397, 1.920, 96.797), 矢量(-18.749, -3.840,
			95.123), 矢量(-17.709, 2.964, 57.802), 矢量(-20.729, -3.287, 73.292), 矢量(-0.903, 5.287, 44.762), 矢量(12.908, 4.244, 46.895), 矢量(
			25.587, -4.046, 102.240), 矢量(-16.917, 1.020, 105.960), 矢量(-26.695, 2.020, 102.450), 矢量(-56.269, 2.576, 95.515), 矢量(-60.819,
			-4.066, 92.715), 矢量(-76.606, 2.020, 73.341), 矢量(-97.762, -3.980, 69.232), 矢量(-79.872, -1.980, 88.098), 矢量(-78.819, 2.194,
			81.570));
		全局.SecondaryFireState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 真, 真, 真, 真, 真, 真, 假, 真, 真, 真, 真, 真, 真, 真, 真, 假, 假, 真, 假, 假, 真, 假, 假,
			真, 假, 真, 真, 真, 真, 假, 真, 真, 真, 真, 假, 真, 假, 真, 真, 真, 真, 真, 真, 真, 真, 假, 假, 假, 假, 假, 假, 假, 真, 假, 真, 真, 假, 真, 假, 真, 假, 假, 假, 真, 真,
			假, 假, 真, 真, 真, 真, 真, 假, 真, 假, 真, 假, 真, 假, 真, 真, 假, 真, 假, 真, 真, 真, 真);
		全局.UltimateState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 矢量(-55.102, -4.069, 62.388), 假, 矢量(-51.788, -4.071, 69.096), 假, 矢量(-12.548, -3.956, 102.714), 假, 矢量(-11.462, -3.805,
			97.180), 假, 矢量(-22.136, -3.170, 74.394), 假, 矢量(-14.273, -3.211, 66.909), 假, 假, 矢量(-9.028, -3.592, 100.041), 假, 假, 假, 矢量(
			-75.195, -3.991, 85.520), 假, 矢量(-93.547, -3.878, 81.104), 假);
		全局.Creator = 数组(自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串(
			"抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串(
			"抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串(
			"抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串(
			"抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串(
			"抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串(
			"抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串(
			"抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串(
			"抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串(
			"抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串(
			"抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串(
			"抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串(
			"抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串(
			"抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串(
			"抱着奶喵0"), 自定义字符串("抱着奶喵0"), 自定义字符串("抱着奶喵0"));
	}
}

规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 好莱坞（清尘）")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(好莱坞);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("通关教学: b站up:Stan_sin\r\n  BV1wN411o7gB"), 左边, 1, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		全局.CheckpointPosition = 数组(矢量(-18.804, 1.604, -3.465), 矢量(-18.123, 5.751, -6.021), 矢量(-19.540, 1.604, -3.701), 矢量(-23.356, 5.751,
			-9.992), 矢量(-32.195, 4.435, -8.821), 矢量(-34.935, 1.750, -7.087), 矢量(-33.513, 4.425, -10.031), 矢量(-22.626, 5.751, -8.836), 矢量(
			-11.936, 1.750, -7.302), 矢量(-21.219, 1.604, 6.633), 矢量(-24.330, 7.750, 9.071), 矢量(-43.011, 1.750, -0.224), 矢量(-29.329, 13.857,
			-12.210), 矢量(-25.473, 7.760, 6.579), 矢量(5.677, 6.003, 41.026), 矢量(-9.918, 5.012, 44.829), 矢量(-23.552, 5.060, 47.228), 矢量(
			-28.338, 0, 50.134), 矢量(-30.684, 4.840, 49.335), 矢量(-27.851, 1.012, 41.817), 矢量(-26.680, 4.515, 39.002), 矢量(-18.465, 5.060,
			47.457), 矢量(-16.962, 0.007, 60.800), 矢量(-21.536, 3.274, 60.704), 矢量(-23.078, 1.187, 53.208), 矢量(-14.641, 5.012, 46.561), 矢量(
			7.187, -0.146, 57.339), 矢量(7.742, 1.993, 64.585), 矢量(4.049, 0.003, 66.021), 矢量(9.580, 3.230, 60.973), 矢量(17.472, 6.591,
			59.430), 矢量(6.576, 0.004, 49.939), 矢量(6.868, 6.591, 49.518), 矢量(-1.953, -0.136, 42.021), 矢量(5.606, 6.003, 42.057), 矢量(2.405,
			1.230, 33.029), 矢量(5.332, 6.003, 35.717), 矢量(-30.493, 1.541, 24.760), 矢量(-31.800, 5.168, 26.817), 矢量(-27.675, 7.750, 19.024),
			矢量(-28.468, 13.857, -12.014), 矢量(-6.844, 1.604, -13.736), 矢量(-0.050, 6.456, -21.362), 矢量(5.954, 8.348, -21.524), 矢量(6.470,
			1.604, -18.232), 矢量(5.214, 8.348, -21.510), 矢量(19.355, 1.625, -30.953), 矢量(25.327, 4.723, -30.493), 矢量(29.354, 3.895, -38.519),
			矢量(17.275, 7.291, -44.406), 矢量(10.652, 10.750, -39.494), 矢量(-1.073, 6.532, -28.106), 矢量(1.490, 10.732, -29.928), 矢量(6.936,
			7.340, -41.198), 矢量(4.061, 11.104, -38.736), 矢量(-3.132, 1.604, -41.937), 矢量(-4.428, 6.807, -46.438), 矢量(-3.650, 10.010,
			-54.790), 矢量(-5.076, 10.007, -65.811), 矢量(5.834, 11.010, -68.835), 矢量(-15.622, 5.750, -64.267), 矢量(-17.896, 9.750, -101.556),
			矢量(-33.830, -0.140, -113.855), 矢量(-36.520, 7.186, -112.664), 矢量(-39.138, 1.750, -129.576), 矢量(-41.847, 6.805, -128.893), 矢量(
			-29.197, 6.859, -136.480), 矢量(-23.920, 1.750, -142.504), 矢量(-26.168, 6.847, -137.093), 矢量(-23.481, 1.750, -125.397), 矢量(
			-21.983, 9.805, -126.139), 矢量(-36.730, 7.186, -112.164), 矢量(-23.816, 3.051, -92.852), 矢量(-25.836, -0.258, -91.575), 矢量(-21.108,
			3.190, -92.331), 矢量(-17.138, 9.750, -100.523), 矢量(-10.376, 9.749, -102.414), 矢量(23.886, 2.559, -95.005), 矢量(28.372, 6.983,
			-85.729), 矢量(24.374, 6.797, -77.862), 矢量(10.579, 6.003, -69.879), 矢量(8.329, 11.038, -69.698), 矢量(16.746, 1.604, -64.843), 矢量(
			13.849, 6.003, -58.705), 矢量(14.433, 1.750, -38.424), 矢量(12.949, 10.793, -39.295), 矢量(-2.779, 10.010, -54.438), 矢量(-16.475,
			5.751, -6.786), 矢量(3.015, 3.964, -11.888), 矢量(4.276, 8.348, -21.276), 矢量(3.490, 3.731, -22.499), 矢量(2.948, 10.750, -28.941),
			矢量(-28.397, 13.857, -12.345), 矢量(3.143, 3.964, -11.364), 矢量(0.948, 6.558, -20.576), 矢量(-7.823, 1.757, -13.681), 矢量(-16.251,
			1.750, -16.394), 矢量(-13.402, 5.751, -11.473), 矢量(-7.124, 6.688, -41.178), 矢量(0.372, 1.604, -42.233), 矢量(6.231, 7.435, -40.706),
			矢量(7.275, 12.903, -48.556), 矢量(12.816, 2.232, -70.226), 矢量(20.779, 8.059, -77.852), 矢量(2.612, 1.604, -70.354), 矢量(-3.933,
			3.899, -67.890), 矢量(-4.795, 10.007, -65.959), 矢量(10.704, 6.003, -69.462), 矢量(-3.065, 1.604, -9.074), 矢量(2.588, 3.974, -11.958),
			矢量(-28.245, 13.857, -13.668), 矢量(5.047, 6.647, 33.003), 矢量(-43.603, -0.250, 7.687), 矢量(-45.551, 1.750, -0.037), 矢量(-43.779,
			1.795, -6.357), 矢量(-34.925, 13.884, -13.229), 矢量(-0.010, 11.010, -54.656), 矢量(16.207, 1.604, -58.906), 矢量(16.408, 6.496,
			-46.382), 矢量(15.234, 4.960, -62.313), 矢量(9.049, 11.010, -68.747), 矢量(22.938, 6.974, -83.006), 矢量(-9.343, 9.750, -102.914), 矢量(
			-2.384, 11.834, -112.077), 矢量(-8.399, 2.026, -116.341), 矢量(-12.218, 9.750, -111.669), 矢量(-35.956, 7.186, -112.393), 矢量(-24.711,
			3.051, -92.869), 矢量(-32.355, -0.257, -104.483), 矢量(-38.556, 5.687, -111.651), 矢量(-28.059, 9.750, -116.174), 矢量(-16.701, 3.750,
			-145.317), 矢量(-24.464, 7.232, -134.735), 矢量(-28.629, 6.847, -139.316), 矢量(-41.553, 6.805, -130.857), 矢量(-10.156, 9.750,
			-105.183), 矢量(31.811, 1.604, -82.417), 矢量(30.606, 6.797, -81.451), 矢量(2.599, 3.976, -13.535), 矢量(-12.234, 3.438, -61.194), 矢量(
			-2.368, 1.604, -68.647), 矢量(-4.979, 10.007, -65.988), 矢量(-24.199, 1.778, -107.476), 矢量(-36.224, 7.186, -112.573), 矢量(11.440,
			7.165, -101.099), 矢量(2.319, 13, -68.937), 矢量(9.847, 6.003, -54.688), 矢量(6.940, 12.903, -49.692), 矢量(-2.296, 6.270, -28.902),
			矢量(1.284, 11.104, -32.564), 矢量(-28.197, 13.857, -13.444), 矢量(2.649, 1.604, -42.483), 矢量(3.412, 11.104, -37.821), 矢量(-4.274,
			1.604, -31.636), 矢量(1.911, 11.104, -34.970), 矢量(-7.896, 1.801, -56.049), 矢量(-6.264, 10.010, -62.998), 矢量(-5.260, 1.604,
			-70.856), 矢量(-2.862, 10.909, -67.446), 矢量(-4.944, 1.604, -70.399), 矢量(6.360, 11.010, -68.939));
		全局.SecondaryFireState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 真, 真, 假, 真, 假, 假, 假, 假, 真, 假, 真, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 真, 假, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 真, 假, 真, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 真,
			假, 假, 假, 假, 假, 假, 真, 假, 假, 真, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 真, 假, 假, 真, 假, 真, 真, 真, 假, 假, 真, 真, 假, 假, 假,
			假, 假, 真, 假, 假, 假, 真, 假, 假, 假, 假, 真, 假, 假, 假, 真, 真, 假, 真, 真, 假, 假, 真, 假, 真, 真, 假, 假, 假, 假, 真, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假);
		全局.UltimateState = 数组();
		全局.Creator = 数组(自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串(
			"清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"),
			自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串(
			"清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"),
			自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串(
			"清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"),
			自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串(
			"清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"),
			自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串(
			"清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"),
			自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串(
			"清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"),
			自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串(
			"清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"),
			自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串(
			"清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"),
			自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串(
			"清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("清尘丶"), 自定义字符串("Exit"), 自定义字符串(
			"Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"));
	}
}

规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 伊利奥斯 小球")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(伊利奥斯);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		全局.CheckpointPosition = 数组(矢量(-53.066, 65.563, -158.868), 矢量(-41.481, 65.557, -156.398), 矢量(-23.160, 68.516, -150.607), 矢量(-15.666,
			68.519, -150.218), 矢量(-0.272, 64.216, -147.604), 矢量(7.327, 66.366, -148.684), 矢量(45.021, 66.369, -148.691), 矢量(72.431, 68.516,
			-150.612), 矢量(108.040, 64.441, -160.208), 矢量(83.765, 67.654, -179.230), 矢量(41.523, 68.689, -163.344), 矢量(-16.158, 64.484,
			-172.606), 矢量(-28.272, 58.367, -176.895), 矢量(-52.384, 69.646, -172.955), 矢量(-18.287, 70.135, -180.129), 矢量(-3.356, 68.865,
			-180.620), 矢量(4.374, 65.252, -160.554), 矢量(57.818, 64.216, -147.995), 矢量(6.714, 63.916, -171.271), 矢量(1.977, 67.531, -180.128),
			矢量(55.558, 64.484, -177.988), 矢量(79.525, 68.517, -162.871), 矢量(82.626, 67.664, -178.733), 矢量(118.731, 60.746, -146.016), 矢量(
			-187.297, -0.167, -86.975), 矢量(-199.021, 5.223, -49.174), 矢量(-236.282, 6.915, -24.420), 矢量(-266.301, -0.561, 15.198), 矢量(
			-259.860, -5, 23.913), 矢量(-237.179, 5.200, 7.816), 矢量(-217.498, 5.007, 2.155), 矢量(-206.628, 6.977, -2.651), 矢量(-204.923, 9.895,
			-5.844), 矢量(-188.647, 6.977, -7.396), 矢量(-157.142, 2.989, -64.444), 矢量(-173.281, 5.138, -33.336), 矢量(-197.578, 9.895, -12.903),
			矢量(-223.455, 7.313, -2.965), 矢量(-223.788, 5.561, -16.063), 矢量(-233.645, 5.637, -20.770), 矢量(-234.657, 8.986, 23.078), 矢量(
			-223.132, 5.091, 7.817), 矢量(-212.920, 10.022, -24.850), 矢量(-217.083, 12.995, -21.887), 矢量(357.168, -10.570, -47.793), 矢量(
			345.979, -18.444, -33.311), 矢量(355.214, -17.774, -41.306), 矢量(300.813, -14.850, -46.625), 矢量(298.698, -20.631, -70.495), 矢量(
			301.481, -16.162, -71.960), 矢量(287.277, -17.803, -77.776), 矢量(339.324, -27.641, -83.165), 矢量(327.966, -14.747, -45.585), 矢量(
			335.512, -18.603, -19.585), 矢量(326.184, -17.196, 15.845), 矢量(331.264, -17.654, -31.360), 矢量(354.094, -10.745, -53.223), 矢量(
			355.234, -25.641, -54.600), 矢量(327.594, -14.788, -44.456), 矢量(301.959, -16.015, -47.557), 矢量(325.382, -17.654, -46.443), 矢量(
			340.223, -25.641, -54.877), 矢量(360.061, -22.801, -5.976), 矢量(327.756, -18.106, -53.257), 矢量(38.611, 123.674, -93.177), 矢量(
			21.554, 61.356, -136.434), 矢量(2.950, 60.367, -183.866), 矢量(-57.153, 60.523, -187.084), 矢量(-58.006, 65.389, -184.124), 矢量(2.252,
			66.363, -147.897), 矢量(69.231, 63.727, -147.902), 矢量(109.413, 64.446, -160.620), 矢量(54.125, 60.367, -184.525), 矢量(40.853,
			60.367, -175.675), 矢量(-14.502, 68.516, -162.723), 矢量(3.858, 65.075, -161.398), 矢量(-32.727, 68.516, -150.595), 矢量(-22.808,
			58.377, -179.004), 矢量(-11.716, 64.616, -145.347), 矢量(-7.925, 60.367, -139.882), 矢量(4.555, 65.247, -160.084), 矢量(9.933, 63.869,
			-171.125), 矢量(29.195, 60.367, -183.050), 矢量(-195.104, 7.313, -31.515), 矢量(-266.850, -0.562, 15.462), 矢量(-240.814, 1.200,
			-12.408), 矢量(-240.861, 5, -6.463), 矢量(-234.638, 5.031, 6.648), 矢量(-223.134, 7.323, -3.325), 矢量(-244.952, -0.524, -9.203), 矢量(
			-234.804, -1, -24.518), 矢量(-207.339, 6.986, -2.958), 矢量(-204.987, 9.895, -5.540), 矢量(-200.960, 7.323, -27.417), 矢量(-144.596,
			-5.684, -79.672), 矢量(-150.087, -0.871, -79.911), 矢量(-148.290, 4.229, -78.104), 矢量(-187.186, 18.110, 4.161), 矢量(-195.294, 7.313,
			-31.553), 矢量(-205.120, 9.895, -5.317), 矢量(-183.574, 5.012, -33.142), 矢量(-169.074, 5, -23.922), 矢量(362.373, -10.895, -49.140),
			矢量(354.367, -10.677, -53.363), 矢量(334.894, -18.520, -60.912), 矢量(279.060, -18.447, -80.130), 矢量(326.106, -17.645, -46.749), 矢量(
			337.644, -16.261, 4.004), 矢量(349.976, -25.162, 23.313), 矢量(358.678, -27.614, -26.642), 矢量(340.266, -26.954, -82.524), 矢量(
			353.782, -11.091, -54.227), 矢量(328.039, -20.729, 7.363), 矢量(328.993, -18.297, -4.012), 矢量(331.146, -17.654, -31.542), 矢量(
			349.784, -25.641, -36.313), 矢量(317.881, -18.434, -56.889), 矢量(298.998, -20.631, -70.492), 矢量(327.959, -14.759, -45.508), 矢量(
			315.480, -16.024, -13.931), 矢量(325.394, -17.334, 15.307), 矢量(336.287, -16.261, 1.455));
		全局.SecondaryFireState = 数组(假, 真, 假, 假, 假, 真, 真, 真, 真, 真, 真, 假, 真, 真, 假, 假, 真, 真, 假, 真, 真, 假, 真, 假, 真, 真, 真, 假, 真, 真, 假, 假, 假, 真, 真,
			真, 假, 假, 假, 真, 假, 真, 假, 假, 假, 假, 真, 假, 假, 假, 真, 真, 假, 真, 真, 真, 假, 真, 假, 假, 假, 真, 真, 假, 真, 真, 真, 假, 真, 真, 真, 真, 假, 真, 假, 真, 假,
			真, 假, 真, 真, 假, 假, 真, 真, 假, 假, 假, 假, 真, 真, 假, 假, 真, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 真, 真, 真, 假, 真, 真, 真, 真, 假, 假, 假, 真, 假, 真, 假,
			假, 假);
		全局.UltimateState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 矢量(-36.777, 58.459, -177.040), 假, 假, 假, 假, 假, 假, 假, 矢量(62.293, 64.574,
			-172.643), 假, 假, 假, 假, 假, 假, 假, 矢量(-249.627, -4.908, 15.085), 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 矢量(343.807, -25.549, -47.229), 假, 假, 假, 矢量(346.981, -25.549, -36.479), 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 矢量(-21.073, 58.731, -149.399), 假, 矢量(-6.288, 60.459, -158.559), 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 矢量(-226.709, 1.092,
			-16.158), 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 矢量(340.867, -25.549, -54.810), 假, 假, 假, 假,
			假);
		全局.Creator = 数组(自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"));
		全局.JumpState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假);
		全局.SpherePosition = 数组(0, 0, 矢量(-33.072, 62.002, -156.782), 矢量(-19.288, 68.918, -147.584), 0, 矢量(2.938, 64.972, -151.530), 矢量(
			14.585, 66.669, -159.952), 矢量(39.199, 66.056, -153.571), 矢量(88.994, 60.593, -147.642), 矢量(104.317, 62.474, -173.652), 矢量(
			75.254, 61.406, -187.602), 0, 矢量(-21.751, 69.339, -176.197), 0, 矢量(-48.542, 62.750, -182.784), 矢量(-10.652, 65.078, -180.414),
			0, 矢量(12.036, 63.285, -167.567), 矢量(55.084, 62.655, -159.392), 0, 矢量(12.909, 63.694, -160.993), 0, 矢量(76.178, 66.913,
			-168.105), 矢量(118.639, 73.395, -160.751), 0, 0, 矢量(-204.812, 1.861, -48.859), 矢量(-229.225, 4.718, -34.351), 矢量(-257.973, 0.293,
			12.200), 0, 矢量(-237.963, 3.060, 15.932), 矢量(-211.857, 6.231, -3.071), 0, 矢量(-199.082, 9.755, -12.970), 矢量(-180.477, 2.074,
			-14.396), 矢量(-165.059, -0.724, -63.572), 矢量(-174.027, 2.565, -19.207), 矢量(-214.406, 7.440, -4.789), 矢量(-224.761, 9.697,
			-14.329), 矢量(-233.853, 7.173, -17.225), 矢量(-229.405, 9.916, 9.605), 矢量(-224.083, 5.813, 15.284), 0, 0, 0, 0, 0, 矢量(318.658,
			-15.487, -53.765), 0, 0, 0, 矢量(327.181, -22.243, -85.303), 矢量(342.827, -22.055, -87.742), 0, 0, 矢量(334.187, -15.488, -12.823),
			0, 0, 矢量(338.971, -15.263, -43.901), 矢量(316.913, -17.448, -44.047), 0, 0, 0, 矢量(329.848, -13.944, -43.789), 0, 0, 0, 矢量(
			-16.686, 55.466, -190.140), 0, 矢量(-13.827, 69.663, -158.476), 0, 矢量(82.229, 68.670, -162.883), 矢量(114.021, 63.049, -169.886),
			0, 矢量(42.688, 63.778, -159.744), 0, 矢量(26.020, 66.710, -167.452), 0, 0, 矢量(-5.112, 62.948, -147.434), 矢量(-1.686, 66.374,
			-168.441), 矢量(2.073, 74.420, -167.984), 0, 0, 0, 矢量(-240.152, 10.372, -3.741), 0, 矢量(-233.980, 8.347, -2.537), 矢量(-233.362,
			3.535, 0.970), 矢量(-231.244, 12.208, -6.823), 矢量(-236.396, 5.886, -23.325), 矢量(-216.751, 9.777, -7.254), 0, 0, 矢量(-228.484,
			7.650, -22.247), 0, 0, 0, 0, 矢量(-201.283, 14.250, -40.459), 0, 0, 0, 0, 0, 0, 矢量(292.726, -15.587, -51.508), 0, 矢量(353.461,
			-23.461, 15.717), 0, 0, 0, 0, 0, 0, 矢量(342.601, -22.688, -35.100), 0, 矢量(308.466, -18.586, -52.895), 矢量(327.684, -16.697,
			-51.241), 0, 矢量(314.104, -14.103, 2.163), 0);
	}
}

规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 直布罗陀 萌新")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(监测站：直布罗陀);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("通关教学: b站up:Stan_sin\r\n  BV13f4y1z71M"), 左边, 1, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		全局.CheckpointPosition = 数组(矢量(30.354, 5, -151.022), 矢量(35.194, 5, -145.988), 矢量(42.536, 3.218, -140.939), 矢量(36.938, 4.010,
			-124.670), 矢量(19.895, 6, -130.757), 矢量(46.563, 4.010, -129.999), 矢量(33.077, 6.560, -109.304), 矢量(26.769, 4, -88.758), 矢量(
			16.181, 3.046, -67.936), 矢量(25.804, 3, -66.711), 矢量(28.072, 3.998, -105.300), 矢量(60.854, 1, -113.372), 矢量(44.855, 4.010,
			-131.473), 矢量(39.700, 1, -144.094), 矢量(44.122, 0.999, -138.877), 矢量(44.350, 4.010, -130.820), 矢量(33.194, 4, -91.737), 矢量(
			30.991, 3, -72.417), 矢量(39.055, -4.947, -75.702), 矢量(45.022, -5, -69.766), 矢量(47.561, 3, -66.329), 矢量(45.596, 5.501, -54.397),
			矢量(36.368, -2.134, -56.973), 矢量(45.662, 3, -36.151), 矢量(67.234, 9.399, -36.279), 矢量(43.556, 3, -69.757), 矢量(36.668, -2.134,
			-57.072), 矢量(53.683, 8.908, -36.387), 矢量(82.606, 3, -33.352), 矢量(86.119, 3.010, -29.821), 矢量(77.563, 6, 6.752), 矢量(94.505,
			6.058, 42.927), 矢量(91.745, 6, 9.719), 矢量(85.001, 6.183, 51.283), 矢量(81.151, 2.845, 28.890), 矢量(72.629, 1.010, 20.003), 矢量(
			77.622, 6.010, 6.080), 矢量(75.526, 10, 7.506), 矢量(69.811, 9.010, 12.958), 矢量(67.433, 9, 25.709), 矢量(98.874, 2.745, -16.184), 矢量(
			67.245, -2.905, -13.682), 矢量(64.361, -2.993, -16.969), 矢量(69.946, 13.739, -37.547), 矢量(53.419, 8.734, -38.662), 矢量(35.716,
			3.046, -47.739), 矢量(45.993, 3, -36.446), 矢量(57.496, 3, -54.121), 矢量(47.804, 3, -66.313), 矢量(31.689, -5.149, -56.307), 矢量(
			34.071, -1.429, -53.736), 矢量(39.803, -5.012, -50.229), 矢量(43.110, -0.510, -49.171), 矢量(65.056, -3.141, -26.305), 矢量(62.097,
			2.028, -22.853), 矢量(73.527, -3.139, -32.081), 矢量(74.748, 2.107, -34.640), 矢量(59.518, 3, -52.439), 矢量(55.779, 8.139, -48.965),
			矢量(48.108, 3.046, -65.826), 矢量(38.250, -5.021, -77.715), 矢量(14.081, 3.045, -70.069), 矢量(26.826, 0.009, -105.191), 矢量(31.781, 4,
			-103.478), 矢量(42.742, -6.137, -119.077), 矢量(36.246, 0, -112.562), 矢量(33.140, 6.561, -109.766), 矢量(39.015, 0, -100.452), 矢量(
			31.313, 6.225, -92.990), 矢量(15.589, -2, -132.552), 矢量(37.649, 4.010, -124.211), 矢量(61.452, -7.192, -141.705), 矢量(60.992, 1,
			-115.213), 矢量(27.284, 3.013, -84.642), 矢量(16.503, -5, -70.262), 矢量(29.458, 6.938, -90.962), 矢量(38.373, -5.020, -77.208), 矢量(
			56.069, 3, -52.942), 矢量(47.966, -5, -68.898), 矢量(34.972, 3, -47.797), 矢量(62.694, -3.003, -16.511), 矢量(83.645, 6, 1.309), 矢量(
			97.334, 1, 12.426), 矢量(87.994, 6, 12.362), 矢量(75.569, 9, 22.556), 矢量(59.696, 8.354, 20.334), 矢量(51.531, 9, 9.279), 矢量(41.032,
			3, 7.798), 矢量(49.293, 9, 6.813), 矢量(56.965, 9.010, 4.911));
		全局.SecondaryFireState = 数组(假, 假, 真, 真, 真, 真, 真, 真, 假, 真, 真, 真, 假, 假, 假, 真, 真, 真, 假, 真, 假, 假, 真, 真, 真, 假, 真, 真, 假, 真, 真, 真, 真, 真, 假,
			真, 假, 假, 假, 真, 真, 假, 真, 假, 假, 假, 真, 假, 假, 假, 假, 假, 真, 假, 假, 假, 真, 假, 假, 真, 真, 真, 假, 假, 假, 假, 假, 假, 真, 真, 真, 真, 真, 假, 真, 真, 真,
			假, 真, 真, 真, 假, 假, 假, 假, 假, 假, 假, 假);
		全局.UltimateState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 矢量(21.742, -1.910,
			-129.950), 假, 矢量(63.864, -6.380, -131.746), 矢量(36.918, 0.092, -95.332), 假, 矢量(23.858, -5.068, -82.402), 假, 矢量(44.188, -5.058,
			-60.366), 假, 矢量(41.762, -5.059, -62.347), 假, 矢量(74.739, -3.006, -9.533), 假, 假, 假, 假, 假, 假, 假, 假);
		全局.SpherePosition = 数组(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 矢量(60.568, 6.003, 5.043));
	}
}

规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里) 圣诞节国王大道 萌新+")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(圣诞节国王大道);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		全局.CheckpointPosition = 数组(矢量(4.237, 6.026, -44.016), 矢量(4.502, 6.026, -37.056), 矢量(5.726, 6.353, -28.385), 矢量(-2.527, 4.531,
			-26.504), 矢量(-12.399, 6.110, -16.238), 矢量(-16.805, 6, -1.426), 矢量(-2.556, 5.290, 2.544), 矢量(2.428, 6.026, -34.952), 矢量(-27.596,
			6, -45.219), 矢量(-38.781, 0.051, -23.568), 矢量(-68.053, 4.500, -34.892), 矢量(-66.979, 5.095, -15.071), 矢量(-60.089, 4.956,
			-17.790), 矢量(-40.059, -0.143, -25.548), 矢量(-6.085, 4.531, -26.035), 矢量(-1.980, 5.307, 0.262), 矢量(16.551, 6, 15.531), 矢量(-3.354,
			5.221, 1.763), 矢量(-26.298, 6, 8.348), 矢量(-10.307, 16.917, 5.690), 矢量(-13.796, 6.230, -14.142), 矢量(-5.570, 4.531, -25.011), 矢量(
			1.978, 6.026, -34.557), 矢量(-26.624, 6, -47.598), 矢量(-29.035, 9.163, -17.177), 矢量(-47.735, 9.123, -36.819), 矢量(-92.566, 7.489,
			-29.917), 矢量(-88.307, 6.930, -14.610), 矢量(-60.455, 3, -4.672), 矢量(-57.437, 5.135, -16.808), 矢量(-47.634, 9.123, -36.816), 矢量(
			-34.174, 9, -34.377), 矢量(4.658, 6.784, -12.387), 矢量(9.543, 6, -15.993), 矢量(-4.043, 13.996, 18.111), 矢量(-11.387, 1.818,
			-33.292), 矢量(-22.802, -0.124, -27.976), 矢量(-29.226, 9, -16.241), 矢量(-34.933, 9, -34.173), 矢量(-86.764, 6.933, -18.195), 矢量(
			-126.485, -1.225, -1.035), 矢量(-151.007, 0.071, 4.869), 矢量(-116.043, 6.100, 5.694), 矢量(-147.439, -2.929, 37.338), 矢量(-145.607,
			1.134, 35.482), 矢量(-138.716, -2.929, 40.436), 矢量(-136.718, 0.081, 46.247), 矢量(-142.550, -2.929, 36.612), 矢量(-146.885, 0.071,
			45.244), 矢量(-146.063, 1.082, 35.880), 矢量(-131.189, 1, -3.599), 矢量(-118.856, -1.289, -9.605), 矢量(-119.211, 3.036, -11.229), 矢量(
			-118.829, -1.289, -9.660), 矢量(-119.189, 1.071, -14.974), 矢量(-117.615, -1.206, -5.449), 矢量(-88.468, 6.933, -9.332), 矢量(-82.921,
			0.447, -23.622), 矢量(-92.890, 7.488, -29.678), 矢量(-83.588, 0.532, -42.141), 矢量(-79.979, 4.500, -42.643), 矢量(-61.598, 0.383,
			-16.875), 矢量(-59.029, 4.956, -17.105), 矢量(-65.711, -0.014, -33.875), 矢量(-67.796, 4.500, -35.171), 矢量(-26.195, -0.125, -25.134),
			矢量(-7.614, 6, -42.014), 矢量(-1.443, 0.036, -35.818), 矢量(1.732, 6.026, -37.071), 矢量(-2.397, 0.045, -27.844), 矢量(5.694, 6.265,
			-27.319), 矢量(-11.631, 6.110, -16.787), 矢量(3.303, 6.774, -9.587), 矢量(-6.009, 0.498, 3.735), 矢量(-3.104, 5.245, 1.295), 矢量(-3.608,
			-0.122, -4.687), 矢量(3.345, 6.774, -9.174), 矢量(6.091, 0.067, -21.093), 矢量(-3.396, 5.308, 3.484), 矢量(-5.043, -0.083, -1.364), 矢量(
			2.423, 6.026, -34.853), 矢量(3.409, -0.133, -26.510), 矢量(-26.102, 6, -43.060), 矢量(-24.942, -0.119, -29.676), 矢量(5.796, 6.110,
			-25.659), 矢量(-5.205, 0.070, -10.390), 矢量(-4.468, 5.095, 3.671), 矢量(-7.329, -0.091, 7.861), 矢量(-5.615, 8.944, -22.637));
		全局.SecondaryFireState = 数组(假, 假, 假, 真, 真, 真, 真, 真, 真, 真, 真, 假, 真, 真, 真, 真, 真, 真, 真, 假, 假, 假, 真, 真, 真, 真, 假, 真, 真, 真, 假, 真, 假, 真, 真,
			假, 真, 真, 真, 真, 真, 真, 真, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 真, 假, 真, 假, 假, 真, 假, 真, 假, 真, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			真, 假, 真, 假, 真, 假, 真, 假, 真, 假, 真);
		全局.UltimateState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 矢量(-105.944, 0.587, -8.516), 假, 矢量(-97.821, 1.809, -20.359), 假, 假,
			假, 假, 假, 假, 假, 矢量(-13.752, -0.034, -32.514), 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 矢量(-10.698, -0.032, -2.890), 假, 矢量(-1.719, 0.365,
			-19.399), 假, 矢量(-9.370, 0.203, -33.802), 假, 矢量(-14.304, -0.034, -32.921), 假, 矢量(0.970, -0.019, -11.442), 假, 矢量(-7.223, -0.031,
			-7.390));
		全局.Creator = 数组(自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(
			""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""),
			自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(
			""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""),
			自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(
			""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""),
			自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(
			""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""),
			自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""), 自定义字符串(""));
	}
}

规则("[自定义]导入数据(将查看器里面的全局数据导出为动作,粘贴到这里)  多拉多柠檬")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(多拉多);
		当前游戏模式 == 游戏模式(突击模式);
	}

	动作
	{
		全局.CheckpointPosition = 数组(矢量(155.403, 11, 40.794), 矢量(153.962, 14.012, 44.089), 矢量(177.326, 14.100, 36.377), 矢量(172.400, 19.100,
			45.458), 矢量(178.015, 14.024, 47.511), 矢量(171.724, 19, 45.782), 矢量(176.233, 11, 31.012), 矢量(179.198, 14.100, 35.881), 矢量(
			173.298, 11, 43.741), 矢量(176.613, 14.100, 43.992), 矢量(173.183, 19, 46.037), 矢量(175.278, 11.850, 60.780), 矢量(175.058, 17.979,
			63.071), 矢量(175.675, 11.850, 60.817), 矢量(172.413, 18.012, 54.757), 矢量(160.769, 11.850, 57.101), 矢量(164.118, 18.012, 60.286),
			矢量(168.558, 12.022, 52.870), 矢量(169.904, 18.012, 52.765), 矢量(157.309, 11.953, 55.624), 矢量(164.156, 18.012, 60.627), 矢量(135.658,
			11.012, 46.736), 矢量(131.389, 16.891, 44.314), 矢量(132.536, 11.012, 38.518), 矢量(129.053, 18.012, 39.626), 矢量(128.084, 11.050,
			36.089), 矢量(126.011, 18, 36.909), 矢量(127.955, 11.050, 19.430), 矢量(129.794, 17.750, 14.270), 矢量(137.323, 11.050, 22.484), 矢量(
			137.466, 17.750, 16.234), 矢量(115.191, 10.861, 23.336), 矢量(113.043, 18.156, 32.493), 矢量(109.501, 11.081, 24.246), 矢量(106.788,
			18.046, 17.028), 矢量(111, 11.081, 14.001), 矢量(108.641, 18.046, 13.722), 矢量(99.750, 11.038, 11.080), 矢量(98.402, 18.012, 13.764),
			矢量(99.703, 12.750, 35.444), 矢量(100.354, 20, 32.391), 矢量(106.182, 11.081, 28.827), 矢量(106.437, 20.178, 30.471), 矢量(126.800,
			9.641, 6.554), 矢量(128.429, 18.010, 7.197), 矢量(126.786, 9.768, 7.391), 矢量(123.025, 18.257, 6.387), 矢量(32.390, 1.021, 2.409), 矢量(
			34.923, 9, 2.696), 矢量(44.971, 2, 6.236), 矢量(49.954, 9, 4.891), 矢量(59.408, 9.120, 13.669), 矢量(40.626, 10.696, 21.489), 矢量(
			45.521, 2, 14.799), 矢量(40.726, 10.687, 21.484), 矢量(63.467, 9.120, 5.911), 矢量(65.467, 16.442, 4.499), 矢量(67.080, 7.500, 3.200),
			矢量(64.710, 16.452, 4.389), 矢量(81.404, 17.484, -4.522), 矢量(96.927, 11, 0.704), 矢量(103.267, 18.335, -4.011), 矢量(87.297, 11,
			13.717), 矢量(85.850, 20, 15.498), 矢量(100.479, 12.750, 34.133), 矢量(102.382, 21.124, 34.466), 矢量(173.108, 11, 44.270), 矢量(172.864,
			19.100, 45.648), 矢量(105.641, 11.081, 21.270), 矢量(102.214, 20.609, 27.920), 矢量(30.995, 1.021, 13.914), 矢量(34.853, 9, 3.803), 矢量(
			30.332, 1.021, 13.938), 矢量(31.381, 10.674, 20.310), 矢量(17.359, 0.998, 8.619), 矢量(19.992, 9.865, 1.369), 矢量(17.557, 0.806,
			8.429), 矢量(18.140, 10, 12.695), 矢量(108.744, 19.950, 32.243), 矢量(-5.573, 8.012, 2.283), 矢量(179.730, 14.100, 35.088), 矢量(155.651,
			11, 39.189), 矢量(140.229, 17.750, 12.939), 矢量(129.170, 9.016, -24.132), 矢量(39.945, 9, -8.078), 矢量(40.009, 9.079, -32.152), 矢量(
			-43.091, 11.322, -52.328), 矢量(-44.400, 21.517, -53.373));
		全局.SecondaryFireState = 数组(假, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假,
			假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			假, 真, 假, 假, 假, 假, 假, 假, 假, 假);
		全局.Creator = 数组(自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"),
			自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"),
			自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"),
			自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"),
			自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"),
			自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"),
			自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"),
			自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"),
			自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("柠檬"), 自定义字符串("Exit"),
			自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"), 自定义字符串("Exit"));
		全局.JumpState = 数组(假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假,
			真, 假, 假, 假, 假, 假, 假, 假, 真, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 假, 真, 假, 真, 假, 真, 假, 假, 假, 假, 假, 假, 假, 真, 假, 真,
			假, 真, 假, 真, 假, 真, 假);
		全局.SpherePosition = 数组(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 矢量(41.883, 15.531, 5.894), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
		全局.actions = 数组(0, 数组(数组(1, 0, 0, 0, 0, 0, 0, 0.300, 0), 数组(1, 0, 1, 0, 0, 0, 0, 0.250, 0), 数组(0, 0, 2, 0, 0, 0, 0, 0, 0)), 0, 数组(
			数组(1, 0, 0, 0, 0, 0, 0, 0.250, 0), 数组(1, 0, 1, 0, 0, 0, 0, 0.150, 0), 数组(1, 0, 2, 0, 0, 3, 矢量(-0.225, -0.580, 0.783), 0.700,
			0), 数组(0, 0, 0, 0, 1, 0, 0, 0.100, 0), 数组(0, 0, 0, 0, 2, 0, 0, 0, 0)), 0, 数组(数组(1, 0, 0, 0, 0, 0, 0, 0.320, 0), 数组(1, 0, 1, 0,
			0, 0, 0, 0.250, 0), 数组(1, 0, 2, 0, 0, 2, 矢量(-0.624, -0.453, 0.637), 0.350, 0), 数组(0, 0, 0, 0, 1, 0, 0, 0.100, 0), 数组(0, 0, 0,
			0, 2, 0, 0, 0, 0)), 0, 数组(数组(1, 0, 0, 0, 0, 0, 0, 0.280, 0), 数组(0, 0, 1, 0, 0, 0, 0, 0.050, 0), 数组(0, 0, 2, 0, 0, 5.000, 矢量(
			0.465, -0.342, 0.817), 0.350, 0), 数组(0, 0, 0, 0, 1, 0, 0, 0.100, 0), 数组(0, 0, 0, 0, 2, 0, 0, 0, 0)), 0, 数组(数组(1, 0, 0, 0, 0, 0,
			0, 0.300, 0), 数组(1, 0, 1, 0, 0, 0, 0, 0.050, 0), 数组(2, 1, 2, 0, 0, 1, 矢量(0.490, -0.865, -0.109), 0.500, 0), 数组(0, 0, 0, 0, 1,
			0, 0, 0.100, 0), 数组(0, 0, 0, 0, 2, 0, 0, 0, 0)), 0, 0, 数组(数组(1, 0, 0, 0, 0, 0, 0, 0.320, 0), 数组(0, 0, 1, 0, 0, 0, 0, 0.160, 0),
			数组(2, 0, 2, 0, 0, 0, 0, 0.450, 0), 数组(0, 0, 0, 0, 1, 0, 0, 0.100, 0), 数组(0, 0, 0, 0, 2, 0, 0, 0, 0)), 0, 数组(数组(1, 0, 0, 0, 0,
			0, 0, 0.340, 0), 数组(0, 0, 1, 0, 0, 0, 0, 0.100, 0), 数组(2, 2, 2, 0, 0, 3.500, 矢量(-0.386, -0.156, -0.909), 0.300, 0), 数组(0, 2, 0,
			0, 0, 0, 0, 0.300, 0), 数组(0, 0, 0, 0, 1, 0, 0, 0.050, 0), 数组(0, 0, 0, 0, 2, 0, 0, 0, 0)), 0, 0, 0, 数组(数组(1, 0, 0, 0, 0, 0, 0,
			0.400, 0), 数组(0, 0, 1, 0, 0, 0, 0, 0.150, 0), 数组(0, 1, 2, 0, 0, 3, 矢量(0.922, -0.268, 0.279), 0.100, 0), 数组(0, 0, 0, 0, 0, 0, 0,
			0.250, 0), 数组(0, 0, 0, 0, 1, 0, 0, 0.100, 0), 数组(0, 0, 0, 0, 2, 0, 0, 0, 0)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 数组(数组(1, 0, 0, 0, 0, 0, 0, 0.320, 0), 数组(0, 2, 1, 0, 0, 0, 0, 0.300, 0), 数组(2, 1, 2, 0, 0, 0, 0, 0.350,
			0), 数组(0, 0, 0, 0, 0, 0, 0, 0.200, 0), 数组(0, 0, 0, 0, 1, 0, 0, 0.100, 0), 数组(0, 0, 0, 0, 2, 0, 0, 0, 0)), 0, 0, 0, 0, 0, 0, 数组(
			数组(1, 0, 0, 0, 0, 0, 0, 0.320, 0), 数组(0, 1, 1, 0, 0, 0, 0, 0.780, 0), 数组(0, 0, 2, 0, 1, 0, 0, 0.100, 0), 数组(0, 0, 0, 0, 2, 0,
			0, 0, 0), 数组(0, 0, 0, 0, 2, 0, 0, 0, 0)), 0, 0, 数组(数组(1, 0, 0, 0, 0, 0, 0, 0.290, 0), 数组(0, 0, 1, 0, 0, 0, 0, 0.200, 0), 数组(0,
			2, 2, 0, 0, 0, 0, 0.500, 0), 数组(0, 2, 0, 0, 0, 2.500, 矢量(-0.947, -0.117, 0.298), 0.200, 0), 数组(1, 0, 0, 0, 0, 0, 0, 1.500, 0),
			数组(0, 0, 0, 0, 1, 0, 0, 0.100, 0), 数组(0, 0, 0, 0, 2, 0, 0, 0, 0)));
		全局.bot_start_position = 数组(0, 矢量(155.675, 11, 40.563), 0, 矢量(178.092, 14.100, 37.003), 0, 矢量(178.932, 13.852, 47.197), 0, 矢量(
			176.004, 11, 32.761), 0, 矢量(172.553, 11, 42.988), 0, 0, 矢量(175.666, 11.850, 60.694), 0, 矢量(176.872, 11.850, 60.699), 0, 0, 0,
			矢量(169.070, 11.850, 54.111), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 矢量(107.262, 11.081, 28.303),
			0, 0, 0, 0, 0, 0, 矢量(34.867, 9, 2.172), 0, 0, 矢量(58.977, 9.120, 12.053));
		全局.bot_start_direction = 数组(0, 矢量(-0.253, -0.688, 0.680), 0, 矢量(-0.322, -0.941, -0.103), 0, 矢量(-0.411, -0.894, -0.179), 0, 矢量(
			0.176, -0.913, -0.368), 0, 矢量(0.653, -0.757, 0.014), 0, 0, 矢量(-0.123, -0.912, 0.392), 0, 矢量(-0.411, -0.466, 0.783), 0, 0, 0,
			矢量(0.072, -0.428, -0.901), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 矢量(-0.327, -0.547, 0.771), 0,
			0, 0, 0, 0, 0, 矢量(0.129, -0.854, 0.505), 0, 0, 矢量(0.531, -0.508, 0.679));
	}
}


规则("Debug")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.BotEnabled == 真;
	    全局.ActionEditModeEnabled == 真;
	}

	动作
	{
        全局.action_type[1] = 自定义字符串("是否W/S");
		全局.action_type[2] = 自定义字符串("是否A/D");
		全局.action_type[3] = 自定义字符串("是否跳跃");
		全局.action_type[4] = 自定义字符串("是否辅助攻击模式");
		全局.action_type[5] = 自定义字符串("是否下蹲");
		全局.action_type[6] = 自定义字符串("转视角速度");
		全局.action_type[7] = 自定义字符串("转视角最终方向");
		全局.action_type[8] = 自定义字符串("持续时间");


		创建HUD文本(已过滤的数组(主机玩家, 按钮被按下(当前数组元素, 按钮(互动))), 自定义字符串("机器人速度"), 速度(主机玩家.Bot), 无, 顶部, 50, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(主机玩家, 按钮被按下(当前数组元素, 按钮(互动))), 自定义字符串("玩家速度"), 速度(主机玩家), 无, 顶部, 50, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(主机玩家, 按钮被按下(当前数组元素, 按钮(互动))), 自定义字符串("机器人阈值"), 阈值(主机玩家.Bot), 无, 顶部, 50, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(主机玩家, 按钮被按下(当前数组元素, 按钮(互动))), 自定义字符串("玩家阈值"), 阈值(主机玩家), 无, 顶部, 50, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(主机玩家, 按钮被按下(当前数组元素, 按钮(互动))), 自定义字符串("机器人朝向"), 面朝方向(主机玩家.Bot), 无, 顶部, 50, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(主机玩家, 按钮被按下(当前数组元素, 按钮(互动))), 自定义字符串("玩家朝向"), 面朝方向(主机玩家), 无, 顶部, 50, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(主机玩家, 按钮被按下(当前数组元素, 按钮(互动))), 自定义字符串("机器人位置"), 所选位置(主机玩家.Bot), 无, 顶部, 50, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(主机玩家, 按钮被按下(当前数组元素, 按钮(互动))), 自定义字符串("玩家位置"), 所选位置(主机玩家), 无, 顶部, 50, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(主机玩家, 按钮被按下(当前数组元素, 按钮(互动))), 自定义字符串("bot_start_direction"), 主机玩家.bot_start_direction, 无, 顶部, 50, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(主机玩家, 按钮被按下(当前数组元素, 按钮(互动))), 自定义字符串("bot_position"), 主机玩家.bot_direction, 无, 顶部, 50, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(主机玩家, 自定义字符串("f+R切换编辑模式\nQ/E切换动作\nshift/ctrl切换子动作\n左右键调整数值\n喷漆保存位置\nf+空格删除最后动作"), 无, 无, 左边, 12, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
	}
}

规则("显示动作")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.BotEnabled == 真;
		全局.ActionEditModeEnabled == 真;
		已重生(事件玩家) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串("{0}动作序号", 事件玩家.edit_mode?自定义字符串("[编辑中]"):自定义字符串("")), 自定义字符串("{0}/{1}", 事件玩家.action_idx + 1, 数量(事件玩家.actions)), 无, 右边, 2, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		For 玩家变量(事件玩家, action_type, 0, 数量(全局.action_type) - 1, 1);
			创建HUD文本(事件玩家, 单次赋值(全局.action_type[单次赋值(事件玩家.action_type) + 1]), 数量(全局.action_value[单次赋值(事件玩家.action_type)]) > 1?全局.action_value[单次赋值(事件玩家.action_type)][事件玩家.current_action[单次赋值(事件玩家.action_type)]]:事件玩家.current_action[单次赋值(事件玩家.action_type)], 事件玩家.action_s_idx == 单次赋值(事件玩家.action_type)?自定义字符串("<-"):自定义字符串(""), 右边, 单次赋值(事件玩家.action_type + 3), 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		End;
	}
}


规则("Create Clones Team 1")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.BotEnabled == 真;
		全局.actions != 无;
	}

	动作
	{
		全局.action_value[0] = 数组(0, 1, -1);
		全局.action_value[1] = 数组(0, 1, -1);
		全局.action_value[2] = 数组(0, 1, -1);
		全局.action_value[3] = 数组(0, 1, -1);
		全局.action_value[4] = 数组(0, 1, -1);
		全局.action_value[5] = 自定义字符串("数值");
		全局.action_value[6] = 自定义字符串("方向");
		全局.action_value[7] = 自定义字符串("数值");

		全局.bot_name = 数组(自定义字符串("8号实验体"), 自定义字符串("孤独的铁球"), 自定义字符串("渣客镇王者"), 自定义字符串("角斗冠军"), 自定义字符串("社会大佬"));
		全局.bot_action = 数组(自定义字符串("晒太阳"), 自定义字符串("对旅店老板重拳出击"), 自定义字符串("吃香蕉"), 自定义字符串("开着作弊器与黑影PK"),
			自定义字符串("安娜面前呼呼大睡"), 自定义字符串("拯救艾泽拉斯"), 自定义字符串("和堡垒学说话"), 自定义字符串("喝纳米可乐"), 
			自定义字符串("4400炸鱼"), 自定义字符串("试驾DVA的机甲"), 自定义字符串("挖狂鼠埋的宝藏"), 自定义字符串("酒馆5连鸡"),
			自定义字符串("潘达利亚玩泥巴"), 自定义字符串("偷温斯顿的香蕉"), 自定义字符串("偷温斯顿的香蕉"), 自定义字符串("探索地下城"));
		调用子程序(CreateBot);
    }
}

规则("CreateBot")
{
	事件
	{
		子程序;
		CreateBot;
	}

	动作
	{
		For 全局变量(bot_idx, 0, 全局.bot_num, 1);
			生成机器人(英雄(破坏球), 队伍2, 全局.bot_idx + 1, 全局.bot_position, 全局.bot_direction);
			全局.Bot[全局.bot_idx] = 此栏位的玩家(全局.bot_idx + 1, 队伍2);
			开始为机器人强制设置名称(全局.Bot[全局.bot_idx], 全局.bot_name[全局.bot_idx]);
		End;
    }
}

规则("机器人初始化")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		全局.BotEnabled == 真;
		全局.actions != 无;
		已重生(事件玩家) == 真;
		是否是机器人(事件玩家) == 真;
	}

	动作
	{
		事件玩家.keyboard_enabled = 真;
		事件玩家.owner = 无;
		事件玩家.Level = 0;
		事件玩家.FreeMode = 真;
		事件玩家.action_time = 0;
		事件玩家.bot_action = 数组随机取值(全局.bot_action);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 事件玩家.owner == 无?自定义字符串("{0} 正在{1}", 事件玩家, 事件玩家.bot_action):自定义字符串("{0} 正在教 {1}({2}s)", 事件玩家, 事件玩家.owner, 全局.bot_max_action_time - 事件玩家.action_time), 右边, 栏位(事件玩家) - 50, 颜色(白色), 颜色(白色), 颜色(橙色), 可见性，排序规则和字符串, 默认可见度);
	}
}

规则("房主重置所有机器人")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.BotEnabled == 真;
		全局.actions != 无;
		正在交流(主机玩家, 终极技能状态) == 真;
		按钮被按下(主机玩家, 按钮(互动)) == 真;
	}

	动作
	{
		If(!实体存在(全局.Bot[0]));
			调用子程序(CreateBot);
		End;
		For 全局变量(bot_idx, 0, 全局.bot_num, 1);
			全局.Bot[全局.bot_idx].Level = 0;
			停止追踪玩家变量(全局.Bot[全局.bot_idx], action_time);
			全局.Bot[全局.bot_idx].action_time = 0;
			全局.Bot[全局.bot_idx].bot_action = 数组随机取值(全局.bot_action);
			全局.Bot[全局.bot_idx].owner = 无;
		End;
	}
}

规则("按F+R进入编辑模式")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.BotEnabled == 真;
		全局.actions != 无;
		全局.ActionEditModeEnabled == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		事件玩家 == 主机玩家;
        事件玩家.bot_state != 2;
		事件玩家.IsSpectating == 假;
		事件玩家.Level + 1 < 数量(全局.CheckpointPosition);
	}

	动作
	{
		If(事件玩家.edit_mode == 0);
			事件玩家.bot_state = 0;
			设置状态(事件玩家, 无, 定身, 9999);
			事件玩家.bot_position = 全局.bot_start_position[事件玩家.Level + 1];
			事件玩家.bot_start_direction = 全局.bot_start_direction[事件玩家.Level + 1];
			If(事件玩家.bot_position == 无);
				事件玩家.bot_position = 所选位置(事件玩家);
			End;
			If(事件玩家.bot_start_direction == 无);
				事件玩家.bot_start_direction = 面朝方向(事件玩家);
			End;
			事件玩家.actions = 全局.actions[事件玩家.Level + 1];
			事件玩家.action_idx = 0;
			If(数量(事件玩家.actions) == 0);
				事件玩家.actions[事件玩家.action_idx] = 数组(0, 0, 0, 0, 0, 0, 0, 无, 0);
			End;
			事件玩家.current_action = 事件玩家.actions[事件玩家.action_idx];
			事件玩家.action_s_idx = 0;
			事件玩家.edit_mode = 1;
		Else;
			事件玩家.actions[事件玩家.action_idx] = 事件玩家.current_action;
			全局.bot_start_position[事件玩家.Level + 1] = 事件玩家.bot_position;
			全局.bot_start_direction[事件玩家.Level + 1] = 事件玩家.bot_start_direction;
			全局.actions[事件玩家.Level + 1] = 事件玩家.actions;
			事件玩家.edit_mode = 0;
			事件玩家.bot_state = 1;
			清除状态(事件玩家, 定身);
		End;
	}
}

规则("按shift/ctrl选择子动作")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.BotEnabled == 真;
		事件玩家.edit_mode == 1;
		(按钮被按下(事件玩家, 按钮(蹲下)) || 按钮被按下(事件玩家, 按钮(技能1))) == 真;
	}

	动作
	{
		If(按钮被按下(事件玩家, 按钮(技能1)));
			事件玩家.action_s_idx -= 1;
			If(事件玩家.action_s_idx < 0);
				事件玩家.action_s_idx = 数量(全局.action_type) - 2;
			End;
		Else;
			事件玩家.action_s_idx += 1;
			If(事件玩家.action_s_idx >= 数量(全局.action_type) - 1);
				事件玩家.action_s_idx = 0;
			End;
		End;
	}
}

规则("左/右键调整参数")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.BotEnabled == 真;
		事件玩家.edit_mode == 1;
		(按钮被按下(事件玩家, 按钮(主要攻击模式)) || 按钮被按下(事件玩家, 按钮(辅助攻击模式))) == 真;
	}

	动作
	{
		If(全局.action_value[事件玩家.action_s_idx] == 自定义字符串("数值"));
			If(按钮被按下(事件玩家, 按钮(辅助攻击模式)));
				事件玩家.current_action[事件玩家.action_s_idx] += 0.01;
				等待(0.016, 无视条件);
				等待(0.500, 当为“假”时中止);
				While(按钮被按下(事件玩家, 按钮(辅助攻击模式)));
					事件玩家.current_action[事件玩家.action_s_idx] += 0.01;
					等待(0.016, 无视条件);
					等待(0.030, 当为“假”时中止);
				End;
			Else If(按钮被按下(事件玩家, 按钮(主要攻击模式)) && 事件玩家.current_action[事件玩家.action_s_idx] > 0);
				事件玩家.current_action[事件玩家.action_s_idx] -= 0.01;
				等待(0.016, 无视条件);
				等待(0.500, 当为“假”时中止);
				While(按钮被按下(事件玩家, 按钮(主要攻击模式)) && 事件玩家.current_action[事件玩家.action_s_idx] > 0);
					事件玩家.current_action[事件玩家.action_s_idx] -= 0.01;
					等待(0.016, 无视条件);
					等待(0.030, 当为“假”时中止);
				End;
			End;
		Else If(全局.action_value[事件玩家.action_s_idx] == 自定义字符串("方向"));
			If(按钮被按下(事件玩家, 按钮(主要攻击模式)));
				事件玩家.current_action[事件玩家.action_s_idx] = 面朝方向(事件玩家);
			Else;
				事件玩家.current_action[事件玩家.action_s_idx] = 无;
			End;
		Else;
			事件玩家.current_action[事件玩家.action_s_idx] += 1;
			If(事件玩家.current_action[事件玩家.action_s_idx] >= 数量(全局.action_value[事件玩家.action_s_idx]));
				事件玩家.current_action[事件玩家.action_s_idx] = 0;
			End;
		End;
	}
}


规则("喷漆保存位置和方向")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.BotEnabled == 真;
		正在使用喷漆交流(事件玩家) == 真;
		事件玩家.edit_mode == 1;
	}

	动作
	{
		事件玩家.bot_position = 所选位置(事件玩家);
		事件玩家.bot_start_direction = 面朝方向(事件玩家);
	}
}

规则("按E下一个动作")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.BotEnabled == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		事件玩家.edit_mode == 1;
	}

	动作
	{
		事件玩家.actions[事件玩家.action_idx] = 事件玩家.current_action;
		事件玩家.action_idx += 1;
		If(事件玩家.action_idx >= 数量(事件玩家.actions));
			事件玩家.actions[事件玩家.action_idx] = 数组(0, 0, 0, 0, 0, 0, 0, 无, 0);
		End;
		事件玩家.action_s_idx = 0;
		事件玩家.current_action = 事件玩家.actions[事件玩家.action_idx];
	}
}

规则("按Q上一个动作")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.BotEnabled == 真;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		事件玩家.edit_mode == 1;
	}

	动作
	{
		事件玩家.actions[事件玩家.action_idx] = 事件玩家.current_action;
		If(事件玩家.action_idx > 0);
			事件玩家.action_idx -= 1;
			事件玩家.action_s_idx = 0;
			事件玩家.current_action = 事件玩家.actions[事件玩家.action_idx];
		End;
	}
}

规则("按f+空格删除动作")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.BotEnabled == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		事件玩家.edit_mode == 1;
		事件玩家.action_idx == 数量(事件玩家.actions) - 1;
		事件玩家.action_idx >= 0;
	}

	动作
	{
		修改玩家变量(事件玩家, actions, 根据索引从数组中移除, 事件玩家.action_idx);
		事件玩家.action_idx -= 1;
		事件玩家.current_action = 事件玩家.actions[事件玩家.action_idx];
		小字体信息(事件玩家, 自定义字符串("动作已删除"));
	}
}

规则("按X召唤机器人")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.BotEnabled == 真;
		全局.actions != 无;
		(正在交流(事件玩家, 需要帮助) || 正在交流(事件玩家, 需要治疗)) == 真;
		事件玩家.FreeMode == 假;
		事件玩家.GameComplete == 假;
		事件玩家.edit_mode == 0;
	}

	动作
	{
		If(事件玩家.Bot != 无);
			小字体信息(数组(事件玩家, 事件玩家.Bot), 自定义字符串("{0}{1}", 事件玩家.Bot, 全局.SmallHint[29]));
		Else If(全局.actions[事件玩家.Level + 1] == 无);
			小字体信息(数组(事件玩家, 已过滤的数组(全局.Bot, 当前数组元素.owner == 无)), 全局.SmallHint[26]);
		Else;
			事件玩家.Bot = 数组随机取值(已过滤的数组(全局.Bot, 当前数组元素.owner == 无));
			If(事件玩家.Bot == 无);
				小字体信息(事件玩家, 全局.SmallHint[27]);
			Else;
				小字体信息(数组(事件玩家, 事件玩家.Bot), 自定义字符串("{0}{1}", 事件玩家.Bot, 全局.SmallHint[28]));
				事件玩家.Bot.action_time = 0;
				事件玩家.Bot.owner = 事件玩家;
				交流(事件玩家.Bot, 正在赶来);
				
				事件玩家.bot_position = 全局.bot_start_position[事件玩家.Level + 1];
				事件玩家.bot_start_direction = 全局.bot_start_direction[事件玩家.Level + 1];
				事件玩家.actions = 全局.actions[事件玩家.Level + 1];
				事件玩家.bot_tips = 全局.bot_tips[事件玩家.Level + 1];
				事件玩家.Bot.Level = 事件玩家.Level;
				事件玩家.Bot.sphere_state = 全局.SpherePosition[事件玩家.Level + 1] ? 假 : 真;

				调用子程序(ResetBot);
				事件玩家.bot_state = 0;
				If(事件玩家.Bot != 无);
					小字体信息(数组(事件玩家, 事件玩家.Bot), 自定义字符串("{0}{1}", 事件玩家.Bot, 全局.SmallHint[29]));
				End;	
				等待(0.5, 无视条件);
				事件玩家.bot_state = 1;
				追踪玩家变量频率(单次赋值(事件玩家.Bot), action_time, 全局.bot_max_action_time, 1, 速率及最终值);
			End;
		End;
	}
}

规则("ReleaseBot")
{
	事件
	{
		子程序;
		ReleaseBot;
	}

	动作
	{
		等待直到(事件玩家.bot_state == 1, 10);
		If(事件玩家.edit_mode == 0);
			事件玩家.action_idx = 0;
			事件玩家.bot_position = 无;
			事件玩家.actions = 无;
			事件玩家.bot_start_direction = 无;
		End;
        事件玩家.bot_state = 0;
		事件玩家.bot_position = 无;
		事件玩家.Bot.Level = 0;
		停止追踪玩家变量(事件玩家.Bot, action_time);
		事件玩家.Bot.action_time = 0;
		事件玩家.Bot.bot_action = 数组随机取值(全局.bot_action);
		事件玩家.Bot.owner = 无;
		事件玩家.Bot = 无;
	}
}

规则("ReleaseBot2")
{
	事件
	{
		子程序;
		ReleaseBot2;
	}

	动作
	{
		If(事件玩家.owner != 无);
			If(事件玩家.owner.edit_mode == 0);
				事件玩家.owner.action_idx = 0;
				事件玩家.owner.bot_position = 无;
				事件玩家.owner.bot_start_direction = 无;
				事件玩家.owner.actions = 无;
			End;
			事件玩家.owner.bot_state = 0;
			事件玩家.owner.bot_tips = 无;
			事件玩家.owner.Bot = 无;
		End;
		事件玩家.Level = 0;
		停止追踪玩家变量(事件玩家, action_time);
		事件玩家.action_time = 0;
		事件玩家.bot_action = 数组随机取值(全局.bot_action);
		事件玩家.owner = 无;
	}
}

规则("bot计时")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		全局.BotEnabled == 真;
		是否是机器人(事件玩家) == 真;
		(事件玩家.action_time >= 全局.bot_max_action_time || 事件玩家.owner.Bot != 事件玩家) == 真;
	}

	动作
	{
		交流(事件玩家, 再见);
		小字体信息(数组(事件玩家.owner, 事件玩家), 全局.SmallHint[31]);
		调用子程序(ReleaseBot2);
	}
}

规则("ReleaseBot")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		全局.BotEnabled == 真;
		事件玩家.owner == 无;
		是否是机器人(事件玩家) == 真;
		相距距离(全局.bot_position, 所选位置(事件玩家)) > 1;
	}

	动作
	{
		停止按下按钮(事件玩家, 按钮(蹲下));
		事件玩家.keyboard_status_ctrl = 假;
		停止按下按钮(事件玩家, 按钮(跳跃));
		事件玩家.keyboard_status_space = 假;
		停止按下按钮(事件玩家, 按钮(辅助攻击模式));
		事件玩家.keyboard_status_right = 假;
		设置状态(事件玩家, 无, 定身, 0.050);
		施加推力(事件玩家, 速率(事件玩家) * 1, -1, 至地图, 取消相反运动);
		停止定向阈值(事件玩家);
		设置状态(事件玩家, 无, 定身, 1);
		等待(0.50, 无视条件);
		传送(事件玩家, 全局.bot_position);
		开始朝向(事件玩家, 全局.bot_direction, 300, 至地图, 方向及角速率);
		等待(1, 无视条件);
		小字体信息(所有玩家(所有队伍), 自定义字符串("{0}{1}", 事件玩家, 全局.SmallHint[30]));
	}
}

规则("发感谢释放机器人")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.BotEnabled == 真;
		事件玩家.Bot != 无;
		正在交流(事件玩家, 感谢) == 真;
	}

	动作
	{
		交流(事件玩家.Bot, 不用谢);
		调用子程序(ReleaseBot);
	}
}

规则("ResetBot")
{
	事件
	{
		子程序;
		ResetBot;
	}

	动作
	{
        事件玩家.bot_state = 0;
		// 事件玩家.bot_position = 全局.actions[事件玩家.Level + 1][0];
		// 事件玩家.bot_start_direction = 全局.actions[事件玩家.Level + 1][1];
		// 事件玩家.actions = 全局.actions[事件玩家.Level + 1][2];
		事件玩家.action_idx = 0;
		停止按下按钮(事件玩家.Bot, 按钮(蹲下));
		事件玩家.Bot.keyboard_status_ctrl = 假;
		停止按下按钮(事件玩家.Bot, 按钮(跳跃));
		事件玩家.Bot.keyboard_status_space = 假;
		停止按下按钮(事件玩家.Bot, 按钮(辅助攻击模式));
		事件玩家.Bot.keyboard_status_right = 假;
		设置状态(事件玩家.Bot, 无, 定身, 0.050);
		施加推力(事件玩家.Bot, 速率(事件玩家.Bot) * 1, -1, 至地图, 取消相反运动);
		停止定向阈值(事件玩家.Bot);
		设置状态(事件玩家.Bot, 无, 定身, 1);
		事件玩家.bot_direction = 事件玩家.bot_start_direction;
		开始朝向(事件玩家.Bot, 事件玩家.bot_direction, 500, 至地图, 方向及角速率);
		等待(0.25, 无视条件);
		传送(事件玩家.Bot, 事件玩家.bot_position);
		停止定向阈值(事件玩家.Bot);
		设置状态(事件玩家.Bot, 无, 定身, 1);
		等待(0.25, 无视条件);
		传送(事件玩家.Bot, 事件玩家.bot_position);
		等待(1, 无视条件);
		事件玩家.bot_state = 1;
	}
}

规则("按Q重置tp")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.BotEnabled == 真;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		事件玩家.Bot != 无;
		事件玩家.bot_state == 1;
		事件玩家.edit_mode == 0;
	}

	动作
	{
		调用子程序(ResetBot);
	}
}

规则("按R定向阈值")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.BotEnabled == 真;
		事件玩家.Bot != 无;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		事件玩家.bot_position == 真;
		事件玩家.bot_state == 1;
		事件玩家.edit_mode == 0;
	}

	动作
	{
		事件玩家.bot_state = 2;
		For 玩家变量(事件玩家, action_idx, 0, 数量(事件玩家.actions), 1);
			If(事件玩家.bot_tips != 无 && 事件玩家.bot_tips[0] == 事件玩家.action_idx);
				小字体信息(数组(事件玩家.Bot, 事件玩家), 事件玩家.bot_tips[1]);
			End;
			事件玩家.current_action = 事件玩家.actions[事件玩家.action_idx];
			If(全局.action_value[0][事件玩家.current_action[0]] != 0 || 全局.action_value[1][事件玩家.current_action[1]] != 0);
				开始定向阈值(事件玩家.Bot, 矢量(单次赋值(全局.action_value[1][事件玩家.current_action[1]]), 0, 单次赋值(全局.action_value[0][事件玩家.current_action[0]])), 1, 至玩家, 添加至现有阈值, 方向和幅度);
			Else;
				停止定向阈值(事件玩家.Bot);
			End;
			If(全局.action_value[2][事件玩家.current_action[2]] == 1);
				开始按下按钮(事件玩家.Bot, 按钮(跳跃));
				事件玩家.Bot.keyboard_status_space = 真;
			Else If(全局.action_value[2][事件玩家.current_action[2]] == -1);
				停止按下按钮(事件玩家.Bot, 按钮(跳跃));
				事件玩家.Bot.keyboard_status_space = 假;
			End;
			If(全局.action_value[3][事件玩家.current_action[3]] == 1);
				开始按下按钮(事件玩家.Bot, 按钮(辅助攻击模式));
				事件玩家.Bot.keyboard_status_right = 真;
			Else If(全局.action_value[3][事件玩家.current_action[3]] == -1);
				停止按下按钮(事件玩家.Bot, 按钮(辅助攻击模式));
				事件玩家.Bot.keyboard_status_right = 假;
			End;
			If(全局.action_value[4][事件玩家.current_action[4]] == 1);
				开始按下按钮(事件玩家.Bot, 按钮(蹲下));
				事件玩家.Bot.keyboard_status_ctrl = 真;
			Else If(全局.action_value[4][事件玩家.current_action[4]] == -1);
				停止按下按钮(事件玩家.Bot, 按钮(蹲下));
				事件玩家.Bot.keyboard_status_ctrl = 假;
			End;
			If(事件玩家.current_action[6] != 无 && 事件玩家.current_action[5] > 0);
				开始朝向(事件玩家.Bot, 单次赋值(事件玩家.current_action[6]), 单次赋值(事件玩家.current_action[5] * 100), 至地图, 方向及角速率);
			End;
			等待(事件玩家.current_action[7], 无视条件);
		End;
		等待(1, 无视条件);
		调用子程序(ResetBot);
	}
}

//自定义文本
规则("[自定义]地图文本")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.MapHint[0] = 自定义字符串("快到碗里来");
        全局.MapHint[1] = 自定义字符串("在这里起飞");
        全局.MapHint[2] = 自定义字符串("先来拿糖果");
	}
}

规则("[自定义]快捷键提示文本")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.ShortKeyHint[0] = 自定义字符串("重新开始 = F + Q");
        全局.ShortKeyHint[1] = 自定义字符串("阵亡观战 = F + E (按空格切换视角)");
        全局.ShortKeyHint[2] = 自定义字符串("开关隐身 = 任意表情");
        全局.ShortKeyHint[3] = 自定义字符串("自由移动 = F + V");
        全局.ShortKeyHint[4] = 自定义字符串("到上一关 = F + Ctrl");
        全局.ShortKeyHint[5] = 自定义字符串("到下一关 = Ctrl + Q + R");
        全局.ShortKeyHint[6] = 自定义字符串("阵亡复位 = 长按Q");
        全局.ShortKeyHint[7] = 自定义字符串("开关键盘 = Q + E");
        全局.ShortKeyHint[8] = 自定义字符串("切换模式 = R + Space");
        全局.ShortKeyHint[9] = 自定义字符串("快速选关 = 长按 V");
        全局.ShortKeyHint[10] = 自定义字符串("开关环境碰撞 = R");
        全局.ShortKeyHint[11] = 自定义字符串("删除最后一关 = 长按 R + E");
		全局.ShortKeyHint[12] = 自定义字符串("鼠标左/右键选择\n语音(上)更换英雄");
	}
}

规则("[自定义]隐藏说明文本")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.HiddenHint[0] = 自定义字符串("仓鼠跑酷地图合集代码：\nG7V27 | 13GT0R | 9ZDS3 | GYZFZ");
        全局.HiddenHint[1] = 自定义字符串("教学图代码：Z4DBC");
        全局.HiddenHint[2] = 自定义字符串("超级跳:钩住一个可以让自身加速的位置,在到达紫圈前松钩并保证速度已达最大(火焰效果),在紫色圈内瞬间起跳。\r\n原理:起跳正确的情况下高速撞击大角度斜面会获得上升动力。\r\nTIPS:紫圈圆心即为最佳起跳位\nNotice:到达紫圈前不可离地!起飞时必须松钩!");
        全局.HiddenHint[3] = 自定义字符串("保存点位教学：b站up:Stan_sin\r\n  BV1da4y1W7uA");
		全局.HiddenHint[4] = 自定义字符串("正在观战, R开始演示, 鼠标左/右键切换观战玩家, F+E退出");
	}
}

规则("[自定义]小字体信息")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.SmallHint[0] = 自定义字符串("不能再继续开拓了​");
        全局.SmallHint[1] = 自定义字符串("不要乱跑");
        全局.SmallHint[2] = 自定义字符串("超级跳开拓模式");
        全局.SmallHint[3] = 自定义字符串("正常开拓模式");
        全局.SmallHint[4] = 自定义字符串("传送点模式");
        全局.SmallHint[5] = 自定义字符串("通关了!用时:");
        全局.SmallHint[6] = 自定义字符串(".但是他作弊了~");
        全局.SmallHint[7] = 自定义字符串("拿到糖果了!");
        全局.SmallHint[8] = 自定义字符串("糖果还没拿到!");
        全局.SmallHint[9] = 自定义字符串("要先拿糖果哦!");
        全局.SmallHint[10] = 自定义字符串("开拓者已开拓​");
        全局.SmallHint[11] = 自定义字符串("坐标错误");
        全局.SmallHint[12] = 自定义字符串("继续长按将清除最后一关​");
        全局.SmallHint[13] = 自定义字符串("起点已清除​");
        全局.SmallHint[14] = 自定义字符串("最后一关已删除​");
        全局.SmallHint[15] = 自定义字符串("请不要连续开拓​");
        全局.SmallHint[16] = 自定义字符串("请站在地上设置开拓起点​");
        全局.SmallHint[17] = 自定义字符串("开启隐身​");
        全局.SmallHint[18] = 自定义字符串("关闭隐身​");
        全局.SmallHint[19] = 自定义字符串("自由移动​");
        全局.SmallHint[20] = 自定义字符串("关闭自由移动​");
        全局.SmallHint[21] = 自定义字符串("不要转弯");
        全局.SmallHint[22] = 自定义字符串("请在地面上起跳");
        全局.SmallHint[23] = 自定义字符串("不要乱跑");
        全局.SmallHint[24] = 自定义字符串("点位间距太短");
        全局.SmallHint[25] = 自定义字符串("{0}: 卡关了吗? 发送需要治疗/帮助(X)让教练演示一下", 英雄图标字符串(英雄(破坏球)));
        全局.SmallHint[26] = 自定义字符串("这关太简单了, 教练懒得教");
        全局.SmallHint[27] = 自定义字符串("教练正忙, 请稍候再试");
        全局.SmallHint[28] = 自定义字符串("准备中");
        全局.SmallHint[29] = 自定义字符串("就绪, F+E观战, R开始演示");
        全局.SmallHint[30] = 自定义字符串("空闲中");
		全局.SmallHint[31] = 自定义字符串("到时间了, 教练要去耍了");
		全局.SmallHint[32] = 自定义字符串("可以F+E观看键位, R开始演示");
	}
}

规则("[自定义]定时更新目标点描述")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		If(全局.RoomAliveHoursLeft == 0 && 比赛时间 == 0);
			设置目标点描述(所有玩家(所有队伍), 自定义字符串("房间即将重启​"), 可见和字符串);
		Else;
			设置目标点描述(所有玩家(所有队伍), 自定义字符串("本局游戏时间还剩：​{0}小时​{1}分钟​", 全局.RoomAliveHoursLeft, 取整(比赛时间 / 60, 下)), 可见和字符串);
		End;
		等待(1, 无视条件);
		循环;
	}
}

规则("[自定义]HUD指引文本")
{
	事件
	{
		子程序;
		CreateHUDText;
	}

	动作
	{
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串(
			"代码：9ZDS3"),
			左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("\r\n\r\n"), 左边, 1, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串(" "), 右边, 1, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("\r\n{0} 双击互动键（{1}）查看快捷键列表", 技能图标字符串(英雄(托比昂), 按钮(技能2)), 输入绑定字符串(按钮(互动))), 左边, 98, 无, 无, 自定义颜色(220,
			220, 220, 200), 可见和字符串, 默认可见度);
		If(全局.BotEnabled && 全局.actions != 无);
			创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("发送需要治疗/帮助(X)召唤教练(部分关卡可用)\n发送感谢释放, Q重置, R开始演示\nf + e观看键位\n如果演示失败, 等几秒后重试一次"), 左边, 4, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		End;
		If(全局.PioneerModeEnabled == 真);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), !实体存在(全局.Pioneer) && 数量(全局.CheckpointPosition) == 0 && 在地面上(当前数组元素)), 自定义字符串("互动{0}+装填{1} 在当前位置开拓​",
				输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(装填))), 无, 无, 顶部, 5, 颜色(橙色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.GameComplete && !实体存在(全局.Pioneer) && 数量(全局.CheckpointPosition) != 0), 自定义字符串(
				"互动{0}+装填{1} 成为开拓者,继续开拓​", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(装填))), 无, 无, 顶部, 5, 颜色(橙色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.GameComplete && 实体存在(全局.Pioneer)), 自定义字符串("当前开拓者: {0}", 全局.Pioneer), 无, 无, 顶部, 5, 颜色(橙色), 颜色(白色),
				颜色(白色), 可见和字符串, 始终不可见);
			创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("\r\n已开拓关卡数:{0}", 数量(全局.CheckpointPosition) - 1), 右边, 0, 颜色(白色), 颜色(白色), 颜色(橙色), 可见和字符串, 默认可见度);
			创建HUD文本(添加至数组(添加至数组(空数组, 全局.Pioneer), 无)[1 * !(全局.PioneerLandingPosition != 无)], 自定义字符串("已开拓 长按互动确认,短按互动重新开拓​"), 无, 无, 顶部, 5, 颜色(
				橙色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		Else;
			创建HUD文本(所有玩家(所有队伍), 自定义字符串("最好成绩: {0}/{1}S", 全局.BestScore[0], 全局.BestScore[1]), 无, 无, 左边, 0, 颜色(绿色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		End;
		If(全局.Tips != 无);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), !当前数组元素.GameComplete), 无, 无, 自定义字符串("\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"), 顶部, 99, 无, 无, 无, 可见, 默认可见度);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), !当前数组元素.GameComplete), 无, 无, 自定义字符串("\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"), 顶部, 99, 无, 无, 无, 可见, 默认可见度);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), !当前数组元素.GameComplete), 无, 无, 自定义字符串("\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"), 顶部, 99, 无, 无, 无, 可见, 默认可见度);
		End;
	}
}

//子程序
规则("创建闯关者HUD文本")
{
	事件
	{
		子程序;
		CreatePlayerHUDText;
	}

	动作
	{
		创建HUD文本(已过滤的数组(事件玩家, !事件玩家.GameComplete), 自定义字符串("第​{0}关 {1}", 事件玩家.Level + 1, 全局.Creator[事件玩家.Level]?自定义字符串("作者: {0}", 全局.Creator[事件玩家.Level]):自定义字符串("")), 无, 无, 顶部, 4, 颜色(橙色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		事件玩家.HUDEntity[0] = 上一个文本ID;
		If(全局.PioneerModeEnabled == 真);
			创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("{0}:{1}", 事件玩家, 事件玩家.Level), 右边, 999 - 事件玩家.Level, 颜色(白色), 颜色(白色), 颜色(橙色), 可见性，排序规则和字符串, 默认可见度);
			事件玩家.HUDEntity[1] = 上一个文本ID;
		Else;
			创建HUD文本(已过滤的数组(事件玩家, !事件玩家.GameComplete), 无, 无, 自定义字符串("检查点: {0} / {1} ({2}s)", 事件玩家.Level + 1, 数量(全局.CheckpointPosition) - 1,  事件玩家.ScoreOfThisRound), 顶部, 5,
				颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
			事件玩家.HUDEntity[2] = 上一个文本ID;
			创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("{0}: {2}S/第{1}关", 事件玩家, 事件玩家.Level, 事件玩家.ScoreOfThisRound), 右边,
				事件玩家.BestScore, 颜色(白色), 颜色(白色), 颜色(橙色), 可见性，排序规则和字符串, 默认可见度);
			事件玩家.HUDEntity[3] = 上一个文本ID;
		End;
		创建HUD文本((事件玩家.FreeMode||(事件玩家.GameComplete&&全局.Pioneer!=事件玩家)) ? 事件玩家 : 无, 英雄图标字符串(全部英雄[事件玩家.chooseHero]), 字符串("{0} {1}", 字符串("英雄"), 事件玩家.chooseHero + 1),
			全部英雄[事件玩家.chooseHero], 右边, 1001, 颜色(白色), 颜色(白色), 颜色(白色), 可见性，排序规则和字符串, 默认可见度);
		事件玩家.HUDEntity[4] = 上一个文本ID;
    }
}

规则("创建闯关者效果")
{
	事件
	{
		子程序;
		CreatePlayerEffect;
	}

	动作
	{
        
        创建地图文本(事件玩家.Invisible ? 无 : 所有玩家(所有队伍), 事件玩家, 事件玩家, 1, 不要截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
		事件玩家.MapEntity[0] = 上一个文本ID;
		创建效果(数组(已过滤的数组(事件玩家, 数量(全局.CheckpointPosition) != 0), 事件玩家.Bot), 环, 颜色(绿色), 全局.CheckpointPosition[事件玩家.Level], 全局.RingRadius[1], 可见，位置和半径);
		事件玩家.EffectEntity[0] = 最后创建的实体;
		创建图标(数组(已过滤的数组(事件玩家, !事件玩家.GameComplete), 事件玩家.Bot), 全局.CheckpointPosition[事件玩家.Level + 1], 旗帜, 可见和位置, 颜色(黄色), 真);
		事件玩家.IconEntity[0] = 最后创建的实体;
		创建效果(数组(已过滤的数组(事件玩家, !事件玩家.GameComplete), 事件玩家.Bot), 环, 自定义颜色(全局.RGB[0], 全局.RGB[1], 全局.RGB[2], 全局.RGB[3]), 全局.CheckpointPosition[事件玩家.Level + 1],
			全局.RingRadius[0], 可见，位置和半径);
		事件玩家.EffectEntity[1] = 最后创建的实体;
		创建效果(数组(已过滤的数组(事件玩家, !事件玩家.GameComplete), 事件玩家.Bot), 光柱, 自定义颜色(全局.RGB[0], 全局.RGB[1], 全局.RGB[2], 全局.RGB[3]),
			全局.CheckpointPosition[事件玩家.Level + 1], 全局.RingRadius[0], 可见，位置和半径);
		事件玩家.EffectEntity[2] = 最后创建的实体;
		创建地图文本(数组(已过滤的数组(事件玩家, !事件玩家.GameComplete), 事件玩家.Bot), 全局.MapHint[0], 全局.CheckpointPosition[事件玩家.Level + 1], 2, 不要截取, 可见，位置和字符串, 颜色(白色),
			始终不可见);
		事件玩家.MapEntity[1] = 上一个文本ID;
		创建效果(数组(已过滤的数组(事件玩家, 全局.UltimateState[事件玩家.Level + 1] != 假), 事件玩家.Bot), 环, 自定义颜色(全局.RGB[4], 全局.RGB[5], 全局.RGB[6], 全局.RGB[7]),
			全局.UltimateState[事件玩家.Level + 1], 全局.RingRadius[2], 可见，位置和半径);
		事件玩家.EffectEntity[3] = 最后创建的实体;
		创建效果(数组(已过滤的数组(事件玩家, 全局.UltimateState[事件玩家.Level + 1] != 假), 事件玩家.Bot), 光柱, 自定义颜色(全局.RGB[4], 全局.RGB[5], 全局.RGB[6], 全局.RGB[7]),
			全局.UltimateState[事件玩家.Level + 1], 全局.RingRadius[2], 可见，位置和半径);
		事件玩家.EffectEntity[4] = 最后创建的实体;
		创建地图文本(数组(已过滤的数组(事件玩家, 全局.UltimateState[事件玩家.Level + 1] != 假), 事件玩家.Bot), 全局.MapHint[1], 全局.UltimateState[事件玩家.Level + 1], 2, 不要截取, 可见，位置和字符串,
			颜色(白色), 始终不可见);
		事件玩家.MapEntity[2] = 上一个文本ID;
		If(全局.SpherePosition != 无);
			"小球"
			创建效果(数组(已过滤的数组(事件玩家, 事件玩家.sphere_state == 假 && !事件玩家.GameComplete), 事件玩家.Bot), 球, 自定义颜色(全局.RGB[8], 全局.RGB[9], 全局.RGB[10], 全局.RGB[11]),
				全局.SpherePosition[事件玩家.Level + 1] + 矢量(0, 0.800, 0), 全局.SphereRadius, 可见，位置和半径);
			事件玩家.EffectEntity[5] = 最后创建的实体;
			"小球图标"
			创建地图文本(数组(已过滤的数组(事件玩家, 事件玩家.sphere_state == 假 && !事件玩家.GameComplete), 事件玩家.Bot), 全局.MapHint[2], 全局.SpherePosition[事件玩家.Level + 1] + 矢量(0,
				1.500, 0), 2, 不要截取, 可见，位置和字符串, 颜色(白色), 始终不可见);
			事件玩家.MapEntity[3] = 上一个文本ID;
			创建图标(数组(已过滤的数组(事件玩家, 事件玩家.sphere_state == 假 && !事件玩家.GameComplete), 事件玩家.Bot), 全局.SpherePosition[事件玩家.Level + 1] + 矢量(0, 0.800, 0), 加号, 可见，位置和颜色,
				颜色(橙色), 真);
			事件玩家.IconEntity[1] = 最后创建的实体;
		End;
	}
}

规则("创建Tips")
{
	事件
	{
		子程序;
		CreateTips;
	}

	动作
	{
		If(全局.Tips != 无);
			创建HUD文本(已过滤的数组(事件玩家, 全局.Tips[事件玩家.Level + 1] && !事件玩家.GameComplete && !事件玩家.FreeMode && !按钮被按下(事件玩家, 按钮(互动))), 自定义字符串(
				"{0}:　　　　　　　　　　　　　　　　　　　　　▼\n{1}\n", 英雄图标字符串(英雄(破坏球)), 全局.Tips[事件玩家.Level + 1]), 无, 无, 顶部, 100, 颜色(青绿色), 无, 无, 可见和字符串, 默认可见度);
			事件玩家.Entity[17] = 上一个文本ID;
		End;
	}
}

规则("变成球")
{
	事件
	{
		子程序;
		ResetBall;
	}

	动作
	{
		If(所用英雄(事件玩家) == 英雄(破坏球));
			While(!正在使用技能 1(事件玩家));
				事件玩家.IsReady = 假;
				设置启用技能 1(事件玩家, 真);
				可用按钮(事件玩家, 按钮(技能1));
				等待(0.250, 无视条件);
				按下按键(事件玩家, 按钮(技能1));
				等待直到 (正在使用技能 1(事件玩家), 0.500);
				事件玩家.IsReady = 真;
			End;
			If(!(事件玩家.FreeMode || 事件玩家.GameComplete) || 事件玩家 == 全局.Pioneer);
				禁用按钮(事件玩家, 按钮(技能1));
				禁用按钮(事件玩家, 按钮(主要攻击模式));
			End;
		End;
	}
}

规则("[子程序] 设置技能")
{
	事件
	{
		子程序;
		SetAbility;
	}

	动作
	{
		事件玩家.Ability1Used = 假;
		事件玩家.Ability2Used = 假;
		事件玩家.SecondaryFireUsed = 假;
		If(事件玩家.GameComplete || 事件玩家.FreeMode || 事件玩家.IsSpectating);
			If(全局.Pioneer != 事件玩家);
				可用按钮(事件玩家, 按钮(技能1));
				可用按钮(事件玩家, 按钮(主要攻击模式));
			End;
			设置启用技能 1(事件玩家, 全局.DefaultAliblty1Enabled && 全局.Pioneer != 事件玩家);
			设置启用技能 2(事件玩家, 全局.DefaultAliblty2Enabled);
			设置辅助攻击模式启用(事件玩家, 全局.DefaultSecondaryEnabled);
			设置启用终极技能(事件玩家, 全局.DefaultUltimateEnabled);
		Else;
			设置启用技能 1(事件玩家, 全局.Ability1State[事件玩家.Level]);
			设置启用技能 2(事件玩家, 全局.Ability2State[事件玩家.Level]);
			设置辅助攻击模式启用(事件玩家, 全局.SecondaryFireState[事件玩家.Level]);
			设置启用终极技能(事件玩家, 全局.UltimateState[事件玩家.Level]);
			禁用按钮(事件玩家, 按钮(主要攻击模式));
		End;
	}
}

规则("[子程序 ] 重置当前关卡")
{
	事件
	{
		子程序;
		Reset;
	}

	动作
	{
		While(全局.JumpState[事件玩家.Level] == 自定义字符串("跳跃点"));
			事件玩家.Level += 1;
		End;
		If(全局.Pioneer != 事件玩家);
			事件玩家.ultimate_log = 空数组;
		End;
		事件玩家.ultimate_info = 空数组;
		If(事件玩家.movementCollision == 真);
			事件玩家.movementCollision = 假;
			开启与环境的移动碰撞(事件玩家);
			设置引力(事件玩家, 100);
			设置移动速度(事件玩家, 100);
			设置技能冷却(事件玩家, 按钮(蹲下), 0);
		End;
		If(所用英雄(事件玩家) != 英雄(破坏球));
			播放效果(所有玩家(所在队伍(事件玩家)), 布丽吉塔恢复包护甲声音, 无, 事件玩家, 100);
			等待(0.300, 无视条件);
			开始强制玩家选择英雄(事件玩家, 英雄(破坏球));
			事件玩家.SpectatingState = 假;
		End;
		调用子程序(ResetBall);
		设置状态(事件玩家, 无, 定身, 0.250);
		事件玩家.UltimateUsed = 假;
		事件玩家.IsReady = 假;
		事件玩家.sphere_state = 全局.SpherePosition[事件玩家.Level + 1] ? 假 : 真;
		事件玩家.HintFreq += 1;
		If(事件玩家.sphere_state == 假 && 事件玩家.HintFreq % 5 == 1);
			小字体信息(事件玩家, 全局.SmallHint[9]);
		End;
		If(全局.BotEnabled && 全局.actions != 无);
			If(事件玩家.HintFreq % 30 == 15 && 全局.actions[事件玩家.Level + 1] != 无 && 数量(已过滤的数组(全局.Bot, 当前数组元素.owner == 无)) > 0 && 事件玩家.Bot == 无);
				小字体信息(事件玩家, 全局.SmallHint[25]);
			Else If(事件玩家.HintFreq % 20 == 3 && 全局.actions[事件玩家.Level + 1] != 无 && 事件玩家.Bot != 无);
				小字体信息(事件玩家, 全局.SmallHint[32]);
			End;
		End;
		If(水平速度(事件玩家) >= 6.900);
			设置辅助攻击模式启用(事件玩家, 假);
			设置启用技能 1(事件玩家, 假);
			设置启用技能 2(事件玩家, 假);
			设置启用终极技能(事件玩家, 假);
		End;
		If(事件玩家 == 全局.Pioneer);
			全局.PioneerStarted = 假;
			全局.PioneerLandingPosition = 无;
			全局.PioneerSpherePosition = 无;
		End;
		If(!全局.PioneerModeEnabled && 事件玩家.Level == 0);
			停止追踪玩家变量(事件玩家, ScoreOfThisRound);
			事件玩家.ScoreOfThisRound = 0;
		End;
		施加推力(事件玩家, 方向(眼睛位置(事件玩家) + 眼睛位置(事件玩家) * 面朝方向(事件玩家), 所选位置(事件玩家)), 1, 至地图, 取消相反运动);
		等待(0.032, 无视条件);
		If((相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius) && 数量(
			全局.CheckpointPosition) != 0);
			传送(事件玩家, 全局.CheckpointPosition[事件玩家.Level]);
		End;
		事件玩家.IsReady = 真;
		If(事件玩家 == 全局.Pioneer);
			全局.PioneerStarted = 真;
		End;
		设置技能冷却(事件玩家, 按钮(辅助攻击模式), 0);
		设置技能冷却(事件玩家, 按钮(技能1), 0);
		设置技能冷却(事件玩家, 按钮(技能2), 0);
		施加推力(事件玩家, 速率(事件玩家) * -1, 0.010, 至地图, 取消相反运动);
		If(全局.UltimateState[事件玩家.Level + 1] != (假 || 0));
			事件玩家.ultimate_info[0] = 全局.CheckpointPosition[事件玩家.Level];
			事件玩家.ultimate_info[1] = 全局.UltimateState[事件玩家.Level + 1];
			事件玩家.ultimate_info[2] = 事件玩家.ultimate_info[0] + 方向(事件玩家.ultimate_info[0], 事件玩家.ultimate_info[1]) * 1000;
			事件玩家.ultimate_info[3] = 与此方向的水平角度(方向(事件玩家.ultimate_info[2], 事件玩家.ultimate_info[0]));
			事件玩家.ultimate_worked = 真;
		Else;
			事件玩家.ultimate_worked = 假;
			事件玩家.ultimate_info = 空数组;
		End;
		If(事件玩家.ultimate_log == 自定义字符串("已开启"));
			事件玩家.ultimate_worked = 真;
		End;
		If(事件玩家.Level < 事件玩家.cheat);
			事件玩家.cheat = 0;
		End;
	}
}

//创建文本
规则("[多行字符串] 快捷键说明")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.ShowHotKey), 无, 无, 自定义字符串("－－－－－－－－－－－－－－－－－－－－"), 左边, 10, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		For 全局变量(Idx, 0, 数量(全局.ShortKeyHint) - 1, 1);
        	创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.ShowHotKey), 无, 无, 单次赋值(全局.ShortKeyHint[全局.Idx]), 左边, 全局.Idx + 11, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		End;
		创建HUD文本(已过滤的数组(所有玩家(队伍1), 当前数组元素.FreeMode||(当前数组元素.GameComplete&&全局.Pioneer!=当前数组元素)), 无, 无,
			全局.ShortKeyHint[12], 右边, 2001, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
	}
}

规则("[多行字符串] 隐藏说明文本")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		创建HUD文本(所有玩家(队伍2), 全局.HiddenHint[4], 无, 无, 顶部, 17, 颜色(天蓝色), 颜色(白色), 颜色(黄色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.ShowHotKey), 无, 无, 自定义字符串("－－－－－－－－－－－－－－－－－－－－"), 左边, 27, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.ShowHotKey), 无, 无, 全局.HiddenHint[0], 左边, 28, 颜色(白色), 颜色(白色), 颜色(黄色), 可见和字符串, 默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.ShowHotKey), 无, 无, 全局.HiddenHint[1], 左边, 29, 颜色(白色), 颜色(白色), 颜色(黄色), 可见和字符串, 默认可见度);
	}
}

//初始化
规则("创建开拓者效果")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.PioneerModeEnabled == 真;
	}

	动作
	{
        创建效果(已过滤的数组(全局.Pioneer, 全局.PioneerLandingPosition != 假), 环, 颜色(黄色), 全局.PioneerLandingPosition, 全局.RingRadius[0], 可见，位置和半径);
        创建效果(已过滤的数组(全局.Pioneer, 全局.PioneerLandingPosition != 假), 光柱, 颜色(黄色), 全局.PioneerLandingPosition, 全局.RingRadius[0], 可见，位置和半径);
        创建效果(已过滤的数组(全局.Pioneer, 全局.Pioneer.UltimateUsed != (假 || 0)), 环, 颜色(亮紫色), 全局.Pioneer.UltimateUsed, 全局.RingRadius[2], 可见，位置和半径);
        创建效果(已过滤的数组(全局.Pioneer, 全局.Pioneer.UltimateUsed != (假 || 0)), 光柱, 颜色(亮紫色), 全局.Pioneer.UltimateUsed, 全局.RingRadius[2], 可见，位置和半径);
        "小球"
        创建效果(已过滤的数组(全局.Pioneer, 全局.PioneerSpherePosition != 假), 球, 自定义颜色(全局.RGB[8], 全局.RGB[9], 全局.RGB[10], 全局.RGB[11]),
            全局.PioneerSpherePosition + 矢量(0, 0.800, 0), 全局.SphereRadius, 可见，位置和半径);
        "小球图标"
        创建图标(已过滤的数组(全局.Pioneer, 全局.PioneerSpherePosition != 假), 全局.PioneerSpherePosition + 矢量(0, 0.800, 0), 加号, 可见，位置和颜色, 颜色(橙色), 真);
    }
}

规则("玩家初始化")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		事件玩家.Level = 0;
		事件玩家.ScoreOfThisRound = 0;
		事件玩家.chooseHero = 0;
		事件玩家.mistake = 0;
		事件玩家.cheat = 0;
		事件玩家.HintFreq = 0;
		事件玩家.InteractPressState = 0;
		事件玩家.IsReady = 真;
		事件玩家.ShowHotKey = 假;
		事件玩家.playerTittle = 首个(已过滤的数组(全局.Vips, 当前数组元素[0] == 自定义字符串("{0}", 事件玩家)));
		事件玩家.playerNickname = 事件玩家.playerTittle ? (事件玩家.playerTittle[1] ? 事件玩家.playerTittle[1] : 自定义字符串("{0}", 事件玩家)) : 自定义字符串("{0}",
			事件玩家);
		事件玩家.playerColor = 事件玩家.playerTittle ? (事件玩家.playerTittle[2] == 颜色(白色) ? 自定义颜色(随机整数(0, 255), 随机整数(0, 255), 随机整数(0, 255), 255)
			: 事件玩家.playerTittle[2]) : 颜色(白色);
		If(是否是机器人(事件玩家) == 假);
			传送(事件玩家, 全局.CheckpointPosition[事件玩家.Level]);
			事件玩家.FreeMode = 假;
			调用子程序(ValidationPlayerData);
        	调用子程序(CreatePlayerHUDText);
        	调用子程序(CreateTips);
			调用子程序(ResetBall);
        	调用子程序(CreatePlayerEffect);
		End;
		事件玩家.Invisible = 假;
		事件玩家.IsSpectating = 假;
		事件玩家.movementCollision = 假;
		事件玩家.SpectatingState = 假;
		对所有玩家启用死亡回放(事件玩家);
		启用死亡回放时目标的HUD(事件玩家);
	}
}

规则("全局初始化")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		关闭游戏预设通告模式;
		关闭游戏预设计分模式;
		关闭游戏预设完成条件;
		关闭游戏预设音乐模式;
		隐藏计分板(所有玩家(所有队伍));
		If(数量(全局.CheckpointPosition) == 0);
			全局.CheckpointPosition = 空数组;
			全局.Ability1State = 空数组;
			全局.Ability2State = 空数组;
			全局.SecondaryFireState = 空数组;
			全局.Creator = 空数组;
			全局.UltimateState = 空数组;
		End;
		全局.RoomAliveHoursLeft = 4;
		全局.PlayersData = 空数组;
		设置比赛时间(1800);
		全局.PioneerLandingPosition = 无;
		全局.PioneerSpherePosition = 无;
        全局.BestScore[0] = 自定义字符串("");
        全局.BestScore[1] = 0;
        调用子程序(CreateHUDText);
	}
}

//存档
规则("验证玩家数据 ValidationPlayerData")
{
	事件
	{
		子程序;
		ValidationPlayerData;
	}

	动作
	{
		"如果数组中有玩家数据, 则将值赋给事件玩家 checkpoint, time, mistake, cheat"
		If(对任意为”真“(全局.PlayersData, 当前数组元素[0] == 自定义字符串("{0}", 事件玩家)));
			事件玩家.Level = 已过滤的数组(全局.PlayersData, 当前数组元素[0] == 自定义字符串("{0}", 事件玩家))[0][1];
			事件玩家.ScoreOfThisRound = 已过滤的数组(全局.PlayersData, 当前数组元素[0] == 自定义字符串("{0}", 事件玩家))[0][2];
			事件玩家.mistake = 已过滤的数组(全局.PlayersData, 当前数组元素[0] == 自定义字符串("{0}", 事件玩家))[0][3];
			事件玩家.cheat = 已过滤的数组(全局.PlayersData, 当前数组元素[0] == 自定义字符串("{0}", 事件玩家))[0][4];
			事件玩家.dataIndex = 数组值的索引(全局.PlayersData, 已过滤的数组(全局.PlayersData, 当前数组元素[0] == 自定义字符串("{0}", 事件玩家))[0]) / 5;
		"反之, 将 玩家昵称, checkpoint, time, mistake, cheat 组成数组 添加到末尾索引"
		Else;
			事件玩家.dataIndex = 数量(全局.PlayersData);
			全局.PlayersData[数量(全局.PlayersData)] = 数组(自定义字符串("{0}", 事件玩家), 事件玩家.Level, 事件玩家.ScoreOfThisRound, 事件玩家.mistake, 事件玩家.cheat);
		End;
	}
}

规则("编辑玩家数据 EditPlayerData")
{
	事件
	{
		子程序;
		EditPlayerData;
	}

	动作
	{
		全局.PlayersData[事件玩家.dataIndex] = 事件玩家.Level < 数量(全局.CheckpointPosition) - 1 ? 数组(自定义字符串("{0}", 事件玩家), 事件玩家.Level,
			事件玩家.ScoreOfThisRound, 事件玩家.mistake, 事件玩家.cheat) : 数组(自定义字符串("{0}", 事件玩家), 0, 0, 0, 0);
	}
}

//关卡设置
规则("删除关卡后修复玩家关卡数")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.Level >= 数量(全局.CheckpointPosition);
	}

	动作
	{
		事件玩家.Level = 数量(全局.CheckpointPosition) - 1;
		事件玩家.Level = 较大(事件玩家.Level, 0);
	}
}

规则("是否完成所有关卡 假")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.Level < 数量(全局.CheckpointPosition) - 1;
	}

	动作
	{
		事件玩家.GameComplete = 假;
	}
}

规则("是否完成所有关卡 真")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(数量(全局.CheckpointPosition) == 0 || 事件玩家.Level >= 数量(全局.CheckpointPosition) - 1) == 真;
	}

	动作
	{
		事件玩家.GameComplete = 真;
		调用子程序(SetAbility);
		If(全局.PioneerModeEnabled == 假 && 事件玩家.ScoreOfThisRound != 0);
			事件玩家.LastScore = 事件玩家.ScoreOfThisRound;
			If(事件玩家.cheat == 0);
				小字体信息(所有玩家(所有队伍), 自定义字符串("{0}{1}{2}", 事件玩家, 全局.SmallHint[5], 事件玩家.LastScore));
				事件玩家.BestScore = 事件玩家.ScoreOfThisRound;
				If(全局.BestScore[1] == 0 || 事件玩家.BestScore < 全局.BestScore[1]);
					全局.BestScore[0] = 自定义字符串("{0}", 事件玩家);
					全局.BestScore[1] = 事件玩家.LastScore;
				End;
			Else;
				小字体信息(所有玩家(所有队伍), 自定义字符串("{0}{1}{2}", 事件玩家, 全局.SmallHint[5],  自定义字符串("{0}{1}{2}", 事件玩家.LastScore, 全局.SmallHint[6], 英雄图标字符串(英雄(破坏球)))));
			End;
		End;
		停止追踪玩家变量(事件玩家, ScoreOfThisRound);
	}
}

规则("当玩家成为开拓者")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
	}

	动作
	{
		If(数量(全局.CheckpointPosition) < 1000);
			播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 100);
			事件玩家.FreeMode = 假;
			调用子程序(Reset);
		Else;
			小字体信息(事件玩家, 全局.SmallHint[0]);
			全局.PioneerStarted = 假;
			全局.Pioneer = 无;
		End;
		If(全局.UltimateState[事件玩家.Level + 1] != 假);
			施加推力(事件玩家, 速率(事件玩家) * -1, 0.010, 至地图, 取消相反运动);
			大字体信息(事件玩家, 全局.SmallHint[1]);
			调用子程序(Reset);
		End;
		事件玩家.ultimate_log = 自定义字符串("已关闭");
		根据条件中止(事件玩家 != 全局.Pioneer);
		If(事件玩家.ultimate_log == 自定义字符串("已开启"));
			事件玩家.ultimate_worked = 真;
			小字体信息(事件玩家, 全局.SmallHint[2]);
		Else;
			事件玩家.ultimate_worked = 假;
			小字体信息(事件玩家, 全局.SmallHint[3]);
		End;
		事件玩家.UltimateUsed = 假;
	}
}

//技能设置
规则("记录玩家辅助攻击使用情况")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.SecondaryFireUsed == 假;
		正在使用辅助武器(事件玩家) == 真;
	}

	动作
	{
		事件玩家.SecondaryFireUsed = 真;
	}
}

规则("终极技能模拟CD(开始CD)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DefaultUltimateEnabled == 真;
		正在使用终极技能(事件玩家) == 假;
		终极技能充能百分比(事件玩家) <= 1;
	}

	动作
	{
		事件玩家.UltimateCharge = 0;
	}
}

规则("一次性辅助攻击模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.OneTimeAbility == 真;
		事件玩家.FreeMode == 假;
		(!事件玩家.GameComplete || 事件玩家 == 全局.Pioneer) == 真;
		事件玩家.SecondaryFireUsed == 真;
		正在使用辅助武器(事件玩家) == 假;
	}

	动作
	{
		等待(0.500, 当为“假”时中止);
		If(相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius || !在地面上(事件玩家));
			If(事件玩家 != 全局.Pioneer || 全局.PioneerLandingPosition == 无);
				设置辅助攻击模式启用(事件玩家, 假);
			End;
		End;
	}
}

规则("一次性技能2")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.OneTimeAbility == 真;
		事件玩家.FreeMode == 假;
		(!事件玩家.GameComplete || 事件玩家 == 全局.Pioneer) == 真;
		事件玩家.Ability2Used == 真;
		正在使用技能 2(事件玩家) == 假;
	}

	动作
	{
		等待(0.500, 当为“假”时中止);
		If(相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius || !在地面上(事件玩家));
			If(事件玩家 != 全局.Pioneer || 全局.PioneerLandingPosition == 无);
				设置启用技能 2(事件玩家, 假);
			End;
		End;
	}
}

规则("在地面上时 重置一次性技能")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.IsReady == 真;
		在地面上(事件玩家) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) <= 全局.RingRadius;
	}

	动作
	{
		If(事件玩家.ultimate_worked == 假 || 水平速度(事件玩家) < 6.900);
			调用子程序(SetAbility);
		End;
	}
}

规则("在地面上时 重置技能CD")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.IsReady == 真;
		在地面上(事件玩家) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) <= 全局.RingRadius;
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) + 技能冷却时间(事件玩家, 按钮(技能1)) + 技能冷却时间(事件玩家, 按钮(技能2)) != 0;
	}

	动作
	{
		等待(0.032, 当为“假”时中止);
		设置技能冷却(事件玩家, 按钮(辅助攻击模式), 0);
		设置技能冷却(事件玩家, 按钮(技能1), 0);
		设置技能冷却(事件玩家, 按钮(技能2), 0);
	}
}

//玩家判定
规则("小球拾取")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.sphere_state == 假;
		事件玩家.IsReady == 真;
		事件玩家.FreeMode == 假;
		全局.Pioneer != 事件玩家;
		事件玩家.GameComplete == 假;
		相距距离(事件玩家, 全局.SpherePosition[事件玩家.Level + 1]) <= 全局.SphereJudgeRadius;
	}

	动作
	{
		事件玩家.sphere_state = !事件玩家.GameComplete && !事件玩家.FreeMode ? 真 : 假;
		小字体信息(事件玩家, 全局.SmallHint[7]);
		播放效果(事件玩家, 正面状态施加声音, 无, 事件玩家, 80);
	}
}

规则("闯关者到达下一关")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.IsReady == 真;
		事件玩家.FreeMode == 假;
		全局.Pioneer != 事件玩家;
		事件玩家.GameComplete == 假;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level + 1]) <= 全局.RingRadius;
		(!全局.JudgeWhenLanding || 在地面上(事件玩家)) == 真;
		事件玩家.ultimate_worked == 假;
		事件玩家.edit_mode == 0;
	}

	动作
	{
		If(!事件玩家.sphere_state);
			调用子程序(Reset);
			小字体信息(事件玩家, 全局.SmallHint[8]);
			播放效果(事件玩家, 爆炸声音, 无, 事件玩家, 100);
			中止;
		End;
		播放效果(事件玩家, 状态爆炸声音, 颜色(白色), 事件玩家, 100);
		事件玩家.Level += 1;
		事件玩家.HintFreq = 0;
		调用子程序(EditPlayerData);
		If(事件玩家.Level < 数量(全局.CheckpointPosition));
			调用子程序(Reset);
		End;
		If(事件玩家.Bot != 无);
			调用子程序(ReleaseBot);
		End;
	}
}

规则("闯关者圈外触地")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.Pioneer != 事件玩家;
		事件玩家.FreeMode == 假;
		事件玩家.GameComplete == 假;
		在地面上(事件玩家) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level + 1]) > 全局.RingRadius[0];
	}

	动作
	{
		If(事件玩家.ultimate_worked == 假);
			等待(0.016, 当为“假”时中止);
			事件玩家.mistake += 1;
			调用子程序(Reset);
		End;
	}
}

规则("开拓者圈外触地")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
		事件玩家.FreeMode == 假;
		全局.PioneerLandingPosition == 无;
		全局.PioneerStarted == 真;
		在地面上(事件玩家) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
	}

	动作
	{
		If(事件玩家.ultimate_worked == 假);
			If(相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) < 全局.RingRadius[1] * 2);
				大字体信息(事件玩家, 全局.SmallHint[24]);
				调用子程序(Reset);
				If(事件玩家.UltimateUsed != 假);
					If(相距距离(事件玩家.UltimateUsed, 所选位置(事件玩家)) >= 2 * 全局.RingRadius[2]);
						大字体信息(事件玩家, 全局.SmallHint[24]);
						调用子程序(Reset);
					End;
				End;
			Else;
				播放效果(事件玩家, 状态爆炸声音, 颜色(白色), 事件玩家, 100);
				全局.PioneerLandingPosition = 所选位置(事件玩家);
				设置启用技能 2(事件玩家, 事件玩家.Ability2Used);
				设置辅助攻击模式启用(事件玩家, 事件玩家.SecondaryFireUsed);
				设置启用终极技能(事件玩家, 事件玩家.UltimateUsed);
			End;
		End;
	}
}

规则("闯关者圈内触地")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.Pioneer != 事件玩家;
		事件玩家.FreeMode == 假;
		事件玩家.GameComplete == 假;
		在地面上(事件玩家) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) <= 全局.RingRadius[1];
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level + 1]) > 全局.RingRadius[0];
	}

	动作
	{
		If(事件玩家.ultimate_worked == 假 || 水平速度(事件玩家) < 6.900);
			事件玩家.sphere_state = 全局.SpherePosition[事件玩家.Level + 1] ? 假 : 真;
		End;
	}
}

规则("开拓者圈内触地")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
		事件玩家.FreeMode == 假;
		全局.PioneerLandingPosition == 无;
		全局.PioneerStarted == 真;
		在地面上(事件玩家) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) <= 全局.RingRadius[1];
	}

	动作
	{
		If(事件玩家.ultimate_worked == 假);
			全局.PioneerSpherePosition = 无;
		End;
	}
}

规则("开拓者离开比赛")
{
	事件
	{
		玩家离开比赛;
		双方;
		全部;
	}

	条件
	{
		全局.PioneerModeEnabled == 真;
		事件玩家 == 全局.Pioneer;
	}

	动作
	{
		全局.PioneerStarted = 假;
		全局.PioneerLandingPosition = 无;
		全局.Pioneer = 数组随机取值(已过滤的数组(所有玩家(所有队伍), 当前数组元素.GameComplete && 当前数组元素 != 事件玩家 && 当前数组元素 != 最后(全局.Creator)));
	}
}

规则("当玩家离开比赛")
{
	事件
	{
		玩家离开比赛;
		双方;
		全部;
	}

	动作
	{
		If(事件玩家.Bot != 无);
			调用子程序(ReleaseBot);
		End;
		For 玩家变量(事件玩家, i, 0, 数量(事件玩家.MapEntity), 1);
			消除地图文本(事件玩家.MapEntity[事件玩家.i]);
		End;
		For 玩家变量(事件玩家, i, 1, 数量(事件玩家.HUDEntity), 1);
			消除HUD文本(事件玩家.HUDEntity[事件玩家.i]);
		End;
		For 玩家变量(事件玩家, i, 0, 数量(事件玩家.EffectEntity), 1);
			消除效果(事件玩家.EffectEntity[事件玩家.i]);
		End;
		For 玩家变量(事件玩家, i, 0, 数量(事件玩家.IconEntity), 1);
			消除图标(事件玩家.IconEntity[事件玩家.i]);
		End;
	}
}

规则("相移")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		具有状态(事件玩家, 相移) == 假;
	}

	动作
	{
		等待(0.250, 无视条件);
		清除状态(事件玩家, 相移);
		设置状态(事件玩家, 无, 相移, 9999);
	}
}

规则("阵亡复位")
{
	事件
	{
		玩家阵亡;
		双方;
		全部;
	}

	条件
	{
		被攻击方.IsSpectating == 假;
        是否是机器人(事件玩家) == 假;
	}

	动作
	{
		被攻击方.IsReady = 假;
		If(全局.Pioneer == 事件玩家 && 全局.PioneerLandingPosition == 无);
			全局.PioneerStarted = 假;
		End;
		If(!全局.PioneerModeEnabled && 事件玩家.Level == 0);
			停止追踪玩家变量(被攻击方, ScoreOfThisRound);
			被攻击方.ScoreOfThisRound = 0;
		End;
		被攻击方.FacingDirection = 面朝方向(被攻击方);
		清除状态(被攻击方, 相移);
		设置状态(被攻击方, 无, 相移, 16200);
		等待(0.032, 无视条件);
		If(全局.Pioneer == 事件玩家);
			If(全局.PioneerLandingPosition != 无);
				传送(被攻击方, 全局.PioneerLandingPosition);
			Else;
				传送(被攻击方, 全局.CheckpointPosition[被攻击方.Level]);
			End;
			等待(0.016, 无视条件);
			复活(被攻击方);
		Else;
			If(事件玩家.FreeMode || 事件玩家.GameComplete);
				传送(被攻击方, 最近的可行走位置(所选位置(被攻击方)));
				复活(被攻击方);
			Else If(数量(全局.CheckpointPosition) != 0);
				传送(被攻击方, 全局.CheckpointPosition[被攻击方.Level]);
				等待(0.016, 无视条件);
				复活(被攻击方);
			End;
		End;
		等待(0.500, 无视条件);
		设置朝向(被攻击方, 被攻击方.FacingDirection, 至地图);
		被攻击方.IsReady = 真;
		If(全局.Pioneer == 事件玩家 && 全局.PioneerLandingPosition == 无);
			全局.PioneerStarted = 真;
		End;
		调用子程序(ResetBall);
	}
}

禁用 规则("球形态关闭主要攻击模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		设置主要攻击模式启用(事件玩家, 假);
	}
}

禁用 规则("开启主要攻击模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 假;
		(事件玩家.FreeMode || 事件玩家.GameComplete) == 真;
	}

	动作
	{
		设置主要攻击模式启用(事件玩家, 真);
	}
}

//房间设置
规则("房间存活倒计时")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		比赛时间 == 0;
		全局.RoomAliveHoursLeft != 0;
	}

	动作
	{
		等待(1, 无视条件);
		全局.RoomAliveHoursLeft -= 1;
		设置比赛时间(3600);
	}
}

规则("跑酷模式计时开始")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.PioneerModeEnabled == 假;
		事件玩家.FreeMode == 假;
		事件玩家.IsReady == 真;
		事件玩家.GameComplete == 假;
		相距距离(所选位置(事件玩家), 首个(全局.CheckpointPosition)) > 全局.RingRadius;
		已重生(事件玩家) == 真;
	}

	动作
	{
		If(事件玩家.Level == 0);
			停止追踪玩家变量(事件玩家, ScoreOfThisRound);
			事件玩家.ScoreOfThisRound = 0;
		End;
		追踪玩家变量频率(事件玩家, ScoreOfThisRound, 16200, 1, 全部禁用);
	}
}

规则("通关或自由模式下无CD")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 != 全局.Pioneer;
		(事件玩家.GameComplete || 事件玩家.FreeMode) == 真;
		((技能冷却时间(事件玩家, 按钮(辅助攻击模式)) + 技能冷却时间(事件玩家, 按钮(技能1)) + 技能冷却时间(事件玩家, 按钮(技能2)) != 0) || 终极技能充能百分比(事件玩家) < 100) == 真;
	}

	动作
	{
		设置技能冷却(事件玩家, 按钮(辅助攻击模式), 0);
		设置技能冷却(事件玩家, 按钮(技能1), 0);
		设置技能冷却(事件玩家, 按钮(技能2), 0);
		设置终极技能充能(事件玩家, 100);
	}
}

//热键
规则("设置互动键按下状态")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		按钮被按下(全局.Pioneer, 按钮(互动)) == 真;
		全局.PioneerLandingPosition != 无;
	}

	动作
	{
		全局.Pioneer.InteractPressState = 1;
		等待(1, 当为“假”时中止);
		全局.Pioneer.InteractPressState = 2;
	}
}

规则("松开1帧后清除按下状态")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		按钮被按下(全局.Pioneer, 按钮(互动)) == 假;
	}

	动作
	{
		等待(0.016, 无视条件);
		全局.Pioneer.InteractPressState = 0;
	}
}


规则("[热键] 按R, 取消环境碰撞")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(事件玩家.FreeMode || (事件玩家.GameComplete && 全局.Pioneer != 事件玩家)) == 真;
		事件玩家.IsSpectating == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 假;
		按钮被按下(事件玩家, 按钮(技能1)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
	}

	动作
	{
		禁用 等待(1, 当为“假”时中止);
		事件玩家.movementCollision = !事件玩家.movementCollision;
		If(事件玩家.movementCollision);
			取消与环境的移动碰撞(事件玩家, 假);
			设置引力(事件玩家, 50);
			设置移动速度(事件玩家, 150);
			小字体信息(事件玩家, 自定义字符串("已取消环境碰撞"));
		Else;
			开启与环境的移动碰撞(事件玩家);
			设置引力(事件玩家, 100);
			设置移动速度(事件玩家, 100);
			小字体信息(事件玩家, 自定义字符串("已开启环境碰撞"));
		End;
	}
}

规则("左右键选择英雄")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(事件玩家.FreeMode || (事件玩家.GameComplete && 全局.Pioneer != 事件玩家)) == 真;
		(按钮被按下(事件玩家, 按钮(主要攻击模式)) || 按钮被按下(事件玩家, 按钮(辅助攻击模式))) == 真;
	}

	动作
	{
		If(按钮被按下(事件玩家, 按钮(主要攻击模式)));
			事件玩家.chooseHero += 事件玩家.chooseHero == 数量(全部英雄) - 1 ? 1 - 数量(全部英雄) : 1;
		Else If(按钮被按下(事件玩家, 按钮(辅助攻击模式)));
			事件玩家.chooseHero -= 事件玩家.chooseHero == 0 ? 1 - 数量(全部英雄) : 1;
		End;
		预加载英雄(事件玩家, 全部英雄[事件玩家.chooseHero]);
	}
}

规则("语音上, 更换英雄")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(事件玩家.FreeMode || (事件玩家.GameComplete && 全局.Pioneer != 事件玩家)) == 真;
		正在交流(事件玩家, 语音（上）) == 真;
	}

	动作
	{
		播放效果(所有玩家(所在队伍(事件玩家)), 布丽吉塔恢复包护甲声音, 无, 事件玩家, 100);
		等待(0.300, 无视条件);
		开始强制玩家选择英雄(事件玩家, 全部英雄[事件玩家.chooseHero]);
		事件玩家.SpectatingState = 假;
	}
}

规则("[热键] 开拓者放置小球")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
		全局.PioneerLandingPosition == 无;
		全局.PioneerSpherePosition == 无;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		事件玩家.pioneer_mode != 自定义字符串("传送点");
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
	}

	动作
	{
		全局.PioneerSpherePosition = 所选位置(事件玩家);
	}
}

规则("[热键] 开拓者确认开拓")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
		全局.PioneerLandingPosition != 无;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		事件玩家.InteractPressState == 2;
	}

	动作
	{
		If(事件玩家.UltimateUsed != (0 || 假) || 事件玩家.ultimate_log == 自定义字符串("已关闭"));
			全局.JumpState[事件玩家.Level] = 事件玩家.pioneer_mode == 自定义字符串("传送点");
			事件玩家.InteractPressState = 0;
			全局.CheckpointPosition[事件玩家.Level + 1] = 全局.PioneerLandingPosition;
			全局.SecondaryFireState[事件玩家.Level] = 事件玩家.SecondaryFireUsed;
			全局.UltimateState[事件玩家.Level + 1] = 事件玩家.UltimateUsed;
			全局.SpherePosition[事件玩家.Level + 1] = 全局.PioneerSpherePosition;
			全局.Creator[事件玩家.Level] = 自定义字符串("{0}", 事件玩家);
			全局.PioneerStarted = 假;
			全局.PioneerLandingPosition = 无;
			全局.PioneerSpherePosition = 无;
			全局.Pioneer = 无;
			小字体信息(所有玩家(所有队伍), 全局.SmallHint[10]);
			事件玩家.Level += 1;
			调用子程序(SetAbility);
		Else;
			事件玩家.InteractPressState = 0;
			全局.PioneerLandingPosition = 无;
			全局.PioneerSpherePosition = 无;
			调用子程序(Reset);
			If(事件玩家.ultimate_log == 自定义字符串("已开启"));
				事件玩家.ultimate_worked = 真;
			Else;
				事件玩家.ultimate_worked = 假;
			End;
			事件玩家.UltimateUsed = 假;
			小字体信息(事件玩家, 全局.SmallHint[11]);
		End;
	}
}

规则("[热键] 开拓者取消开拓")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
		全局.PioneerLandingPosition != 无;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		事件玩家.InteractPressState == 1;
	}

	动作
	{
		设置辅助攻击模式启用(事件玩家, 真);
		可用按钮(事件玩家, 按钮(辅助攻击模式));
		事件玩家.InteractPressState = 0;
		全局.PioneerLandingPosition = 无;
		全局.PioneerSpherePosition = 无;
		调用子程序(Reset);
		If(事件玩家.pioneer_mode == 自定义字符串("超级跳"));
			事件玩家.ultimate_worked = 真;
			事件玩家.UltimateUsed = 假;
			小字体信息(事件玩家, 全局.SmallHint[2]);
		Else If(事件玩家.pioneer_mode == 自定义字符串("正常模式"));
			事件玩家.ultimate_worked = 假;
			事件玩家.UltimateUsed = 假;
			小字体信息(事件玩家, 全局.SmallHint[3]);
		Else If(事件玩家.pioneer_mode == 自定义字符串("传送点"));
			事件玩家.ultimate_worked = 假;
			事件玩家.UltimateUsed = 假;
			小字体信息(事件玩家, 全局.SmallHint[4]);
		End;
	}
}

规则("[热键] 删除最后一关")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.PioneerModeEnabled == 真;
		按钮被按下(主机玩家, 按钮(装填)) == 真;
		按钮被按下(主机玩家, 按钮(技能2)) == 真;
	}

	动作
	{
		If(数量(全局.CheckpointPosition) != 0);
			等待(0.500, 当为“假”时中止);
			小字体信息(主机玩家, 全局.SmallHint[12]);
			等待(1.500, 当为“假”时中止);
			修改全局变量(CheckpointPosition, 根据索引从数组中移除, 数量(全局.CheckpointPosition) - 1);
			修改全局变量(Ability1State, 根据索引从数组中移除, 数量(全局.Ability1State) - 1);
			修改全局变量(Ability2State, 根据索引从数组中移除, 数量(全局.Ability2State) - 1);
			修改全局变量(SecondaryFireState, 根据索引从数组中移除, 数量(全局.SecondaryFireState) - 1);
			修改全局变量(UltimateState, 根据索引从数组中移除, 数量(全局.UltimateState) - 1);
			修改全局变量(SpherePosition, 根据索引从数组中移除, 数量(全局.SpherePosition) - 1);
			全局.Pioneer = 最后(全局.Creator);
			修改全局变量(Creator, 根据索引从数组中移除, 数量(全局.Creator) - 1);
			全局.PioneerStarted = 假;
			全局.PioneerLandingPosition = 无;
			If(数量(全局.CheckpointPosition) == 0);
				小字体信息(所有玩家(所有队伍), 全局.SmallHint[13]);
			Else;
				小字体信息(所有玩家(所有队伍), 全局.SmallHint[14]);
			End;
		Else;
			小字体信息(所有玩家(所有队伍), 全局.SmallHint[14]);
		End;
	}
}

规则("[热键] 重新开始游戏")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		存活(事件玩家) == 真;
	}

	动作
	{
		If(事件玩家.Bot != 无);
			调用子程序(ReleaseBot);
		End;
		事件玩家.FreeMode = 假;
		If(事件玩家 == 全局.Pioneer);
			全局.Pioneer = 无;
			全局.PioneerLandingPosition = 无;
			全局.PioneerStarted = 假;
		End;
		事件玩家.Level = 0;
		事件玩家.HintFreq = 0;
		调用子程序(Reset);
	}
}

规则("[热键] 到上一关")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
	}

	动作
	{
		If(事件玩家.Bot != 无);
			调用子程序(ReleaseBot);
		End;
		事件玩家.HintFreq = 0;
		If(事件玩家.Level > 0);
			事件玩家.Level -= 1;
		End;
		While(全局.JumpState[事件玩家.Level] == 自定义字符串("跳跃点"));
			事件玩家.Level -= 1;
		End;
		If(事件玩家 == 全局.Pioneer);
			全局.Pioneer = 无;
			全局.PioneerLandingPosition = 无;
			全局.PioneerStarted = 假;
		End;
		调用子程序(Reset);
	}
}

规则("[热键] 到下一关")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		地图工坊设置开关(自定义字符串("快捷键"), 自定义字符串("跳关"), 真, 0) == 真;
	}

	动作
	{
		If(事件玩家.Bot != 无);
			调用子程序(ReleaseBot);
		End;
		事件玩家.HintFreq = 0;
		事件玩家.Level += 1;
		If(事件玩家.cheat == 0);
			事件玩家.cheat = 事件玩家.Level;
		End;
		等待(1, 当为“假”时中止);
		While(按钮被按下(事件玩家, 按钮(蹲下)) == 真 && 按钮被按下(事件玩家, 按钮(终极技能)) == 真 && 按钮被按下(事件玩家, 按钮(装填)) == 真);
			事件玩家.Level += 1;
			等待(0.100, 无视条件);
		End;
	}
}

规则("[热键] 成为开拓者")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.PioneerModeEnabled == 真;
		事件玩家.GameComplete == 真;
		实体存在(全局.Pioneer) == 假;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		在地面上(事件玩家) == 真;
	}

	动作
	{
		If(全局.DisableContinuousCreation && 事件玩家 == 最后(全局.Creator));
			小字体信息(事件玩家, 全局.SmallHint[15]);
		Else If(数量(全局.CheckpointPosition) == 0);
			If(在地面上(事件玩家) == 假);
				小字体信息(事件玩家, 全局.SmallHint[16]);
			Else;
				修改全局变量(CheckpointPosition, 添加至数组, 所选位置(事件玩家));
				修改全局变量(UltimateState, 添加至数组, 假);
				全局.Pioneer = 事件玩家;
			End;
		Else;
			全局.Pioneer = 事件玩家;
		End;
		事件玩家.ultimate_worked = 假;
		事件玩家.ultimate_log = 自定义字符串("已关闭");
		事件玩家.UltimateUsed = 假;
		事件玩家.pioneer_mode = 自定义字符串("正常模式");
		调用子程序(ResetBall);
	}
}

规则("[热键] 死亡观战")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
	}

	动作
	{
		事件玩家.IsSpectating = !事件玩家.IsSpectating;
		If(事件玩家.IsSpectating);
			关闭游戏预设复生模式(事件玩家);
			击杀(事件玩家, 无);
			可用按钮(事件玩家, 按钮(主要攻击模式));
			等待(0.20, 无视条件);
			If(事件玩家.SpectatingState == 假);
				按下按键(事件玩家, 按钮(跳跃));
				等待(0.20, 无视条件);
				事件玩家.SpectatingState = 真;
			End;
			If(事件玩家.Bot != 无);
				For 玩家变量(事件玩家, i, 1, 栏位(事件玩家.Bot), 1);
					按下按键(事件玩家, 按钮(主要攻击模式));
					等待(0.10, 无视条件);
				End;
			End;
		Else;
			开启游戏预设复生模式(事件玩家);
			复活(事件玩家);
			调用子程序(ResetBall);
		End;
	}
}

规则("[热键] 死亡观战切换视角")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		事件玩家.IsSpectating == 真;
	}

	动作
	{
		事件玩家.SpectatingState = !事件玩家.SpectatingState;
	}
}

规则("[热键]开拓者切换模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 全局.Pioneer;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		地图工坊设置开关(自定义字符串("快捷键"), 自定义字符串("超级跳模式开拓"), 真, 1) == 真;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) < 全局.RingRadius[1];
	}

	动作
	{
		If(事件玩家.pioneer_mode == 自定义字符串("正常模式"));
			事件玩家.pioneer_mode = 自定义字符串("超级跳");
			事件玩家.ultimate_log = 自定义字符串("已开启");
			事件玩家.ultimate_worked = 真;
			小字体信息(事件玩家, 全局.SmallHint[2]);
		Else If(事件玩家.pioneer_mode == 自定义字符串("超级跳"));
			事件玩家.pioneer_mode = 自定义字符串("传送点");
			事件玩家.ultimate_log = 自定义字符串("已关闭");
			事件玩家.ultimate_worked = 假;
			小字体信息(事件玩家, 全局.SmallHint[4]);
			事件玩家.ultimate_info = 空数组;
		Else If(事件玩家.pioneer_mode == 自定义字符串("传送点"));
			事件玩家.pioneer_mode = 自定义字符串("正常模式");
			小字体信息(事件玩家, 全局.SmallHint[3]);
		End;
	}
}

规则("[热键] 位移")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		((全局.Pioneer == 事件玩家 && 事件玩家.pioneer_mode == 自定义字符串("传送点"))) == 真;
		// (事件玩家.FreeMode || (事件玩家.GameComplete && 全局.Pioneer != 事件玩家) || (全局.Pioneer == 事件玩家 && 事件玩家.pioneer_mode == 自定义字符串("传送点"))) == 真;
		事件玩家.IsSpectating == 假;
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		传送(事件玩家, 所选位置(事件玩家) + 面朝方向(事件玩家) * 5);
		设置引力(事件玩家, 0);
		While(按钮被按下(事件玩家, 按钮(主要攻击模式)));
			传送(事件玩家, 所选位置(事件玩家) + 面朝方向(事件玩家) * 0.500);
			施加推力(事件玩家, 速率(事件玩家) * -1, 0.010, 至地图, 取消相反运动);
			等待(0.010, 当为“真”时重新开始);
		End;
		设置引力(事件玩家, 100);
	}
}

规则("[热键] 杀死玩家")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
	}

	动作
	{
		等待(0.500, 当为“假”时中止);
		击杀(事件玩家, 无);
	}
}


规则("[热键] 开关隐身")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在使用表情交流(事件玩家) == 真;
	}

	动作
	{
		事件玩家.Invisible = !事件玩家.Invisible;
		If(事件玩家.Invisible);
			设置不可见(事件玩家, 全部);
			大字体信息(事件玩家, 全局.SmallHint[17]);
		Else;
			大字体信息(事件玩家, 全局.SmallHint[18]);
			设置不可见(事件玩家, 全部禁用);
		End;
	}
}

规则("[热键] 开关自由模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		在地面上(事件玩家) == 真;
	}

	动作
	{
		等待(0.500, 当为“真”时重新开始);
		事件玩家.FreeMode = !事件玩家.FreeMode;
		If(事件玩家.FreeMode);
			修改全局变量(Pioneer, 根据值从数组中移除, 事件玩家);
			小字体信息(事件玩家, 全局.SmallHint[19]);
			调用子程序(SetAbility);
			If(事件玩家.ScoreOfThisRound != 0);
				停止追踪玩家变量(事件玩家, ScoreOfThisRound);
			End;
			If(事件玩家.Bot != 无);
				调用子程序(ReleaseBot);
			End;
		Else;
			小字体信息(事件玩家, 全局.SmallHint[20]);
			调用子程序(Reset);
			If(事件玩家.ScoreOfThisRound != 0 && !事件玩家.GameComplete);
				追踪玩家变量频率(事件玩家, ScoreOfThisRound, 16200, 1, 全部禁用);
			End;
		End;
	}
}

规则("[热键] 显示或隐藏快捷键")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 假;
		按钮被按下(事件玩家, 按钮(技能1)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 假;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
	}

	动作
	{
		等待直到 (!按钮被按下(事件玩家, 按钮(互动)), 9999);
		等待直到 (按钮被按下(事件玩家, 按钮(互动)), 0.300);
		If(按钮被按下(事件玩家, 按钮(互动)));
			事件玩家.ShowHotKey = !事件玩家.ShowHotKey;
		End;
	}
}

//超级跳
规则("开拓者超级跳")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.ultimate_worked == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		垂直速度(事件玩家) != 0;
		事件玩家 == 全局.Pioneer;
		水平速度(事件玩家) > 12;
	}

	动作
	{
		If(相距距离(全局.CheckpointPosition[事件玩家.Level], 所选位置(事件玩家)) > 6);
			事件玩家.ultimate_info = 空数组;
			设置辅助攻击模式启用(事件玩家, 假);
			事件玩家.pioneer_outline_countdown = 50;
			事件玩家.UltimateUsed = 所选位置(事件玩家);
			事件玩家.ultimate_worked = 假;
			While(Y方向分量(所选位置(事件玩家)) - Y方向分量(事件玩家.UltimateUsed) <= 3 && 事件玩家.pioneer_outline_countdown >= 1);
				等待(0.020, 无视条件);
				事件玩家.pioneer_outline_countdown -= 1;
			End;
			If(事件玩家.pioneer_outline_countdown < 1);
				施加推力(事件玩家, 速率(事件玩家) * -1, 0.010, 至地图, 取消相反运动);
				设置状态(事件玩家, 无, 冰冻, 0.500);
				传送(事件玩家, 全局.CheckpointPosition[事件玩家.Level]);
				等待(0.250, 无视条件);
				事件玩家.ultimate_worked = 真;
				事件玩家.UltimateUsed = 假;
				事件玩家.InteractPressState = 0;
				全局.PioneerLandingPosition = 无;
				调用子程序(SetAbility);
				全局.PioneerSpherePosition = 无;
			End;
		Else;
			大字体信息(事件玩家, 全局.SmallHint[24]);
		End;
	}
}

规则("防止乱跑")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		事件玩家.ultimate_worked == 真;
		垂直速度(事件玩家) > 0;
		相距距离(所选位置(事件玩家), 全局.UltimateState[事件玩家.Level + 1]) > 全局.RingRadius;
		事件玩家.GameComplete == 假;
		事件玩家.FreeMode == 假;
	}

	动作
	{
		等待(0.200, 当为“假”时中止);
		设置状态(事件玩家, 无, 定身, 0.500);
		调用子程序(Reset);
		If(事件玩家.HintFreq % 5 == 2);
			小字体信息(事件玩家, 全局.SmallHint[23]);
		End;
	}
}

规则("超级跳")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.ultimate_worked == 真;
		正在使用辅助武器(事件玩家) == 假;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		垂直速度(事件玩家) > 5;
		事件玩家 != 全局.Pioneer;
		相距距离(所选位置(事件玩家), 全局.UltimateState[事件玩家.Level + 1]) <= 全局.RingRadius[2];
	}

	动作
	{
		事件玩家.ultimate_worked = 假;
	}
}

规则("两点一线检测")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"宽度是最下面那个值"
		与此方向的水平角度(方向(事件玩家.ultimate_info[2], 所选位置(事件玩家))) < 事件玩家.ultimate_info[3] + 0.350;
		"宽度是最下面那个值"
		与此方向的水平角度(方向(事件玩家.ultimate_info[2], 所选位置(事件玩家))) > 事件玩家.ultimate_info[3] - 0.350;
		"这是长度"
		相距距离(事件玩家.ultimate_info[2], 所选位置(事件玩家)) <= 相距距离(事件玩家.ultimate_info[2], 事件玩家.ultimate_info[0]) + 2;
		"这是长度"
		相距距离(事件玩家.ultimate_info[2], 所选位置(事件玩家)) >= 相距距离(事件玩家.ultimate_info[2], 事件玩家.ultimate_info[1]) - 2;
		全局.UltimateState[事件玩家.Level + 1] != (假 || 0);
		事件玩家.FreeMode == 假;
	}

	动作
	{
		事件玩家.ultimate_outline_countdown = 2;
		等待(0.050, 当为“假”时中止);
		如条件为”真“则循环;
	}
}

规则("超出两点一线范围")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.ultimate_outline_countdown > 0;
		事件玩家.FreeMode == 假;
		事件玩家 != 全局.Pioneer;
	}

	动作
	{
		事件玩家.ultimate_outline_countdown -= 1;
		等待(0.100, 无视条件);
		如条件为”真“则循环;
		If((全局.UltimateState[事件玩家.Level + 1] && 事件玩家.ultimate_worked) != 假);
			设置状态(事件玩家, 无, 定身, 0.500);
			大字体信息(事件玩家, 全局.SmallHint[23]);
			调用子程序(Reset);
		End;
	}
}

规则("超级跳模式圈外低速复位")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		水平速度(事件玩家) <= 12;
		正在使用辅助武器(事件玩家) == 假;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		事件玩家.FreeMode == 假;
		(全局.Pioneer != 事件玩家 ? 事件玩家.GameComplete == 假 : 真) == 真;
		在地面上(事件玩家) == 真;
		(事件玩家.ultimate_worked == 假 ? 全局.UltimateState[事件玩家.Level + 1] != (假 || 0) : 真) == 真;
	}

	动作
	{
		等待(0.016, 当为“假”时中止);
		调用子程序(Reset);
	}
}

规则("超级跳模式出圈禁用抓钩")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		事件玩家.ultimate_worked == 真;
		正在使用辅助武器(事件玩家) == 假;
		事件玩家.FreeMode == 假;
		(全局.Pioneer != 事件玩家 ? 事件玩家.GameComplete == 假 : 真) == 真;
	}

	动作
	{
		设置辅助攻击模式启用(事件玩家, 假);
	}
}

规则("防止起步在空中")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.ultimate_log == 自定义字符串("已开启");
		正在空中(事件玩家) == 真;
		事件玩家 == 全局.Pioneer;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 全局.RingRadius[1];
		事件玩家.FreeMode == 假;
		事件玩家.UltimateUsed == 假;
	}

	动作
	{
		等待(0.200, 无视条件);
		根据条件中止(事件玩家.ultimate_worked == 假);
		小字体信息(事件玩家, 全局.SmallHint[22]);
		调用子程序(Reset);
	}
}

规则("开拓者两点一线写入")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.Pioneer == 事件玩家;
		事件玩家.ultimate_worked == 真;
		事件玩家.ultimate_info == 空数组;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 5;
	}

	动作
	{
		事件玩家.ultimate_info[0] = 全局.CheckpointPosition[事件玩家.Level];
		事件玩家.ultimate_info[1] = 所选位置(事件玩家);
		事件玩家.ultimate_info[2] = 事件玩家.ultimate_info[0] + 方向(事件玩家.ultimate_info[0], 事件玩家.ultimate_info[1]) * 1000;
		事件玩家.ultimate_info[3] = 与此方向的水平角度(方向(事件玩家.ultimate_info[2], 事件玩家.ultimate_info[0]));
	}
}

规则("开拓者两点一线清除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.Pioneer == 事件玩家;
		事件玩家.FreeMode == 假;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) <= 5;
	}

	动作
	{
		事件玩家.ultimate_info = 空数组;
	}
}

规则("开拓者两点一线检测")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"宽度是最下面那个值"
		与此方向的水平角度(方向(事件玩家.ultimate_info[2], 所选位置(事件玩家))) < 事件玩家.ultimate_info[3] + 0.300;
		"宽度是最下面那个值"
		与此方向的水平角度(方向(事件玩家.ultimate_info[2], 所选位置(事件玩家))) > 事件玩家.ultimate_info[3] - 0.300;
		"这是长度"
		禁用 相距距离(事件玩家.ultimate_info[2], 所选位置(事件玩家)) <= 相距距离(事件玩家.ultimate_info[2], 事件玩家.ultimate_info[0]) + 2;
		"这是长度"
		禁用 相距距离(事件玩家.ultimate_info[2], 所选位置(事件玩家)) >= 相距距离(事件玩家.ultimate_info[2], 事件玩家.ultimate_info[1]) - 2;
		事件玩家.FreeMode == 假;
		事件玩家.ultimate_log == 自定义字符串("已开启");
		事件玩家 == 全局.Pioneer;
		相距距离(所选位置(事件玩家), 全局.CheckpointPosition[事件玩家.Level]) > 5;
	}

	动作
	{
		等待(0.500, 无视条件);
		如条件为”真“则循环;
		根据条件中止(事件玩家.ultimate_info == 空数组);
		根据条件中止(事件玩家.ultimate_worked == 假);
		播放效果(事件玩家, 负面状态施加声音, 颜色(白色), 事件玩家, 30);
		大字体信息(事件玩家, 全局.SmallHint[21]);
		事件玩家.ultimate_info = 空数组;
		调用子程序(Reset);
	}
}

规则("开关跳转指定关卡")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.edit_mode == 0;
		事件玩家.IsSpectating == 假;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 假;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 假;
		按钮被按下(事件玩家, 按钮(技能1)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
	}

	动作
	{
		等待(0.650, 当为“假”时中止);
		事件玩家.JumpingCheckpoint = !事件玩家.JumpingCheckpoint;
		If(事件玩家.JumpingCheckpoint);
			创建HUD文本(事件玩家, 自定义字符串("左右移动鼠标来调整要前往的关卡\r\n　　　　　　【{0}】\r\n　　　左键确认，右键退出", 取整(数量(全局.CheckpointPosition) / 360 * (水平朝向角度(事件玩家)
				+ 180), 下)), 无, 无, 顶部, 5, 颜色(橙色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
			事件玩家.JumpingCheckpointHUD = 上一个文本ID;
			设置状态(事件玩家, 无, 定身, 9999);
		Else;
			消除HUD文本(事件玩家.JumpingCheckpointHUD);
			事件玩家.JumpingCheckpoint = 假;
			取消主要动作(事件玩家);
			清除状态(事件玩家, 定身);
		End;
	}
}

规则("跳转指定关卡")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.edit_mode == 0;
		事件玩家.IsSpectating == 假;
		事件玩家.JumpingCheckpoint != 假;
		(按钮被按下(事件玩家, 按钮(主要攻击模式)) || 按钮被按下(事件玩家, 按钮(辅助攻击模式))) == 真;
	}

	动作
	{
		If(按钮被按下(事件玩家, 按钮(主要攻击模式)));
			事件玩家.HintFreq = 0;
			If(事件玩家.cheat == 0 && 事件玩家.Level < 取整(数量(全局.CheckpointPosition) / 360 * (水平朝向角度(事件玩家) + 180), 下));
				事件玩家.cheat = 事件玩家.Level == 0 ? 1 : 事件玩家.Level;
			End;
			事件玩家.Level = 取整(数量(全局.CheckpointPosition) / 360 * (水平朝向角度(事件玩家) + 180), 下);
		Else If(按钮被按下(事件玩家, 按钮(辅助攻击模式)));
			消除HUD文本(事件玩家.JumpingCheckpointHUD);
			事件玩家.JumpingCheckpoint = 假;
			清除状态(事件玩家, 定身);
		End;
	}
}

//键盘
规则("Initial Global")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.xPos = 地图工坊设置实数(自定义字符串("键盘设置"), 自定义字符串("X-position"), -1.4, -3, 3, 0);
		全局.yPos = 地图工坊设置实数(自定义字符串("键盘设置"), 自定义字符串("Y-position"), -0.3, -2, 2, 0);
		全局.scale = 地图工坊设置实数(自定义字符串("键盘设置"), 自定义字符串("Scale"), 0.720, 0.300, 1, 1);
	}
}

规则("[热键] 开关键盘")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
	}

	动作
	{
		事件玩家.keyboard_enabled = !事件玩家.keyboard_enabled;
	}
}

规则("[热键] 按下跳跃")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
	}

	动作
	{
		事件玩家.keyboard_status_space = 真;
	}
}

规则("[热键] 松开跳跃")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
	}

	动作
	{
		事件玩家.keyboard_status_space = 假;
	}
}

规则("[热键] 按下蹲")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
	}

	动作
	{
		事件玩家.keyboard_status_ctrl = 真;
	}
}

规则("[热键] 松开蹲")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
	}

	动作
	{
		事件玩家.keyboard_status_ctrl = 假;
	}
}

规则("[热键] 按下右键")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		事件玩家.keyboard_status_right = 真;
	}
}

规则("[热键] 松开右键")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 假;
	}

	动作
	{
		事件玩家.keyboard_status_right = 假;
	}
}

规则("[热键] 按下左键")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
	}

	动作
	{
		事件玩家.keyboard_status_left = 真;
	}
}

规则("[热键] 松开左键")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 假;
	}

	动作
	{
		事件玩家.keyboard_status_left = 假;
	}
}

规则("显示键盘")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.keyboard_enabled == 真;
	}

	动作
	{
		全局.textSize = 3.600;
		全局.textX = -0.353;
		全局.textY = 0.712;
		全局.text = 自定义字符串("Q");
		全局.button = 按钮(终极技能);
		全局.text = 自定义字符串("W");
		全局.textX += 0.269;
		创建地图文本(事件玩家, 单次赋值(自定义字符串("▒")), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 4 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, 颜色(黑色), 始终不可见);
		事件玩家.MapEntity[18] = 上一个文本ID;
		创建地图文本(事件玩家, 单次赋值(全局.text), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 3.700 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, Z方向分量(阈值(事件玩家)) > 0.100 ? 颜色(白色) : 自定义颜色(33, 33, 33, 255),
			始终不可见);
		事件玩家.MapEntity[19] = 上一个文本ID;
		全局.text = 自定义字符串("E");
		全局.textX += 0.269;
		全局.button = 按钮(技能2);
		全局.text = 自定义字符串("R");
		全局.textX += 0.269;
		全局.button = 按钮(装填);
		全局.textX += 0.538;
		创建地图文本(事件玩家, 事件玩家.keyboard_status_left ? 输入绑定字符串(按钮(主要攻击模式)) : 自定义字符串(""), 逐帧更新(眼睛位置(事件玩家)
			+ 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale)) * 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale)
			- 0.200 - 0.040 * 全局.scale) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家)) - 90) + 3 * 面朝方向(事件玩家))),
			3.200 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, 颜色(白色), 始终不可见);
		事件玩家.MapEntity[20] = 上一个文本ID;
		全局.textX += 0.269;
		创建地图文本(事件玩家, 事件玩家.keyboard_status_right ? 输入绑定字符串(按钮(辅助攻击模式)) : 自定义字符串(""), 逐帧更新(眼睛位置(事件玩家)
			+ 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale)) * 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale)
			- 0.200 - 0.040 * 全局.scale) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家)) - 90) + 3 * 面朝方向(事件玩家))),
			3.200 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, 颜色(白色), 始终不可见);
		事件玩家.MapEntity[21] = 上一个文本ID;
		"Row 2"
		全局.textY -= 0.253;
		全局.text = 自定义字符串("A");
		全局.textX = -0.229;
		创建地图文本(事件玩家, 单次赋值(自定义字符串("▒")), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 4 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, 颜色(黑色), 始终不可见);
		事件玩家.MapEntity[22] = 上一个文本ID;
		创建地图文本(事件玩家, 单次赋值(全局.text), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 3.700 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, X方向分量(阈值(事件玩家)) > 0.100 ? 颜色(白色) : 自定义颜色(33, 33, 33, 255),
			始终不可见);
		事件玩家.MapEntity[23] = 上一个文本ID;
		全局.text = 自定义字符串("S");
		全局.textX += 0.269;
		创建地图文本(事件玩家, 单次赋值(自定义字符串("▒")), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 4 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, 颜色(黑色), 始终不可见);
		事件玩家.MapEntity[24] = 上一个文本ID;
		创建地图文本(事件玩家, 单次赋值(全局.text), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 3.700 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, Z方向分量(阈值(事件玩家)) < -0.100 ? 颜色(白色) : 自定义颜色(33, 33, 33, 255),
			始终不可见);
		事件玩家.MapEntity[25] = 上一个文本ID;
		全局.text = 自定义字符串("D");
		全局.textX += 0.269;
		创建地图文本(事件玩家, 单次赋值(自定义字符串("▒")), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 4 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, 颜色(黑色), 始终不可见);
		事件玩家.MapEntity[26] = 上一个文本ID;
		创建地图文本(事件玩家, 单次赋值(全局.text), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 3.700 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, X方向分量(阈值(事件玩家)) < -0.100 ? 颜色(白色) : 自定义颜色(33, 33, 33, 255),
			始终不可见);
		事件玩家.MapEntity[27] = 上一个文本ID;
		全局.text = 自定义字符串("F");
		全局.textX += 0.269;
		全局.button = 按钮(互动);
		"Row 3"
		全局.textSize = 3;
		全局.textY -= 0.253;
		全局.text = 自定义字符串("Shift");
		全局.textX = -0.478;
		全局.button = 按钮(技能1);
		全局.text = 自定义字符串("V");
		全局.textX = 0.975;
		全局.button = 按钮(近身攻击);
		全局.textSize = 3.600;
		"Row 4"
		全局.textY -= 0.253;
		全局.text = 自定义字符串("Ctrl");
		全局.textX = -0.584;
		全局.button = 按钮(蹲下);
		全局.textSize = 2;
		创建地图文本(事件玩家, 单次赋值(全局.text == 自定义字符串("Shift") ? 自定义字符串("▒▒") : (全局.text == 自定义字符串("Space")
			? 自定义字符串("▒▒▒▒▒▒") : 自定义字符串("▒"))), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale)) * 地图矢量(右, 事件玩家, 旋转) + (
			全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家)) - 90) + 3 * 面朝方向(事件玩家))),
			4 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, 自定义颜色(0, 0, 0, 180), 始终不可见);
		事件玩家.MapEntity[28] = 上一个文本ID;
		创建地图文本(事件玩家, 单次赋值(全局.text), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 单次赋值(全局.textSize * 全局.scale), 不要截取, 可见，位置，字符串和颜色, 事件玩家.keyboard_status_ctrl ? 颜色(白色) : 自定义颜色(33, 33,
			33, 255), 始终不可见);
		事件玩家.MapEntity[29] = 上一个文本ID;
		全局.text = 自定义字符串("Space");
		全局.textX = 0.446;
		全局.button = 按钮(跳跃);
		全局.textSize = 3;
		创建地图文本(事件玩家, 单次赋值(全局.text == 自定义字符串("Shift") ? 自定义字符串("▒▒") : (全局.text == 自定义字符串("Space")
			? 自定义字符串("▒▒▒▒▒▒") : 自定义字符串("▒"))), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale)) * 地图矢量(右, 事件玩家, 旋转) + (
			全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家)) - 90) + 3 * 面朝方向(事件玩家))),
			4 * 全局.scale, 不要截取, 可见，位置，字符串和颜色, 自定义颜色(0, 0, 0, 180), 始终不可见);
		事件玩家.MapEntity[30] = 上一个文本ID;
		创建地图文本(事件玩家, 单次赋值(全局.text), 逐帧更新(眼睛位置(事件玩家) + 300 * ((全局.xPos + 单次赋值(全局.textX * 全局.scale))
			* 地图矢量(右, 事件玩家, 旋转) + (全局.yPos + 单次赋值(全局.textY * 全局.scale) - 0.200) * 与此角度的相对方向(与此方向的水平角度(面朝方向(事件玩家)), 与此方向的垂直角度(面朝方向(事件玩家))
			- 90) + 3 * 面朝方向(事件玩家))), 单次赋值(全局.textSize * 全局.scale), 不要截取, 可见，位置，字符串和颜色, 事件玩家.keyboard_status_space ? 颜色(白色) : 自定义颜色(33, 33,
			33, 255), 始终不可见);
		事件玩家.MapEntity[31] = 上一个文本ID;
	}
}

规则("隐藏键盘")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.keyboard_enabled == 假;
	}

	动作
	{
		For 玩家变量(事件玩家, i, 18, 数量(事件玩家.MapEntity), 1);
			消除地图文本(事件玩家.MapEntity[事件玩家.i]);
		End;
	}
}

规则("炸房效果")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		总计消耗时间 > 16140;
	}

	动作
	{
		小字体信息(所有玩家(所有队伍), 自定义字符串("炸房倒计时: 60秒"));
		等待(50, 无视条件);
		大字体信息(所有玩家(所有队伍), 自定义字符串("— 10 —"));
		等待(1, 无视条件);
		大字体信息(所有玩家(所有队伍), 自定义字符串("— 9 —"));
		等待(1, 无视条件);
		大字体信息(所有玩家(所有队伍), 自定义字符串("— 8 —"));
		等待(1, 无视条件);
		大字体信息(所有玩家(所有队伍), 自定义字符串("— 7 —"));
		等待(1, 无视条件);
		大字体信息(所有玩家(所有队伍), 自定义字符串("— 6 —"));
		等待(1, 无视条件);
		大字体信息(所有玩家(所有队伍), 自定义字符串("— 5 —"));
		等待(1, 无视条件);
		大字体信息(所有玩家(所有队伍), 自定义字符串("— 4 —"));
		等待(1, 无视条件);
		大字体信息(所有玩家(所有队伍), 自定义字符串("— 3 —"));
		等待(1, 无视条件);
		大字体信息(所有玩家(所有队伍), 自定义字符串("— 2 —"));
		等待(1, 无视条件);
		大字体信息(所有玩家(所有队伍), 自定义字符串("— 1 —"));
		等待(1, 无视条件);
		大字体信息(所有玩家(所有队伍), 自定义字符串("Boom!"));
		等待(5, 无视条件);
		交流(所有玩家(所有队伍), 倒计时);
		等待(3, 无视条件);
		隐藏英雄HUD(所有玩家(所有队伍));
		隐藏游戏模式HUD(所有玩家(所有队伍));
		隐藏计分板(所有玩家(所有队伍));
		隐藏游戏模式地图UI(所有玩家(所有队伍));
		隐藏姓名板(所有玩家(所有队伍), 所有玩家(所有队伍));
		消除所有效果;
		消除所有图标;
		消除所有HUD文本;
		消除所有地图文本;
		移除所有机器人;
		等待(0.160, 无视条件);
		传送(所有玩家(所有队伍), 矢量(0, 500, 0));
		设置不可见(所有玩家(所有队伍), 全部);
		设置引力(所有玩家(所有队伍), 0);
		复活(所有玩家(所有队伍));
		开始镜头(所有玩家(所有队伍), (最近的可行走位置(矢量(999, 999, 999)) + 最近的可行走位置(矢量(-999, -999, -999))) / 2 + 与此角度的相对方向(比赛时间 * 7.500, -30) * 200, (
			最近的可行走位置(矢量(999, 999, 999)) + 最近的可行走位置(矢量(-999, -999, -999))) / 2, 5);
		调用子程序(PlayDestroyMapEffect);
		等待(1, 无视条件);
		重新开始比赛;
	}
}


规则("播放破坏地图效果  PlayDestroyMapEffect -- by Mazattack#1183")
{
	事件
	{
		子程序;
		PlayDestroyMapEffect;
	}

	动作
	{
		If(当前地图 == 地图(监测站：直布罗陀));
			设置比赛时间(48 + 随机整数(与此方向的水平角度(方向(目标位置(1), 目标位置(0))) / 7.500 - 12, 与此方向的水平角度(方向(目标位置(1), 目标位置(0))) / 7.500 + -6));
		Else If(当前地图 == 地图(66号公路));
			设置比赛时间(48 + 随机整数(与此方向的水平角度(方向(目标位置(1), 目标位置(0))) / 7.500 - -6, 与此方向的水平角度(方向(目标位置(1), 目标位置(0))) / 7.500 + 12));
		Else;
			设置比赛时间(48 + 随机整数(与此方向的水平角度(方向(目标位置(1), 目标位置(0))) / 7.500 - 6, 与此方向的水平角度(方向(目标位置(1), 目标位置(0))) / 7.500 + 9));
		End;
		全局.Chase = (最近的可行走位置(矢量(999, 999, 999)) + 最近的可行走位置(矢量(-999, -999, -999))) / 2 + 与此角度的相对方向(随机整数(0, 359), 随机实数(-45, -60)) * 500;
		等待(0.016, 无视条件);
		持续追踪全局变量(Chase, (最近的可行走位置(矢量(999, 999, 999)) + 最近的可行走位置(矢量(-999, -999, -999))) / 2, 5, 终点及持续时间);
		While(相距距离(全局.Chase, (最近的可行走位置(矢量(999, 999, 999)) + 最近的可行走位置(矢量(-999, -999, -999))) / 2) > 1);
			播放效果(所有玩家(所有队伍), 有益爆炸, 颜色(天蓝色), 全局.Chase, 3);
			等待(0.016, 无视条件);
		End;
		For 全局变量(Idx, 0, 400, 1);
			播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(橙色), (最近的可行走位置(矢量(999, 999, 999)) + 最近的可行走位置(矢量(-999, -999, -999))) / 2 + 与此角度的相对方向(随机实数(0, 360), 0)
				* 随机整数(0, (全局.Idx + 1) / 1), 随机整数(全局.Idx / 5, 全局.Idx));
			播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(橙色), (最近的可行走位置(矢量(999, 999, 999)) + 最近的可行走位置(矢量(-999, -999, -999))) / 2 + 与此角度的相对方向(随机实数(0, 360), 0)
				* 随机整数(0, (全局.Idx + 1) / 1), 全局.Idx);
			等待(0.016, 无视条件);
		End;
	}
}